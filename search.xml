<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CS106X_Note1</title>
      <link href="/2024/01/16/CS106X-Note1/"/>
      <url>/2024/01/16/CS106X-Note1/</url>
      
        <content type="html"><![CDATA[<h1 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h1><p>C++ 的语法和 Java 是大体相似的<br>（岂不是我学完C++可以速通Java了</p><pre><code class="cpp">using namespace name;</code></pre><p>其中 <code>namespace</code>就是变量的作用域(scope)</p><p>这种写法的好处就是我们可以让各个文件中相同名字的函数名、变量名、类名 <strong>各自独立</strong>。<br>例如我们有很多类似于<code>cout</code>的标识符，如果你需要用<code>cout</code>来打印你的内容，那就代表着你不能将一个变量命名为cout(这样会导致冲突)</p><p>如果你在两个不同的<code>namespace</code>中使用了相同名称的变量、方法或者类的时候，这都是OK的。</p><p>你在代码开头打上<code>using namespace xxx;</code>，这代表你希望获得<code>xxx</code>中所有东西的命名，以及你希望在程序中可以访问其所有内容。</p><p>例如：<code>cout</code>的全称是<code>std::cout</code>，这代表它是一个位于<code>std namespace</code>的变量。<br>但是我们一遍遍打 <strong>std::</strong> 有些痛苦，加上<code>using namespace std;</code>，就可以不用在<code>cout</code>的前面加上<code>std::</code>了。</p><hr><p><code>cin</code>是一个糟糕的用法</p><p><code>cin&gt;&gt;(int age)</code>是语法错误，无法编译。</p><p>FUCK，Vscode 无法使用StanfordLib，你妈的。</p><p>cin无法判断用户输入的内容是否匹配对应的类型，所以我们不用。</p><p>我们用<code>simpio.h</code>中的<code>getInteger("prompt")</code>,<code>getReal("prompt")</code>,<code>getLine("prompt")</code>,<code>getYesOrNo("prompt")</code>.</p><hr><h1 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h1><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><pre><code class="cpp">double circleArea(double r) {    return 3.14159265359 * r * r;}</code></pre><ol><li><p>可以利用函数指针来将一个函数作为参数传入另一个函数，也就是回调(call back)</p></li><li><p>C++对类型转换较为宽容，类似于<code>Java</code>和<code>Python</code>。例如你传入<code>1</code>到<code>circleArea</code>中，会自动转换为<code>1.0</code></p></li><li><p>C++允许默认参数<code>default parameters</code>，这是C++的一个特性，C不具备。它允许你在函数中声明一个具有默认值的参数。如果在调用函数的时候没有为这个参数提供值，它将会自动使用默认值。</p></li></ol><pre><code class="cpp">void printLine(int width = 10, char letter = '*') {    for (int i = 0; i &lt; width; i++) {        cout &lt;&lt; letter;    }}···printLine(7, '?'); // ???????printLine(5);      // *****printLine();       // **********</code></pre><p>需要注意的一点是：<strong>有默认值的参数必须在参数列表的末尾</strong>，否则函数无法判断你的参数是传递给谁的。我们也不能跳过第一个默认值，去直接给第二个默认值参数传值。默认参数只能<strong>从右至左连续地省略</strong>。</p><ol start="4"><li>一切的函数必须在使用之前就被声明或定义。这一点和C是一致的。如果有大量的函数需要被声明的话，那就可以单独建立一个头文件，然后在main函数的文件头include一下”.h”。<br>所有的默认参数值在开头的声明处写明就好，如果在函数定义处重申一遍默认值，编译器会报错。例如下面：</li></ol><pre><code class="cpp">void song(int times = 5);····void song(int times) {    ·····}</code></pre><ol start="5"><li>数学函数<br><code>#include &lt;cmath&gt;</code><br>以下来自ChatGPT:</li></ol><p><strong>三角函数</strong>:</p><ul><li><code>sin(double x)</code>: 计算角 x（以弧度为单位）的正弦。</li><li><code>cos(double x)</code>: 计算角 x（以弧度为单位）的余弦。</li><li><code>tan(double x)</code>: 计算角 x（以弧度为单位）的正切。</li><li><code>asin(double x)</code>: 计算 x 的反正弦值，结果以弧度为单位。</li><li><code>acos(double x)</code>: 计算 x 的反余弦值，结果以弧度为单位。</li><li><code>atan(double x)</code>: 计算 x 的反正切值，结果以弧度为单位。</li><li><code>atan2(double y, double x)</code>: 计算以点 (x, y) 为坐标的角度，结果以弧度为单位。</li></ul><p><strong>指数和对数函数</strong>:</p><ul><li><code>exp(double x)</code>: 计算 e 的 x 次幂。</li><li><code>log(double x)</code>: 计算 x 的自然对数（基数是 e）。</li><li><code>log10(double x)</code>: 计算 x 的常用对数（基数是 10）。</li><li><code>pow(double base, double exp)</code>: 计算 base 的 exp 次幂。</li></ul><p><strong>平方根和绝对值函数</strong>:</p><ul><li><code>sqrt(double x)</code>: 计算 x 的平方根。</li><li><code>cbrt(double x)</code>: 计算 x 的立方根。</li><li><code>abs(int n)</code> / <code>fabs(double x)</code>: 计算整数或浮点数 x 的绝对值。</li></ul><p><strong>取整函数</strong>:</p><ul><li><code>ceil(double x)</code>: 计算大于或等于 x 的最小整数。</li><li><code>floor(double x)</code>: 计算小于或等于 x 的最大整数。</li><li><code>round(double x)</code>: 返回 x 四舍五入到最接近的整数。</li></ul><p><strong>其他函数</strong>:</p><ul><li><code>fmod(double x, double y)</code>: 返回 x 除以 y 的余数。</li><li><code>hypot(double x, double y)</code>: 计算直角三角形的斜边长度，给定两个边长 x 和 y。</li></ul><ol start="6"><li>值语意(value semantics) / 引用语意(reference semantics)</li></ol><ul><li>值语意：当变量(int, double, char)作为参数传入函数时，只会<strong>复制它们的值</strong>，两者是完全独立的</li><li>引用语意：当较为复杂的对象或者数组作为参数传入函数时，会使用引用语意。两者是关联在一起的</li><li>当然，你可以自己选择语意的类型，例如你写一个<code>swap</code>函数。需要注意的是，这里的<code>int&amp; a, int&amp; b</code>的写法和<strong>指针</strong>是不同的：引用更像给<strong>变量起一个别名</strong>，你使用a, b就和使用x, y是一样的，而不是像是指针一样去访问地址。你也不需要用什么*a, *b之类的去<strong>解引用</strong>。你也就不可以将字面值作为一个引用参数传入函数中去</li></ul><pre><code class="cpp">void swap(int&amp; a, int&amp; b) {   int temp = a;   a = b;   b = temp;}····swap(x, y);</code></pre><ul><li>我们也可以通过引用参数来实现<strong>一次返回多个值</strong>的操作，例如下面：我在<code>datingRange</code>中对min, max做的任何操作，其实都是直接作用在<code>main</code>中的young, old上的。</li></ul><pre><code class="cpp">void datingRange(int age, int&amp; min, int&amp; max) {   min = age / 2 + 7;   max = (age - 7) * 2;}int main() {   int young;   int old;   datingRange(48, young, old);   ·····}</code></pre><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p><code>#include &lt;string&gt;</code> &amp; <code>string s = "hello";</code></p><p>C++中的字符串支持运算符<code>Operators</code>，例如：</p><ul><li>Concatenation串联 +/+=</li></ul><pre><code class="cpp">string s1 = "Mar";s1 += "ty"; // "Marty"</code></pre><ul><li><p>Q1:为什么有了<code>+</code>这种操作，在<code>cout</code>中还要用<code>&lt;&lt;</code>呢？</p></li><li><p>A1:因为串联操作<strong>仅支持string+string/char</strong>，对于int、double等类型无效</p></li><li><p>Compare比较 利用 == != &lt; &lt;= &gt; &gt;= 根据ASCII码大小，注意<strong>大写字母的ASCII码小</strong></p></li></ul><pre><code class="cpp">string s2 = "Cynthia";if (s1 &gt; s2 &amp;&amp; s2 != "Joe") { // true   ···}</code></pre><ul><li><p>operator overloading操作符重载<br>这是一种C++特有的语言特性，你可以<strong>重新定义操作符，让它们能处理不同的数据类型</strong>。Compare这里就用到了这一特性</p></li><li><p>Mutable可变性</p></li></ul><pre><code class="cpp">s1.append(" Stepp");       //"Marty Stepp"s1.erase(3, 2);            //"Mar  Stepp"s1[6] = 'o';               //"Mar  Stopp"</code></pre><ul><li>Q2:<code>append</code>和<code>+=</code>的区别是?</li><li>A2:前者是<strong>直接修改原有的string</strong>，后者是<strong>创建了一个新的string</strong>，相比之下，内存方面会有一些差异。</li></ul><hr><p>下面是一些string内部定义的一些函数：</p><table><thead><tr><th>函数调用</th><th>解释和用法</th></tr></thead><tbody><tr><td><code>s.append(str)</code></td><td>向字符串 <code>s</code> 的末尾追加另一个字符串 <code>str</code>。</td></tr><tr><td><code>s.assign(str)</code></td><td>将字符串 <code>s</code> 的内容替换为字符串 <code>str</code> 的副本。</td></tr><tr><td><code>s.clear()</code></td><td>清除字符串 <code>s</code> 中的所有内容，使其变为空字符串。</td></tr><tr><td><code>s.compare(str)</code></td><td>比较字符串 <code>s</code> 和 <code>str</code>。返回值 &lt; 0 表示 <code>s</code> 小于 <code>str</code>，0 表示两者相等，&gt; 0 表示 <code>s</code> 大于 <code>str</code>。</td></tr><tr><td><code>s.empty()</code></td><td>如果字符串 <code>s</code> 为空返回 <code>true</code>，否则返回 <code>false</code>。</td></tr><tr><td><code>s.erase(pos, len)</code></td><td>从字符串 <code>s</code> 中移除从 <code>pos</code> 位置开始的 <code>len</code> 个字符。</td></tr><tr><td><code>s.find(str, pos)</code></td><td>从字符串 <code>s</code> 中的 <code>pos</code> 位置开始查找子字符串 <code>str</code>。如果找到，返回子字符串的起始位置；否则返回 <code>std::string::npos</code>。</td></tr><tr><td><code>s.rfind(str, pos)</code></td><td>从字符串 <code>s</code> 中的 <code>pos</code> 位置开始回头查找子字符串 <code>str</code>。如果找到，返回子字符串的起始位置；否则返回 <code>std::string::npos</code>。 (pos为空，则默认从末尾开始)</td></tr><tr><td><code>s.length()</code></td><td>返回字符串 <code>s</code> 中的字符数。</td></tr><tr><td><code>s.replace(pos, len, str)</code></td><td>将字符串 <code>s</code> 中从 <code>pos</code> 开始的 <code>len</code> 个字符替换为字符串 <code>str</code>。</td></tr><tr><td><code>s.substr(pos, len)</code></td><td>返回一个新字符串，包含从字符串 <code>s</code> 的 <code>pos</code> 位置开始的 <code>len</code> 个字符。</td></tr><tr><td><code>s.insert(pos, str)</code></td><td>在字符串 <code>s</code> 的 <code>pos</code> 位置插入字符串 <code>str</code>。</td></tr></tbody></table><p>下面是<code>StanfordLib</code>中<code>strlib.h</code>的函数</p><table><thead><tr><th>Function name</th><th>Description</th></tr></thead><tbody><tr><td><code>endswith(str, suffix)</code></td><td>如果字符串以给定的文本结束，则为真</td></tr><tr><td><code>startswith(str, prefix)</code></td><td>如果字符串以给定的文本开始，则为真</td></tr><tr><td><code>integerToString(int)</code></td><td>将整数转换成字符串</td></tr><tr><td><code>realToString(double)</code></td><td>将实数转换成字符串</td></tr><tr><td><code>stringToInteger(str)</code></td><td>将字符串转换成整数</td></tr><tr><td><code>stringToReal(str)</code></td><td>将字符串转换成实数</td></tr><tr><td><code>equalsIgnoreCase(s1, s2)</code></td><td>如果s1和s2有相同的字符，忽略大小写，则为真</td></tr><tr><td><code>toLowerCase(str)</code></td><td>返回字符串的小写版本</td></tr><tr><td><code>toUpperCase(str)</code></td><td>返回字符串的大写版本</td></tr><tr><td><code>trim(str)</code></td><td>返回去除周围空白的字符串</td></tr></tbody></table><hr><p>C++中有两种并行的字符串存储处理方式-C(char arrays)/C++(string objects)</p><p>类似于<code>"Hi there"</code>就是<code>C string</code>，当你打出<code>s1 = "xxx"</code>,其实后台默认做了个转换，将<code>C string</code>转换为了<code>C++ string</code>并存储在<code>s1</code>中。</p><p>一切适用于C++ string的特性都不适用于C string。</p><ul><li>Q3:什么时候会出现Bug呢？</li><li>A3:例如<code>string s2 = "Hi" + "there";</code> 这是一个<code>C-string</code> + <code>C-string</code>,这个bug甚至不会导致编译错误，只是会使你的程序崩溃。因为这里只是在<strong>将地址相加</strong>，并返回一个<strong>不知道在什么地方的地址</strong>。正确的写法应该是**<code>string s2 = string("Hi") + "there";</code>,先将<code>Hi</code>转换为<code>C++-string</code>,再进行处理，就OK了。</li><li>同理，<code>C-string</code> + <code>char/int.....</code>都是不行的</li></ul><h2 id="I-O-Stream"><a href="#I-O-Stream" class="headerlink" title="I/O Stream"></a>I/O Stream</h2><p><code>#include &lt;fstream&gt;</code><br>由于<code>继承</code>的机制，例如：<code>cin</code>-&gt;<code>ifstream</code>,<code>cout</code>-&gt;<code>ofstream</code> </p><p>⬇️<code>ifstream</code></p><table><thead><tr><th>成员函数</th><th>描述</th></tr></thead><tbody><tr><td><code>f.clear();</code></td><td>重置流的错误状态（如果有的话）</td></tr><tr><td><code>f.close();</code></td><td>停止读取文件</td></tr><tr><td><code>f.eof();</code></td><td>如果流已经过了文件末尾（EOF），则返回真</td></tr><tr><td><code>f.fail();</code></td><td>如果最后一次读取调用失败（例如 EOF），则返回真</td></tr><tr><td><code>f.get();</code></td><td>读取并返回一个字符</td></tr><tr><td><code>f.open("filename");</code></td><td>用给定的C字符串打开文件（如果传递了C++字符串，可能需要写 <code>.c_str()</code>）</td></tr><tr><td><code>f.open(s.c_str());</code></td><td>同上</td></tr><tr><td><code>f.unget(ch);</code></td><td>取消读取一个字符</td></tr><tr><td><code>f &gt;&gt; var;</code></td><td>从输入文件读取数据到变量（类似 cin）；一次读取一个由空白分隔的标记</td></tr><tr><td><code>getline(f&amp;, s&amp;);</code></td><td>将输入行读取到字符串，通过引用；返回成功/失败的真/假指示器</td></tr></tbody></table><p><strong>open</strong> a file,<strong>read</strong> each line,<strong>close</strong> it.</p><pre><code class="cpp">// read and print every line of a file#include &lt;fstream&gt;...ifstream input;input.open("poem.txt"); string line;while (getline(intput, line)) {   cout &lt;&lt; line &lt;&lt; endl;}input.close();</code></pre><p>一个常见的错误⬇️</p><pre><code class="cpp">// incorrect (why?)while (!input.fail()) {   string line;   getline(input, line);   cout &lt;&lt; line &lt;&lt; endl;}</code></pre><p>问题点在于：<code>getline</code>读取到文件的末尾时，并不会立刻将<code>input</code>的<code>fail</code>状态设置成<code>true</code>，而是先设置<code>eof</code>，当下一次尝试读取时(即读取一个<code>eof</code>状态的文件，才会将他的<code>fail</code>状态更为<code>true</code>)。这就会产生一个问题：最后一次读取<code>input</code>的时候失败了，没有对<code>line</code>进行任何更改，也就导致<em>最后一行输出了两次</em>，随后才会终止while循环 </p><hr><p><code>#include &lt;sstream&gt;</code></p><p><code>istringstream</code>可以将一整个<code>string</code>读取进来，然后逐个<code>word</code>进行处理</p><pre><code class="cpp">// read specific word tokends from a stringistringstream input("Jenny Smith 8675309");string first, last;int phone;input &gt;&gt; first &gt;&gt; last;input &gt;&gt; phone;cout &lt;&lt; first &lt;&lt; " " &lt;&lt; last &lt;&lt; " " &lt;&lt; phone &lt;&lt; endl;// Jenny Smith 8675309</code></pre><pre><code class="cpp">istringstream input2("To be or not to be");string word; while (input2 &gt;&gt; word) {    cout &lt;&lt; word &lt;&lt; endl;}</code></pre><p><code>ostringstream</code>可以创建一个<code>string</code>的<code>buffer</code>缓冲区，将你的输出存储起来。最后使用<code>str</code>来读取其内容。</p><pre><code class="cpp">ostringstream output;int age = 42, iq = 79;output &lt;&lt; "My age is " &lt;&lt; age &lt;&lt; endl;output &lt;&lt; "and my IQ is " &lt;&lt; iq &lt;&lt; endl;string result = output.str();cout &lt;&lt; result &lt;&lt; endl;// My age is 42\nand my IQ is 79\n</code></pre><p><code>StanfordLib</code>-<code>filelib.h</code></p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>createDirectory(name);</code></td><td>用给定的名称创建一个新目录</td></tr><tr><td><code>deleteFile(name);</code></td><td>从磁盘中删除一个文件</td></tr><tr><td><code>fileExists(name)</code></td><td>如果给定的文件在磁盘上存在，则返回真</td></tr><tr><td><code>getCurrentDirectory()</code></td><td>返回C++程序目录的字符串形式</td></tr><tr><td><code>isDirectory(name), isFile(name)</code></td><td>基于文件路径的类型返回真</td></tr><tr><td><code>openFile(ifstream&amp;, name);</code></td><td>方便地使用C++字符串打开文件</td></tr><tr><td><code>promptUserForFile(ifstream&amp;, prompt)</code></td><td>重复提示用户输入现有文件的名称</td></tr><tr><td><code>readEntireFile(ifstream&amp;, Lines&amp;);</code></td><td>将文件数据读入到行的集合中</td></tr><tr><td><code>renameFile(oldname, newname);</code></td><td>更改文件的名称</td></tr></tbody></table><hr><h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><p><code>#include "grid.h"</code><br>一种<code>collection</code>容器-&gt;<strong>存储数据的数据结构</strong>，数据的独立片段则被称为<strong>elements</strong>元素。</p><p><code>Grid</code>是二维数组,**一定要标明元素的数据类型。默认值是0/false(bool)</p><p>需要强调的一点是：<strong>当你想把一个<code>Grid</code>作为参数传入到函数当中去的时候，<code>Copying</code>是很慢的，严重拖慢效率，直接reference(&amp;)引用传递就好</strong></p><p>还需要强调的一点是：<strong>当你不希望你传入的<code>Grid</code>被修改时，请善用<code>const</code></strong></p><pre><code class="cpp">// constructing a GridGrid&lt;int&gt; matrix(3, 4);martix[0][0] = 75;...// or specify elements in {}Grid&lt;int&gt; matrix = {   {75,24,3,3},   {23,4,5,4},   {1,2,1,1}};</code></pre><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Grid&lt;type&gt; name(r, c);</code></td><td>创建一个给定行数/列数的网格；如果省略，则创建一个空的0x0网格</td></tr><tr><td><code>g[r][c];</code></td><td>返回给定行/列的值</td></tr><tr><td><code>g.fill(value);</code></td><td>设置每个格子为给定的值</td></tr><tr><td><code>g.inBounds(r, c)</code></td><td>如果给定位置在网格内，则返回真</td></tr><tr><td><code>g.numCols()</code> 或 <code>g.width()</code></td><td>返回列数</td></tr><tr><td><code>g.numRows()</code> 或 <code>g.height()</code></td><td>返回行数</td></tr><tr><td><code>g.resize(nRows, nCols);</code></td><td>将网格调整为新的大小，并丢弃旧内容</td></tr><tr><td><code>g[r][c] = value;</code> 或 <code>g.set(r, c, value);</code></td><td>在给定行/列存储值</td></tr><tr><td><code>g.toString()</code></td><td>返回网格的字符串表示形式，例如 <code>"{{3, 42}, {-7, 1}, {5, 19}}"</code></td></tr><tr><td><code>ostr &lt;&lt; g</code></td><td>打印网格，例如 <code>{{3, 42}, {-7, 1}, {5, 19}}</code></td></tr></tbody></table><hr><h1 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h1><h2 id="Vector-aka-list"><a href="#Vector-aka-list" class="headerlink" title="Vector(aka list)"></a>Vector(aka list)</h2><p><code>#include "vector.h"</code></p><p>依旧是一个<code>collection</code> 容器，负责<strong>从0开始索引存储内容</strong>，一个可以<strong>动态调整大小</strong>的数组。</p><pre><code class="cpp">// initialize a vector containing 5 integers//          index 0  1  2  3  4Vector&lt;int&gt; nums {1, 2, 3, 4, 5} //不需要加"="Vector&lt;string&gt; names;names.add("Tom");       //{"Tom"}names.add("Jay");       //{"Tom", "Jay"}names.insert(0, "Liu")  //{"Liu", "Tom", "Jay"}</code></pre><ul><li>Q4: 为什么不用<code>Arrays</code>?</li><li>A4: 1. Arrays有着固定的大小，且很难更改其大小。  2. 无法判断访问是否越界，是否会访问到垃圾内存上。  3.没有那些实用的函数</li></ul><p>一些常用的函数如下⬇️</p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>v.add(value);</code> 或 <code>v += value;</code> 或 <code>v += v1, v2, ..., vN;</code></td><td>在向量末尾添加一个或多个值</td></tr><tr><td><code>v.clear();</code></td><td>移除所有元素</td></tr><tr><td><code>v[i]</code> 或 <code>v.get(i);</code></td><td>返回给定索引处的值</td></tr><tr><td><code>v.insert(i, value);</code></td><td>在给定索引之前插入值，并将后续的值向右移动</td></tr><tr><td><code>v.isEmpty();</code></td><td>如果向量不包含任何元素，则返回真</td></tr><tr><td><code>v.remove(i);</code></td><td>移除/返回给定索引处的值，并将后续的值向左移动</td></tr><tr><td><code>v[i] = value;</code> 或 <code>v.set(i, value);</code></td><td>在给定索引处替换值</td></tr><tr><td><code>v.subList(start, length);</code></td><td>返回索引子范围的新向量</td></tr><tr><td><code>v.size();</code></td><td>返回向量中元素的数量</td></tr><tr><td><code>v.toString();</code></td><td>返回向量的字符串表示形式，例 如 <code>"{{3, 42, -7, 15}}"</code></td></tr><tr><td><code>ostr &lt;&lt; v;</code></td><td>打印向量中的元素</td></tr></tbody></table><p>C++在<code>c++17</code>后开始有了<strong>模板推断</strong>的特性，也就是你在<code>&lt;&gt;</code>输入为空的话，编译器会<strong>自行判断数据类型</strong></p><p>下面是一个小练习，写一个函数，目的是删除整个<code>vector</code>里所有的<code>string s</code></p><pre><code class="cpp">void removeAll(Vector&lt;string&gt;&amp; v, string s) {   for (int i = v.size() - 1; i &gt;= 0; i--) {      if (v[i] == s) {         v.remove(i);      }   }}</code></pre><ul><li><strong>注意⚠️！！</strong> <strong>是<code>Vector</code>,V要大写</strong></li><li>为什么从后往前查找呢？</li></ul><h3 id="Vector-insert"><a href="#Vector-insert" class="headerlink" title="Vector insert"></a>Vector insert</h3><p><code>Vector</code>内部是用<code>Arrays</code>来实现的，那么是如何实现动态容量的呢？</p><p>由于<code>Arrays</code>本身并没有调整大小的功能，所以size总会比我们实际所需的大一些。例如我们创建了一个包含<code>6个int的Vector</code>，那么他的实际大小可能是10/20/30… 但是<strong>这个实际大小确实是固定的</strong>，当我们所需的大小超过了目前的实际大小，那么就会<strong>重新创建</strong>一个实际大小更大的<code>Arrays</code>，<strong>并把原来的数据Copy过去</strong></p><hr><h2 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h2><p>一种通过代码来判断计算机资源使用情况的方法：通常与<strong>速度(运行时间)/内存(占用空间)<strong>有关，大多数都是</strong>参考运行时间</strong></p><p>为了方便评估，我们有如下假设：</p><ul><li>A single statement’s runtime = 1</li><li>A function call’s runtime = (sum of runtime of statements in function’s body)</li><li>A loop of N iterations   ‘ runtime = (N * (loop body’s runtime))</li></ul><p>下面是一个例子：⬇️</p><pre><code class="cpp">statement1;                // runtime = 1for (int i = 1; i &lt;= N; i++) {      // runtime = N^2    for (int j = 1; j &lt;= N; j++) {  // runtime = N        statement2;    }}for (int i = 1; i &lt;= N; i++) {      // runtime = 3N    statement3;    statement4;    statement5;}// total = N^2 + 3N + 1</code></pre><p>通常来说我们只关心<strong>影响运行时间的最大因素</strong>，并将<strong>表达式中的参数都忽略掉</strong>。例如上面👆这个例子我们就可以用O(N^2)来概括</p><hr><h1 id="Part4"><a href="#Part4" class="headerlink" title="Part4"></a>Part4</h1><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><code>#include "list.h"</code><br><code>LinkedList</code>提供了和<code>Vector</code>几乎一样的函数。</p><pre><code class="cpp">LinkedList&lt;int&gt; list; // 要声明元素存储类型for (int i = 1; i &lt;= 8; i++) {   list.add(10 * i); // {10, 20, 30, 40, 50, 60, 70, 80}}</code></pre><p>一个笑话：计算机科学家讨厌三件东西,redundancy(冗余),inefficiency(低效)和redundancy(冗余)</p><ul><li>Q5:为什么要在已经有<code>Vector</code>的情况下，还要在设计一个几乎相同的collection <code>LinkedList</code>呢？</li><li>A5:因为两者内部是不同的实现方式，前者是<code>Arrays</code>，后者是<code>Nodes</code></li></ul><hr><h2 id="Abstract-data-types-ADTs"><a href="#Abstract-data-types-ADTs" class="headerlink" title="Abstract data types (ADTs)"></a>Abstract data types (ADTs)</h2><p>一类<strong>数据类型和操作方法</strong>的集合，主要关注<strong>这个集合能做什么</strong>，而不是<strong>它如何做什么</strong></p><p>我们可以将<code>Vector</code>和<code>LinkedList</code>都归类为<code>list</code>.其他的一些ADTs还有：<code>stack, queue, set, map, graph</code></p><h2 id="Stacks-and-queues"><a href="#Stacks-and-queues" class="headerlink" title="Stacks and queues"></a>Stacks and queues</h2><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240116/1705372931222.webp" alt="1705372931222"></p><h3 id="Stacks"><a href="#Stacks" class="headerlink" title="Stacks"></a>Stacks</h3><p><code>#include "stack.h"</code></p><ul><li>Add/remove from “top” only. Last-In, First-Out (LIFO)</li><li>元素按照插入的顺序进行存储。我们认为他们没有序号(index)</li><li>只能对最上面的(最后一个插入的)元素进行操作(add/remove/examine)</li><li>基础的一些操作⬇️</li><li><strong>push</strong>: Add an element to the top.</li><li><strong>pop</strong>:  Remove the top element.</li><li><strong>peek</strong>: Examine the top element.</li></ul><table><thead><tr><th>方法</th><th>时间复杂度</th><th>描述</th></tr></thead><tbody><tr><td><code>s.isEmpty()</code></td><td>O(1)</td><td>如果栈没有元素则返回真</td></tr><tr><td><code>s.peek()</code></td><td>O(1)</td><td>返回栈顶元素但不移除它；如果栈为空则抛出错误</td></tr><tr><td><code>s.pop()</code></td><td>O(1)</td><td>移除并返回栈顶元素；如果栈为空则抛出错误</td></tr><tr><td><code>s.push(value);</code></td><td>O(1)</td><td>将给定值放到栈顶</td></tr><tr><td><code>s.size()</code></td><td>O(1)</td><td>返回栈中元素的数量</td></tr></tbody></table><pre><code class="cpp">Stack&lt;int&gt; s;              // {}s.push(42);                // {42}s.push(-3);                // {42, -3}s.push(17);                // {42, -3, 17}cout &lt;&lt; s.pop() &lt;&lt; endl;   // 17  (s is {42, -3})cout &lt;&lt; s.peek() &lt;&lt; endl;  // -3  (s is {42, -3})cout &lt;&lt; s.pop() &lt;&lt; endl;   // -3  (s is {42})</code></pre><p><code>Stack</code>内部是通过<code>Arrays</code>或者<code>Vector</code>实现的</p><ul><li>“bottom” = index 0</li><li>“top”    = index (size - 1)   (便于进行操作)</li></ul><p>当然，你也可以用<code>LinkedList</code>来实现</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><code>#include "queue.h"</code></p><ul><li>Add to “back” only; remove from “front” only. First-In, First-Out(FIFO)</li><li>元素按照按照插入顺序进行存储，没有index</li><li>只能在队尾<code>add</code>，在前面<code>examine/remove</code></li><li>基础的一些操作⬇️</li><li><strong>enqueue</strong>: Add an element to the back.</li><li><strong>dequeue</strong>: Remove the front element.</li><li><strong>peek</strong>:    Examine the front element.</li></ul><table><thead><tr><th>方法</th><th>时间复杂度</th><th>描述</th></tr></thead><tbody><tr><td><code>q.dequeue()</code></td><td>O(1)</td><td>移除并返回队列前端的值；如果队列为空则抛出错误</td></tr><tr><td><code>q.enqueue(value);</code></td><td>O(1)</td><td>在队列后端放置给定的值</td></tr><tr><td><code>q.isEmpty()</code></td><td>O(1)</td><td>如果队列没有元素则返回真</td></tr><tr><td><code>q.peek()</code></td><td>O(1)</td><td>返回队列前端的值但不移除；如果队列为空则抛出错误</td></tr><tr><td><code>q.size()</code></td><td>O(1)</td><td>返回队列中元素的数量</td></tr></tbody></table><p>和<code>Stacks</code>一样，必须将<strong>所有的元素出列</strong>才可以遍历它们。</p><pre><code class="cpp">// process (and destory) an entire queuewhile (!q.isEmpty()) {   do something with q.dequeue();}</code></pre><p>Another version:</p><pre><code class="cpp">int size = q.size(); // 要注意，queue是FIFO，这一套操作下来，其实整体是没有改变的，先出来，再塞到末尾。这种方式不会丢失内容for (int i = 0; i &lt; size; i++) {   do something with q.dequeue();   (including possibly re-adding it to the queue)}</code></pre><pre><code class="cpp">void mirror (Queue&lt;string&gt;&amp; p) {    Stack&lt;string&gt; s;    int size = p.size();    string tmp;    for (int i = 0; i &lt; size; i++) {        tmp = p.dequeue();        s.push(tmp);        p.enqueue(tmp);    }    for (int i = 0; i &lt; size; i++) {        p.enqueue(s.pop());    }}</code></pre><h2 id="Sets-and-Maps"><a href="#Sets-and-Maps" class="headerlink" title="Sets and Maps"></a>Sets and Maps</h2><h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240116/1705410426723.jpg" alt="Sets"><br><code>#include "set.h"</code> &amp; <code>#include "hashset.h"</code></p><ul><li>包含若干<strong>不重复的</strong>元素。</li><li>没有index，没有顺序，我们也不关系它们的顺序</li><li>有两种实现方式：<code>Set</code> / <code>HashSet</code></li><li><code>Set</code>会将数据存储在一个<strong>二叉树</strong>中。而<code>HashSet</code>则是将数据H<strong>ash化并用Array存储</strong></li><li>同时，<code>Sets</code>也支持<strong>操作符的使用</strong></li></ul><table><thead><tr><th>成员</th><th>Set</th><th>HashSet</th><th>描述</th></tr></thead><tbody><tr><td><code>s.add(value);</code></td><td>O(log N)</td><td>O(1)</td><td>向集合中添加给定值</td></tr><tr><td><code>s.clear();</code></td><td>O(N)</td><td>O(N)</td><td>移除集合中的所有元素</td></tr><tr><td><code>s.contains(value)</code></td><td>O(log N)</td><td>O(1)</td><td>如果找到给定值则返回真</td></tr><tr><td><code>s.isEmpty()</code></td><td>O(1)</td><td>O(1)</td><td>如果集合中没有元素则返回真</td></tr><tr><td><code>s.isSubsetOf(set)</code></td><td>O(N log N)</td><td>O(N)</td><td>如果这个集合是另一个集合的子集则返回真</td></tr><tr><td><code>s.remove(value);</code></td><td>O(log N)</td><td>O(1)</td><td>从集合中移除给定值</td></tr><tr><td><code>s.size()</code></td><td>O(1)</td><td>O(1)</td><td>返回集合中的元素数量</td></tr><tr><td><code>s.toString()</code></td><td>O(N)</td><td>O(N)</td><td>返回集合的字符串表示，例如 “{3, 42, -7, 15}”</td></tr><tr><td><code>ostr &lt;&lt; s</code></td><td>O(N)</td><td>O(N)</td><td>将集合打印到流中</td></tr></tbody></table><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td><code>s1 == s2</code></td><td>如果集合包含完全相同的元素则返回真</td></tr><tr><td><code>s1 != s2</code></td><td>如果集合不包含相同的元素则返回真</td></tr><tr><td><code>s1 + s2</code></td><td>返回集合 s1 和 s2 的并集（来自任一集合的元素）</td></tr><tr><td><code>s1 += s2;</code></td><td>将集合 s1 设置为 s1 和 s2 的并集（或向 s1 添加一个值）</td></tr><tr><td><code>s1 * s2</code></td><td>返回集合 s1 和 s2 的交集（在两个集合中都存在的元素）</td></tr><tr><td><code>s1 *= s2;</code></td><td>将集合 s1 设置为 s1 和 s2 的交集</td></tr><tr><td><code>s1 - s2</code></td><td>返回集合 s1 和 s2 的差集（在 s1 中但不在 s2 中的元素）</td></tr><tr><td><code>s1 -= s2;</code></td><td>将集合 s1 设置为s1 和 s2 的差集（或从 s1 中移除一个值）</td></tr></tbody></table><ul><li>Q6: 那我们什么时候需要用<code>Sets</code>来解决问题呢？</li><li>A6: 例如：计算一些文本中<strong>有多少种单词</strong>(比如”to”出现了55次，也只算1种) </li><li>Q7: 什么时候用<code>Set</code>，什么时候用<code>HashSet</code>呢？</li><li>A7: 需要<strong>有序</strong>时，用前者；否则用后者以获得更快性能。</li></ul><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240116/1705415408686.jpg" alt="1705415408686"><br><code>#include "map.h"</code>; <code>#include "hashmap.h"</code>; </p><pre><code class="cpp">Map&lt;string, int&gt; votes // maps from string keys to integer values</code></pre><ul><li>一种用来存储<strong>一对数据</strong>的collection, (key, value)。<code>key</code>相当于是<strong>索引</strong>，<code>value</code>是<strong>具体的值</strong></li><li>同样的，我们也有两种的<code>Maps</code>类型：<code>Map</code> / <code>HashMap</code></li><li>其内部原理和<code>Sets</code>几乎相同，<code>Map</code>用<strong>二叉树存储</strong>，而<code>HashMap</code>存储<strong>Hash化后的数据</strong>，利弊也是类似的</li><li>基础的一些操作⬇️</li><li><strong>m.put(key, value)</strong>: Add a key/value pair to the map.</li><li><strong>m.get(key)</strong>:        Returns the value paired with the given key.(return a default value if the key is not found)</li><li><strong>m.remove(key)</strong>:     Remove the given key and its paired value.</li></ul><table><thead><tr><th>成员</th><th>Map</th><th>HashMap</th><th>描述</th></tr></thead><tbody><tr><td><code>m.clear();</code></td><td>O(N)</td><td>O(N)</td><td>移除所有键/值对</td></tr><tr><td><code>m.containsKey(key)</code></td><td>O(log N)</td><td>O(1)</td><td>如果映射中有给定键的对应项则返回真</td></tr><tr><td><code>m[key]</code> 或 <code>m.get(key)</code></td><td>O(log N)</td><td>O(1)</td><td>返回给定键映射的值；如果未找到，则添加具有默认值的项</td></tr><tr><td><code>m.isEmpty()</code></td><td>O(1)</td><td>O(1)</td><td>如果映射不包含任何对则返回真</td></tr><tr><td><code>m.keys()</code></td><td>O(N)</td><td>O(N)</td><td>返回映射中所有键的向量副本</td></tr><tr><td><code>m[key] = value;</code> 或 <code>m.put(key, value);</code></td><td>O(log N)</td><td>O(1)</td><td>添加一个键/值对；如果键已存在，替换其值</td></tr><tr><td><code>m.remove(key);</code></td><td>O(log N)</td><td>O(1)</td><td>移除给定键的任何对</td></tr><tr><td><code>m.size()</code></td><td>O(1)</td><td>O(1)</td><td>返回映射中对的数量</td></tr><tr><td><code>m.toString()</code></td><td>O(N)</td><td>O(N)</td><td>返回映射的字符串表示，例如 “{a: 90, d: 60, c: 70}”</td></tr><tr><td><code>m.values()</code></td><td>O(N)</td><td>O(N)</td><td>返回映射中所有值的向量副本</td></tr><tr><td><code>ostr &lt;&lt; m</code></td><td>O(N)</td><td>O(N)</td><td>将映射打印到流中</td></tr></tbody></table><h3 id="Lexicon"><a href="#Lexicon" class="headerlink" title="Lexicon"></a>Lexicon</h3><p><code>#include "lexicon.h"</code></p><ul><li>有和<code>Sets</code>一样的方法和接口，就是一个<strong>大字典</strong></li><li>默认就是存储<code>String</code>, 按<code>字典序</code>排列</li></ul><table><thead><tr><th>成员方法</th><th>Big-Oh</th><th>描述</th></tr></thead><tbody><tr><td><code>Lexicon name;</code></td><td>O(N*len)</td><td>创建空词典或从文件读取</td></tr><tr><td><code>Lexicon name("file");</code></td><td>O(N*len)</td><td>从文件创建词典</td></tr><tr><td><code>L.add(word);</code></td><td>O(len)</td><td>向词典中添加给定单词</td></tr><tr><td><code>L.addWordsFromFile("f");</code></td><td>O(N*len)</td><td>从输入文件添加所有单词（每行一个）</td></tr><tr><td><code>L.clear();</code></td><td>O(N*len)</td><td>移除词典中的所有元素</td></tr><tr><td><code>L.contains("word")</code></td><td>O(len)</td><td>如果在词典中找到单词则返回真</td></tr><tr><td><code>L.containsPrefix("str")</code></td><td>O(len)</td><td>如果 s 是词典中任意单词的开始则返回真</td></tr><tr><td><code>L.isEmpty()</code></td><td>O(1)</td><td>如果词典中没有单词则返回真</td></tr><tr><td><code>L.remove("word");</code></td><td>O(len)</td><td>如果存在，则从词典中移除单词</td></tr><tr><td><code>L.removePrefix("str");</code></td><td>O(len)</td><td>移除所有以特定前缀开始的单词</td></tr><tr><td><code>L.size()</code></td><td>O(1)</td><td>返回词典中的单词数量</td></tr><tr><td><code>L.toString()</code></td><td>O(M)</td><td>返回词典的字符串表示，例如 “{ ‘arm’, ‘cot’, ‘zebra’ }”</td></tr></tbody></table><h1 id="Part-5"><a href="#Part-5" class="headerlink" title="Part 5"></a>Part 5</h1><h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><p><strong>self—similar</strong></p><ul><li><p>这描述了一种<strong>自己运行时调用自己</strong>的算法或处理方式</p></li><li><p>What is recursive programming?</p></li><li><p>Writting a function that calls itself.</p></li></ul><p>eg: Factorial(N)</p><pre><code class="cpp">int fact(int n){   if (n &lt;= 1){       return 1;      // Base case   }else{      int result = n * fact(n - 1); // Recursive case      return result;   }   }</code></pre><ul><li><p>recursion &amp; iteration</p></li><li><p>其实recursion在效率上是<strong>远远不如iteration</strong>的，尤其当其调用过多后，很有可能会造成<strong>stack overflow</strong>。很多问题也不适合利用recursion来解决。</p></li><li><p>Q8: 什么类型的问题或者算法适合用recursion来解决呢？</p></li><li><p>A8: 有<code>self-similar</code>(自相似)特性的算法。=&gt; 我怎么描述这个算法使得其能<strong>被一个更小更相似的版本</strong>来刻画</p></li><li><p><strong>base case</strong> : 最简单的情况，直接给出答案</p></li><li><p><strong>recursive case</strong> : 一些无法被直接回答的情况。但是你可以通过其他<strong>更小的更简单的</strong>情况来刻画它</p></li></ul><h2 id="backtracking"><a href="#backtracking" class="headerlink" title="backtracking"></a>backtracking</h2><p>回溯</p><p>这是一种采取recursion来解决**涉及对(true)错(false)**的问题的特定方法。<br>如果你遇到了false，那就通过backtracking来寻找争取的路。<br>我们先从<code>exhaustive search</code>(穷举搜索)开始。backtracking作为其一种形式</p><h3 id="exhaustive-search"><a href="#exhaustive-search" class="headerlink" title="exhaustive search"></a>exhaustive search</h3><ul><li><p>尝试每一种可能的组合</p></li><li><p>搜索空间经常包含许多<code>选择</code>，每一种选择都有很多的<code>可选项</code>。</p></li><li><p>什么时候我们可能会用到穷举搜索呢？ 例如：<strong>搜索目录树结构</strong>、<strong>对一组数值进行排列或搜索的情况</strong>(-&gt;逻辑组合、组合数学、名称、密码……)</p></li></ul><hr><ul><li>一个通用的穷举搜索的伪代码：</li></ul><pre><code class="cpp">function Search(decisions): - If there are decisions left to make:   // Let's handle one decision ourselves, and the rest by recursion.   For each available choice C for this decision:      - Choose C.      - Search the remaining decisions that could follow C. - Otherwise, if there are no more decisions to make: Stop.</code></pre><p>这里的<code>base case</code>不再代表<strong>一种简单普通的情况</strong>，而是代表<strong>走到头了</strong>，<strong>我这个stack已经堆到要求的高度了</strong>，没什么可以接着选了。</p><hr><p>例子：printBinary 打印指定位数的所有二进制数.</p><pre><code class="cpp">void printBinary (int digits, string prefix = "") {   if (digits == 0) {      cout &lt;&lt; prefix &lt;&lt; endl; // 这个base case并不是什么都不做，而是将我们之前的成功(完整的prefix)打印出来   }else {      printBinary(digits - 1, prefix + "0");      printBinary(digits - 1, prefix + "1");   }}</code></pre><p>printDecimal 打印所有的十进制数</p><pre><code class="cpp">void printDecimal (int digits, string prefix = "") {   if (digits == 0) {      cout &lt;&lt; prefix &lt;&lt; endl; // 这个base case并不是什么都不做，而是将我们之前的成功(完整的prefix)打印出来   }else {      printDecimal(digits - 1, prefix + "0");      printDecimal(digits - 1, prefix + "1");      printDecimal(digits - 1, prefix + "2");      printDecimal(digits - 1, prefix + "3");      printDecimal(digits - 1, prefix + "4");      printDecimal(digits - 1, prefix + "5");      printDecimal(digits - 1, prefix + "6");      printDecimal(digits - 1, prefix + "7");      printDecimal(digits - 1, prefix + "8");      printDecimal(digits - 1, prefix + "9");   }}</code></pre><p>permute 打印所有字母的排列组合</p><pre><code class="cpp">void permute (string s, string perfix = "") {    int length = s.length();    if (length &lt; 1) {        cout &lt;&lt; perfix &lt;&lt; endl;    }else {        for (int i = 0; i &lt; length; i++) {            char x = s[i];            string y = s;            y.erase(i,1);            permute(y, perfix + x);        }    }}</code></pre><h3 id="backtracking-1"><a href="#backtracking-1" class="headerlink" title="backtracking"></a>backtracking</h3><p>回溯法是<strong>穷尽搜索</strong>和<strong>筛选</strong>相结合的一种方法，它在探索解空间的时候，加入了<em>过滤</em>的思想。这样我们就可以<strong>找到问题的最优解或者满足特定条件的解决方案</strong></p><ul><li><p>这是一种暴力技巧，它会检查所有的可能性(至少确保考虑了所有情况)</p></li><li><p>同时，由于这类算法和策略通常具有<strong>自相似性</strong>，通过递归来实现解决方案通常会<strong>更加直观和易于理解</strong></p></li><li><p>-&gt; 递归能够更自然的表达问题与解决方案之间的关系，使代码更易读以及可维护</p></li><li><p>backtracking的伪代码：</p></li></ul><pre><code class="cpp">function Search(decisions): - If there are decisions left to make:   // Let's handle one decision ourselves, and the rest by recursion.   For each available choice C for this decision:      - Choose C.      - Search the remaining decisions that could follow C.      - **Un-choose C** -&gt;(Backtrack!) - Otherwise, if there are no more decisions to make: Stop.</code></pre><p>在进行选择时，你会修改目前的状态，而在后续的搜索过程中，你会发现这种修改<strong>并不符合你的要求或者期望</strong>。因此，你需要<strong>撤销之前的选择</strong>，回到之前的状态，以便重新尝试其他的选择。-&gt; 确保你可以找到满足条件的解决方案</p><ul><li><strong>8皇后问题</strong></li><li>在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法</li><li>很明显的解决思路是： 我们应在放置一个皇后时，通过其被摆放的位置，来限制接下来皇后可能存在的位置，来减少查找空间的大小。这样可以逐步缩小解的范围，使我们更快的找到有效的解决方案</li></ul><h1 id="Part-6"><a href="#Part-6" class="headerlink" title="Part 6"></a>Part 6</h1><h2 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h2><p>一种*<strong>轻量化的</strong>类，相当于给各类数据打了个包。</p><pre><code class="cpp">struct Date {     // 声明一个structure的名称   int month;   int day;       // 各类成员的名称与类型}···Date today;       //初始化today.month = 10;today.day = 23;Date xmas = {12, 25}; // 按顺序来实现初始化+赋值</code></pre><p>当然，你也可以在里面写一些<strong>你定义的函数</strong>，在这些函数里，你可以<strong>直接 使用结构体里的变量</strong></p><pre><code class="cpp">struct Date {        int month;   int day;          int daysInMonth() {       if (month == 9 || month == 4      ||  month == 6 || month == 11) {         return 30;      }else if (month == 2) {         return 28; // 这里就不考虑闰年的情况了      }else { return 31; }   }   string toString() {      return integerToString(month) + "/" + integerToString(day);   }}</code></pre><p>结构体里的东西默认是公开的(public)，意味着你可以直接访问它并查看其变量的值。<br>而对于类来说，里面的东西默认是私有的(private)，意味着当你想直接访问/修改里面的变量，编译器会报错：你没有这个权限</p><ul><li><p>空指针：本身的所处内存并不是NULL，而是其指向的是NULL。nullptr就像宇宙中的无边黑暗</p></li><li><p>垃圾指针：没有进行初始化，故其指向某个随机地方的指针。也就是随机<strong>生成</strong>一个地址数字存储起来，这个内存中可能存储着<strong>你绝不可以碰触的数字</strong></p></li><li><p>-&gt; 所以我们<strong>声明一个新指针时</strong>，务必要<strong>为其赋予初值</strong></p></li></ul><pre><code class="cpp">int* p = nullptr;if(p)....         // false p是否不为nullptrif(!p)...         // true p是否为nullptr </code></pre><p><code>type* name = new type(parameters);</code></p><p><strong>运行中的程序</strong>是将所有的变量存储在一个 <strong>栈(stack)</strong> 中</p><p>当一个函数完成其任务，所有的局部变量的使命也就完成了。我们就会将这些变量占用的内存空间回收，用于存放新的数据。从技术来讲，当这些变量消失的时候，实际上就是<strong>栈被压缩了</strong></p><p>还有另外一块存储空间 - <strong>堆(heap)<strong>。<br>当你使用<code>new</code>语句来申请空间时，就会在heap里申请一块空间，并返回一个指针。<br>并且这块内存并不会随着某个函数的运行结束而被</strong>自动释放</strong>，只会被手动<strong>free up</strong></p><p>从整体来看，内存中存储变量是连续的，但两者在<strong>生命周期上是完全无关的</strong>。故我们将这两块区域视为<strong>相对独立</strong>的。<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240129/image.6361ak1emao0.webp" alt="image"></p><pre><code class="cpp">struct ListNode {   int data;   ListNode* next;}</code></pre><p>在C++中，你<strong>不能定义一个指向引用的指针</strong>，这是不被允许的。故你可以传递<em><em>指针的引用（</em>&amp;）</em><em>，但是不能传递**指向引用的指针(&amp;</em>)**</p><p>双重指针(**)会使代码显得极为臃肿，故不推荐使用</p><pre><code class="cpp">int size(ListNode* front) {   int cnt = 0;   ListNode* tmp = front;   while (tmp != nullptr){      tmp = tmp-&gt;next;      cnt++;   }   return cnt;}int get(ListNode* front, int index) {   ListNode* tmp = front;   for (int i = 0; i &lt; index; i++) {      tmp = tmp-&gt;next;   }   return tmp-&gt;data;}void add(ListNode*&amp; front, int value) {    // ⬆️⬆️必须是引用&amp;，否则就不会影响头节点   // create a new node   ListNode* newNode = new ListNode(value);   if (front == nullptr) {      front = newNode;   } else {      ListNode* tmp = front;      while (tmp-&gt;next != nullptr) {         tmp = tmp-&gt;next;      }      tmp -&gt; next = newNode;   }}void addFirst(ListNode*&amp; front, int value) {   front = new ListNode(value, front);}void removeFirst(ListNode*&amp; front) {   if (front != nullptr) {      ListNode* tmp = front;      front = front-&gt;next;      delete tmp;   }}void remove(ListNode*&amp; front, int index) {   if (front != nullptr) {      ListNode* tmp_1 = front;      for (int i = 0; i &lt; index - 1; i++) {         tmp_1 = tmp_1-&gt;next;      }      ListNode* trash = tmp_1-&gt;next;      tmp_1-&gt;next = trash-&gt;next;      delete trash;   }}</code></pre><h2 id="Classes-and-Objects"><a href="#Classes-and-Objects" class="headerlink" title="Classes and Objects"></a>Classes and Objects</h2><ul><li>Class: 一种数据对象的模板，定义了属于这种类型的内容，包括其存储的数据和行为</li><li>数据 -&gt; <strong>成员变量</strong>(存储在对象内部的变量)</li><li>对象内部的函数和行为 -&gt; <strong>成员函数/方法</strong> </li><li><strong>构造函数</strong> 可以在对象被创建、被初始化时设置对象的状态</li></ul><p>面向对象编程(OOP)的思想：你的<strong>大部分代码都与对象有关</strong>，这些对象执行任务，并与其他对象相互协作。</p><p>提供了抽象(abstraction)的概念: 我并不需要知道其内部的运行原理，我只需要知道<strong>如何去使用它</strong></p><ul><li>C++中的类被分成了两种代码文件: </li><li>.h: 头文件，负责<strong>声明</strong>(declarations)</li><li>.cpp: 源文件，负责<strong>定义</strong>(method bodies)写清楚具体的实现方式</li><li>例如你想写一个名为<code>Foo</code>的class，就要有<code>Foo.h &amp; Foo.cpp</code></li><li>好处在于：别人只需要看你的头文件即可知道你所定义的方法和参数，而不需要关心位于源文件的具体实现方式。</li></ul><hr><p>那么如何编写一个头文件呢？<br>⬇️这是一个基本的结构<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240130/image.6t4y9bwtydxc.webp" alt="image"></p><pre><code class="cpp">#ifndef _classname_h#define _classname_h// 预处理，防止重复声明定义class ClassName {public:                                   // in ClassName.h   ClassName(parameters);                 // constructor   returnType name(parameters);           // member functions   returnType name(parameters);           // (behavior inside   returnType name(parameters);           // each object)private:   type name;     // member variables   type name;     // (data inside each object)}; // IMPORTANT: must put a semicolon at end of class declaration(argh)#endif</code></pre><p>通过<code>const</code>用法，你可以使得一些东西不会被改变</p><pre><code class="cpp">const int x = 4;void foo(const BankAccount&amp; ba){   ···}class BankAccount {   ····   double getBalance() const;    // 意味着getBalance将不会改变BankAccount }</code></pre><hr><p>操作符重载(Operator overloading)</p><p>unary(一元) + - ++ – * &amp; ! ~ new delete<br>binary(二元) + - * / % += -= *= /= %= &amp; | &amp;&amp; || ^ == != &lt; &gt; &lt;= &gt;= = [ ] -&gt; ( ) </p><pre><code class="cpp">returnType operator op(parameters);    //.hreturnType operator op(parameters) {   //.cpp   statements;}</code></pre><p>在C++中有一个比较有趣的玩法，可以<strong>让某些函数/方法访问到private内的数据</strong>，就是在前面加上<code>friend</code>关键字</p><hr><p><strong>Destructor 析构函数</strong></p><p>如果你的对象中涉及到了指针或者在堆中创建的新对象，那在析构函数中释放他们就很有必要了-&gt;避免内存泄漏。</p><pre><code class="cpp">~ClassName();                    // ClassName.hClassName::~ClassName() {···}   // ClassName.cpp</code></pre><h2 id="Doubly-Linked-List-Skip-Lists"><a href="#Doubly-Linked-List-Skip-Lists" class="headerlink" title="Doubly Linked List &amp; Skip Lists"></a>Doubly Linked List &amp; Skip Lists</h2><ul><li><p>Doubly Linked List: 每个节点都有<code>prev</code>和<code>next</code>两个指针。同时我们要维护两个指针<code>front</code>和<code>back</code>，一头一尾，这样我们就可以双向遍历Lists。缺点就是会占用更多的内存，以及维护和修改起来更为困难</p></li><li><p>Skip List: 有序的List。每个节点包含存储<code>next</code>指针的<code>vector</code>/<code>array</code>。使得查找、增加或者删除元素的时间复杂度都可以达到O(logN)<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240130/image.457bredn5h34.webp" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240130/image.4esn1dyqplz4.webp" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240130/image.4rsxngc83ekg.webp" alt="image"></p></li></ul><hr><h1 id="Part-7"><a href="#Part-7" class="headerlink" title="Part 7"></a>Part 7</h1><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h3 id="两种声明方式"><a href="#两种声明方式" class="headerlink" title="两种声明方式"></a>两种声明方式</h3><ol><li><strong>type name[length]</strong>;</li></ol><ul><li>位于栈上，有固定大小，内存自动释放</li></ul><ol start="2"><li><strong>type* name</strong> = new <strong>type[length]</strong>;</li></ol><ul><li>位于堆上，指针(意味着你可以<strong>创造一个更大的数组</strong>然后让指针指向<strong>新的数组</strong>)，内存不会自动释放</li></ul><p>你可以根据你所需的<strong>生命周期</strong>来<strong>选择不同的声明方式</strong>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>由于C++是一个<strong>追求效率</strong>的语言，故在没有特殊要求的时候，它是不会遍历整个数组并设置成0的。</p><p>如果你想初始化，可以想下面这么写⬇️</p><pre><code class="cpp">type* name = new type[length](); // initialize to 0</code></pre><p>或者你也可以这么写⬇️</p><pre><code class="cpp">type name[length] {};            // initialize to 0</code></pre><p>第二种写法更类似于一种trick</p><h3 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h3><p>数组本身也是支持<code>for-each</code>循环的。</p><pre><code class="cpp">int a[4] {1, 2, 3, 4};for(int n: a) {   cout &lt;&lt; n &lt;&lt; endl;}/* output:   1   2   3   4*/</code></pre><h3 id="一点关于栈的题外话"><a href="#一点关于栈的题外话" class="headerlink" title="一点关于栈的题外话"></a>一点关于栈的题外话</h3><pre><code class="cpp">int x = 555;int y = 777;int a[3] {1, 2, 3};cout &lt;&lt; a[-1] &lt;&lt; endl;cout &lt;&lt; a[-2] &lt;&lt; endl;/* output:   777   555*/</code></pre><p>这是为什么呢？<br>因为在栈上x, y, a是连续的，<code>a[-1]/a[-2]</code>本身的意思就是 <strong>从a的起始位置向前移1/2个int的大小</strong></p><pre><code class="cpp">void foo() {   int x = 5;   int y = 7;}void goo() {   int a;   int b;   cout &lt;&lt; a &lt;&lt; endl;   cout &lt;&lt; b &lt;&lt; endl;}int main() {   foo();   goo();   return 0;}/* output:   5   7*/</code></pre><p>这是怎么一回事呢？ 调用完<code>foo()</code>后，<code>x&amp;y</code>就从栈上被<em>擦除</em>掉了，但是<strong>其存储的bits并没有改变</strong>，只是系统将那块内存区域标记为<strong>不再使用</strong>。随后的<code>goo()</code>中的<code>a&amp;b</code>就被放到了先前的这块内存上。由于两者未进行初始化，故<strong>继承</strong>了先前<code>x&amp;y</code>的值。</p><h3 id="Vector-Stack-是如何依赖-Arrays来工作的"><a href="#Vector-Stack-是如何依赖-Arrays来工作的" class="headerlink" title="Vector/Stack 是如何依赖 Arrays来工作的"></a>Vector/Stack 是如何依赖 Arrays来工作的</h3><p>你不能通过类似于<code>.size()</code>or<code>.length()</code>等方法来获取数组的大小。数组本身<strong>只是一块内存，其没有任何功能</strong></p><p>两者都是基于一种被我们称为<code>unfilled array</code>来实现的。也就是其<strong>实际大小</strong>比我们<strong>已经添加</strong>的大一些。</p><p>让我们用<code>Array</code>来实现一下<code>Stack</code></p><pre><code class="cpp">// ArrayStack.hclass ArrayStack {   public:      ArrayStack();     // constrution      ~ArrayStack();    // destrution      // member functions(method)      // TODO: push, pop(peek), isEmpty, operator &lt;&lt;      void push(int n);      int pop();      int peek() const;      bool isEmpty() const;      friend ostream&amp;  operator &lt;&lt;(ostream&amp; out, const ArrayStack&amp; stack);   private:      //member variables      int size;      // 用于记录已添加元素数量      int capacity;  // 用于记录总容量      int* elements; // 可变性，易于维护};ostream&amp;  operator &lt;&lt;(ostream&amp; out, const ArrayStack&amp; stack);</code></pre><pre><code class="cpp">// ArrayStack.cpp#include "ArrayStack.h"ArrayStack::ArrayStack(){   size = 0;   capacity = 10;   elements = new int[capacity]();}     ArrayStack::~ArrayStack(){   delete[] elements;   // 为了区分数组与单个值，需要在delete后面加上[]                        // 因为其本质是指针，后台清理指针时，指向一个元素和指向一系列元素的处理方式不同}// member functions(method) // TODO: push, pop(peek), isEmpty, operator &lt;&lt;void ArrayStack::push(int n){      if (size &lt; capacity) {         elements[size] = n;         size++;      }else {         capacity *= 2;         int* newelements = new int[capacity];         for (int i = 0; i &lt; size; i++) {            newelements[i] = elements[i];         }         newelements[size] = n;         size++;         delete[] elements;         elements = newelements;      }}int ArrayStack::pop(){      if(!isEmpty()) {      int a = elements[size - 1];      element[size - 1] = 0;     // optional      size--;      return a;   }else {      throw "oh sh*t";   }}int ArrayStack::peek() const{   if(!isEmpty()) {      return elements[size - 1];   }else {      throw "oh sh*t";   }}bool ArrayStack::isEmpty() const{   return size == 0;    // 若为真，返回true}friend ostream&amp;  operator &lt;&lt;(ostream&amp; out, const ArrayStack&amp; stack){   out &lt;&lt; "{";   if(!stack.isEmpty()) {      out &lt;&lt; stack.elements[0];      for (int i = 1; i &lt; stack.size; i++) {         out &lt;&lt; "," &lt;&lt; stack.elements[i];      }   }   out &lt;&lt; "}";   return out;}</code></pre><p>在第一次运行时出了问题，问题在于<code>const ArrayStack&amp; stack</code>这种调用方式，默认只能使用<code>ArrayStack</code>中的<code>const</code>函数。于是进行了一些修改。<strong>注意！在.cpp与.h文件中要进行同步的修改</strong></p><p>Q9: 我们对于<code>capacity</code>的大小修改应该遵循怎样的规则呢？<br>A9: 倍数增长(*2常用)。可以确保你越来越不受<strong>扩容</strong>的困扰。</p><h3 id="shallow-copy-bug-浅拷贝错误"><a href="#shallow-copy-bug-浅拷贝错误" class="headerlink" title="shallow copy bug(浅拷贝错误)"></a>shallow copy bug(浅拷贝错误)</h3><pre><code class="cpp">ArrayStack s1;s1.push(1);s1.push(2);s1.push(3);ArrayStack s2 = s1;</code></pre><p>这会造成什么问题呢？一般来说，我们使用<code>=</code>就是将后者的<strong>内存内容</strong>复制到前者去。这里<code>ArrayStack</code>中s<code>ize/capacity</code>都好说，但是<code>elements</code>是<code>int*</code>的形式(复制也只会复制<strong>一个地址</strong>而已)，<strong>两者会共享一个数组</strong>。最后会造成下图的后果⬇️</p><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240203/image.1k3exxguyw68.webp" alt="image"></p><p>如何解决这个问题呢-&gt;Deep Copy(深拷贝)</p><ol><li>可以写一个复制构造函数<code>ArrayStack(const ArrayStack&amp; stack)</code></li><li>可以写一个等号运算符<code>ArrayStack&amp; operator =(const ArrayStack&amp; stack);</code></li></ol><p><strong>Rule of Three</strong>:当你在C++的class中写如下三个的任意一个的时候，你最好把三个都写上</p><ol><li>copy constructor</li><li>assignment operator</li><li>destructor</li></ol><p>或者你也可以直接从源头上断绝这种问题-&gt;<strong>禁止拷贝</strong></p><pre><code class="cpp">// ArrayStack.hprivate:   ArrayStack(const ArrayStack&amp; stack);   ArrayStack&amp; operator =(const ArrayStack&amp; stack);// In ArrayStack.cpp, don't give them any actual definition/body.</code></pre><h2 id="Graphs-图"><a href="#Graphs-图" class="headerlink" title="Graphs(图)"></a>Graphs(图)</h2><ul><li>一种数据结构，包含如下内容：</li></ul><ol><li>一组顶点(vertexes)，有时也被称为节点(nodes)</li><li>一组边(edges)，顶点之间的连接</li></ol><h3 id="一些关于图的术语"><a href="#一些关于图的术语" class="headerlink" title="一些关于图的术语"></a>一些关于图的术语</h3><ol><li>reachable: Vertex a is <em>reachable</em> from b if a path exists from a to b.</li><li>complete: If every vertex has a direct edge from every other.</li><li>connected: If every vertex can be reachable from every other.</li><li>cycle: A path which starts and ends at the same node.(一般而言，每个edge在一个path中只允许被使用一次)</li><li>loop: A edge directly from a node to itself.(许多图不允许)</li></ol><h3 id="Weighted-Graph-加权图"><a href="#Weighted-Graph-加权图" class="headerlink" title="Weighted Graph(加权图)"></a>Weighted Graph(加权图)</h3><ul><li>给每个边赋予一定的值(权重)</li><li>一般我们认为<strong>权重是非负的</strong></li><li>非加权图可视为：每个边都有相同的权重(0/1/…..)<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240203/image.15aj04p76uyo.webp" alt="image"></li></ul><h3 id="Directed-Graph-digraph-单向图"><a href="#Directed-Graph-digraph-单向图" class="headerlink" title="Directed Graph/digraph(单向图)"></a>Directed Graph/digraph(单向图)</h3><ul><li>每个edge是有方向的(带箭头)</li><li>你也可以混合加权/非加权</li></ul><h3 id="binary-tree-二叉树-Linked-List-链表"><a href="#binary-tree-二叉树-Linked-List-链表" class="headerlink" title="binary tree(二叉树)/Linked List(链表)"></a>binary tree(二叉树)/Linked List(链表)</h3><ul><li>二叉树是一个<strong>有向且无环</strong>的图</li><li>每个节点的最大入度(in-degree, 多少条边指向该节点)为1，最大出度(out-degree, 该节点指向多少个节点)为2。</li><li>链表也是类似的，入度和出度均为1</li></ul><h3 id="Stanford-BasicGraph"><a href="#Stanford-BasicGraph" class="headerlink" title="Stanford BasicGraph"></a>Stanford BasicGraph</h3><p><code>#include "basicgraph.h"</code></p><ul><li>通过这个库构建的图，是<strong>有向加权</strong>的</li><li>nodes默认是strings<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240203/image.72t0sdwwcwhs.webp" alt="image"></li></ul><table><thead><tr><th>包含的函数</th><th>描述</th></tr></thead><tbody><tr><td><code>g.addEdge(v1, v2);</code></td><td>在两个顶点之间添加一条边</td></tr><tr><td><code>g.addVertex(name);</code></td><td>向图中添加一个顶点</td></tr><tr><td><code>g.clear();</code></td><td>清除图中的所有顶点/边</td></tr><tr><td><code>g.getEdgeSet();</code></td><td>返回所有边的集合</td></tr><tr><td><code>g.getEdgeSet(v);</code></td><td>返回从顶点v出发的所有边的集合</td></tr><tr><td><code>g.getNeighbors(v);</code></td><td>返回顶点v的所有邻居顶点的集合</td></tr><tr><td><code>g.getVertex(name);</code></td><td>返回具有给定名称的顶点</td></tr><tr><td><code>g.getVertexSet();</code></td><td>返回图中所有顶点的集合</td></tr><tr><td><code>g.isNeighbor(v1, v2);</code></td><td>如果顶点v1和v2相邻则返回真（即v1到v2有一条边）</td></tr><tr><td><code>g.isEmpty();</code></td><td>如果图为空（没有顶点或边）则返回真</td></tr><tr><td><code>g.removeEdge(v1, v2);</code></td><td>删除顶点v1和v2之间的边</td></tr><tr><td><code>g.removeVertex(name);</code></td><td>删除具有给定名称的顶点</td></tr><tr><td><code>g.size();</code></td><td>返回图中顶点的数量</td></tr><tr><td><code>g.toString();</code></td><td>返回图的字符串表示，例如 “{a, b, c, a -&gt; b}”</td></tr></tbody></table><h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS/BFS"></a>DFS/BFS</h2><h3 id="Depth-first-search-DFS深度优先搜索"><a href="#Depth-first-search-DFS深度优先搜索" class="headerlink" title="Depth-first search(DFS深度优先搜索)"></a>Depth-first search(DFS深度优先搜索)</h3><ul><li>搜索一点到另一点的路径</li><li>尽可能的探索<strong>每一条可能的路径</strong></li><li>没有<strong>选择性</strong>，只是找到，并非最佳/最优路径</li><li>基于<a href="#backtracking">backtracking</a></li></ul><h4 id="DFS伪代码"><a href="#DFS伪代码" class="headerlink" title="DFS伪代码"></a>DFS伪代码</h4><pre><code class="cpp">dfs from v1 to v2:   mark v1 as visited, and add it to the path;   perform dfs from each of v1's unvisited neighbors n to v2:      if dfs(n,v2) succeeds: a path is found!   if all neighbors fail: remove v1 from the path;</code></pre><h3 id="Breadth-first-search-BFS广度优先搜索"><a href="#Breadth-first-search-BFS广度优先搜索" class="headerlink" title="Breadth-first search(BFS广度优先搜索)"></a>Breadth-first search(BFS广度优先搜索)</h3><ul><li>先直接探索<strong>所有你可以直接到达的临近点</strong></li><li>如果没有到达目的地，那就重复上面的步骤，循环往复，直到到达目的地。</li><li><strong>永远返回最短/最优的路径</strong></li><li>会<strong>消耗更多的时间与空间</strong></li></ul><h4 id="BFS伪代码"><a href="#BFS伪代码" class="headerlink" title="BFS伪代码"></a>BFS伪代码</h4><pre><code class="cpp">bfs from v1 to v2:   create a queue of vertexes to visit, initially storing just v1.    mark v1 as visited.   while queue is not empty and v2 is not seen:       dequeue a vertex v from it,      mark that vertex v as visited,      and add each unvisited neighbor n of v to the queue.</code></pre><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>基本上与**顶点数(V)和边数(E)**呈线性相关</li><li><strong>O(V + E)</strong></li></ul><h3 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h3><ul><li>找到<strong>总权重最小(成本最低)的路径</strong></li><li>与<a href="#breadth-first-searchbfs%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS</a>类似，但是其采用了<code>优先级队列(priority queue)</code></li><li>无法处理<strong>负权重</strong>，会打破算法的正常运行。但是权重为0不会有影响。</li><li>在更新<code>pqueue</code>时，只有新cost<strong>低于</strong>当前cost时，才会更新。若相等，则不会更新。</li></ul><h3 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm"></a>A* Algorithm</h3><ul><li>Dijkstra算法的改进版，基于<a href="#heuristic%E5%90%AF%E5%8F%91%E5%BC%8F">启发式</a>函数</li><li>所需做的改动就是<strong>加入一个启发式估计信息</strong>-&gt;该节点的成本+我估计该节点好坏程度的总和</li><li>从a到c，途径节点b -&gt; priority(b) = cost(a, b) + <strong>Heuristic(b, c)</strong></li><li>我们按照处理后的优先程度，进行探索</li></ul><h4 id="Heuristic-启发式"><a href="#Heuristic-启发式" class="headerlink" title="Heuristic(启发式)"></a>Heuristic(启发式)</h4><ul><li>一种<strong>有预测的，基于目前已有信息的猜测</strong></li><li>指导解决<strong>接下来的问题</strong></li><li>在图的问题中，如果我们能<strong>预估中间点到达目的地时的好坏程度</strong>-&gt;启发式方法</li><li>制定一个<strong>可接受的</strong>启发是非常重要的：因为有时候这个预测可能<strong>过于乐观</strong>，导致实际结果与预测偏差过大</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>20231231_信</title>
      <link href="/2023/12/31/20231231-%E4%BF%A1/"/>
      <url>/2023/12/31/20231231-%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7eb7b5782f85d600b5cc129e0b73046edfa0f06f9d5abde0e6f6d64714073fc7">98c6ec152bf6953f1fca972fa992a23e63d9c9469c76045fa7081e36a3d877c5e86782397c141d0cf180fb9c84b5b09176ea0085f23cda2a9f8545c17ed8ff0d31a19cdd561f61554de358feb09f62532dd0ea3658d3eddf60e9b9bf381d7d8f79114e733b956bf0055707a37542a4122738ee76b3985c49f5dafb9cb3b9072a454d2905cfca2923e3ad3eba1fc80b5d516e0c39e69a970c9a9e437ae7f24899e2857be53fd9fab8cdd303d7f4d0a1e4eebb195d9f3f80a514cbfb34a766618377fe18a568406d55fb83b4f784245b82180dfda4db25f6f8ba2ae3cb0030a4c2896b873e5d0e95adb2dfad42e4b83f41694ad8e9d418531b3c15e0d2db3b61df1369ffe22ac1fe336bfb318ccad2a63fc0bbebe3b7c458d18743fa8fad1fc61e2b2f46c4d1069ce16d8554b2742011b7d7bb4ad98634f725415bd48e80e54ca63201a1576d8d72da487b2d394aeeb909ad6528a14418dd9f91899e7082d1ab1a33a16fb1991876eb1ecffbcb6450543910a3d8b2b867b463712ebba1325cbe1c9db1c123c8d617ae5fa363617c2b7acdc1a336267d6518d9c0a0a0a0ddfee7dd2090c2e9145a22da71cbfb739624f8add814a2f77e5c7a14ecbe79c30a73e89983fc1cf2890de5be0f0680502dcdc9660b4c0828668b87bfbac9c52c61ebb460f0c0e48a97a86283f7cdb9baa2aa127643e66cfd06accf82ebeeb30c9045626e7cb91279fedf9fe5e38330d5ee55e0e3fce8916beaa8ff15cbe94e1deedd6af2ecefa1d31f5a5fedd70dc8048f0749a0d7789fbada6936925cfdb3612aa2691f2b267445b0797f5aede5156e78c3496533bf65377dd790b7cab244bab0987c2ae52ccd8a9d1769a665edfc62600b364504807e1cda5095c0c7063805f38c534f3af3cd4e2f5b7f026afce04cc03c3cbac9b7d355194e95228a79f2a2023ca7dc43f787a7d5d065f941d1be719a78af7ca9e8e2292f25b7983ccdafae30f4d257cc93bcb3a4bb8483c099d8f4aa38e97c5b0240d23a6314a271a4331392add2d12c8373574c560847c835d8c7a85e1c53ee76673dfde6c95063490a08a248e4d779fa99f300490fab9267aff818a1d161e910408e0f373118f1ef60c602b762ef9eb227f18e04d595bbd674a05530ffd76996e850e7d6c8f3461c4371fbda2a2cac0537c92690cb4f25bee65ca71314b777816063c79ddf79858ace5c72e2702389fa2af97c4341cca7f7278b96f3f9cf1db0f9e11b30d9f20c4c2c7face0cf571a2f9b27d38a513a4ae94978b371d9a2b4cd59643ba7b969657a69f053bd9d54960a9e792f668f89fde33ca66334570c0c9c4c0c0e8610a80072c2df761f76f339851d7b66737531063bdb6f62c608b44311fa119356d27226be3f2c536832fb1ac57205e008380dff56f7e88e5d9321ca6e6c31df14bdd6b3ebfa05732293a77a61b21268dc4650780af415b1641c3961c6c9c0c4acfb61c30410732f88a4481dd70d2594c329d723066cf38c215511f25dec19a317708b4ab6698a370b857096fd7b3367cd49026c43b13b464524a825a840cf17911e39a5bea7246bb7559b01fc92f53cbe8c9990dea76b85b6f47077eaffa5e9708e3be4a9f78101a3b055e46012c525b7bdef02a0bc442dcbb752080df98db2ad1bd88745594ffb125b4d19ee0c8de928f77eb05f48e7064194857e44eac0c9ef1cf5eb3b0254bc7f42f857921d6ad3497be3c5b57f08565e40b023720cd1886898669f43caf1233e39eb673290ab6943ef27d593be6f49d8e5d19f83044970f68bfa736574f4dd99e136da0a61f841760fa2b324cb699a7b023f0d360d70222896451585565a4747557495af44c4e822a035b8090a0c4236054c3131e33ad009fc50743c0e3f0d5082c063d604d5949716434e975ded50f9cf3486920320cae2c0dcab35ff38bb9d1d0febe18fd998efc8ed76d9825aefa17552aec45b1868d7180400ea2e89e5c4965426b55a172d21423567cdbe29a0b4cb0b800a9b41bc8cb5757a7793d4002fac7b916a5e43b14a1644ae866efe7bd9c414175da6c5ce7dcc9042c2161f0decdc77d103a56df139c21cb2b17fdc783dd8cd0a55eac80cecc9f7898ec6e30ed0ddae2a2dc6478f5f2e8ca6d816fa7c9f2484bec6befb6f337149f54c5442f49c2f57ce8c804f401af9431fa6e65d6e53aeade068cd4e86d5308de791a488398411db502fb96a7ca26bef8cc3c6af82d54cc69143e3f7d244e1d85d51b877fae681f3f436a3532a03f5e01274fbd58a4467ed805af75cf8c9bcce40093029d5673ff1e3649a7681196c259bf2d50aab10a75731fea9d0c99814d3b854f60bd2ccb558ff76ad87ec1b1e0ce4d85663d1c1377cc5e4730d4910f6351700e988ec9ae6634664b56ef42df4432da8f9727eed34af12b365c7319406ce51cba9b92d01775e859bc58674b3451190dff1fca32a0acb053d58e6403fdf78126802d20c04242b75f3e5288dec352d67dd647b9267cc94b3058fc06530b88d57d19a4b8e89c516d0ea7b2f0cfea5fa02bd8ef784dfbdee4f2faed9370746258cae7adbacefe4b9d499500259f352b2081995c7bcc51680ff94a21e02c238102d7f1b016d4a60ef927bdf89557cbadbecb881c283792d48bfd4edad4eeacb9aecbb45ef92442d114e4646f51c89303812cea17ad8a1085f26e5124008e5bec2de003c5079e24eefdc4f36d8212ad955e10bcfc811a68dc26e81e0ce9b01880d5ad028a3d4d5f5cacfb86721b189126d3dfe70a1d47d144694492826e75d337746a4b73c3a3ac24189ed10b05db63920c60e29aba72be332330940b29d3f2f0873a232266df6e0185968afe59f4b8989ef34b17c434890931fe58ca87e564c7b97f3ae5565cbbbdc57d2a614cd3b5ce288127ac99890f48a5394e3eaa84caff010f268e179811e2e325503aac610f55a0ab83fd809d6bc51d7ad9b7d2506dd2f27ea918945ceff5188935e1bc88db9162b00af2f95f23dd757a6f0381efe63007962943a4f44b31a876d0c2d33a318286049b40db8e1ffcbe7cfb1fcca1e57d7dbdb3f61c79f29be8529f1437a0bd5bedfa2b2a964eb603f92753b48c075116c78d7e35fefc8941424173ecbff19d1e17727bd87f25be332ee15867431cac25566f58855f2d41b3184b8a712572c7de8bc4339eabc7f6daea5561b7a95debb7e8e3629755ad689d48a6489b278ccf31eec59051473e15026b2698cd78cf0042e50f119c512d427ad69c5ddf38631ce917fb9196cc1e6592bae2229f8bae95930cb292ebbb7743b03b5fd065296a14eb7bc948f3f7acb6bc3947c3797320a079d75c0447f9fdf04a962b7ddef14bb68b93ee146b01b85c88a1b4354600fc5ed62d7ef8480ba8acb37138392f838907b8fa0e4b42a1093be8ad967db77a7824ce0b80b6ed49dafc943089c1bf79add6080f2842b0d204ec48da97aed85406b1b052f270f2be843eb84cfb01e13c6c77c63e36b93d433da6f9647748cc5c480cbc7aced67939630d3d3310e8f5e4772449e09af3a9cf90abfa183807268d6a90eb282d8ab8385b7b8c0bdf7db636531f2682a1d338d6790c2a80fa8b222fa961eecf2cf17bb013ff23d32a4caa2fbf436d5d209f114770f7ab06db078e81a2caf52619b0eda2168f882b58e88c919b2f452c482f2e9646b28356166e08c33693a226b3ded48e9124fc0bb7072cac1d21e9c2e6d054c8f8306ef7a4b2881a0b2b38b9aa485ebc5569a84cf1806019c3663ee7eeae45f7392e41e42b616995fb499ba399f6fcda2f2da929c8f377d96f3215377cd7eb889b1e508c79188e2d1e249e7dba10b2b46116a1a6f771bb30fda8afc6e21faa982bec6a63ace23440c2320faa5bbb7c04b3fcea7d6d7e118d547e49830e3bfcce4e622f96fd8ec291e61547cb0637f6b98481a12d8574f70129e4c9e8a6fe74a203fdba6811ca675737066d4a4d8a973ad4b93117b9d503df0a356345ea59fa1ad145018ac52f838a0e40667fd0421a3227270b82edba67507decf3905fc7608b5d3d276f7fe3d823c0c317d90a1ea0999d0b9e794e6bcefbe62508ffee289abb5e6066e996eb8ea46d523fd0e51d09c666ddaa9f49a07adb0dbff8a93f520a692b2b083ee1b1bd7229908a6b1fc4bd6590cde45aa72b1cc30cb24f0f44306a4f8ef63f9b45775ac14394165df0805fb209b66a960df38ca5905e89e188e0615c21c38d2e4fc6fa3ee69ea240a0d2c8a4665bbe1c4f15b7278ea7020775f05a8b9a8b22697a325a92634d85bb34671179ff54875c8d7859d56389ea5bfd80fc0dbe5269347a96b94eb9c9c4eb4225944accb36c834931ef5309fc0ef6862d96fb1d92d5e954a95d4b3f273b067b233f04e940409209fc7b402f721af9caa4b672d428745970b34692c288e7f077f28e75659b54e47cbc8f92e49949276313533676c46f36e6a1f6136a234c798d09674c3790d2880070fdf3063e1e659770840990ec4359d34f7af8ce3190d97c85b2b9278e42ec2f52a66879a588282f4c2458e290c84b60df7ba8ff7acd6902ebdea8c11ee5567bfbfb1cfdc4c0f20f36e42e7f6d86ac3c2aca02ff94221b617ce439af5dd13a54e846257e5d045306ee9dc287eb885209511d3562e45569deeed718f7da44a2da7e826c412c38951af98510213985be0a553f4be8d55b9b704d6aaddd5fa74378d9cba11138f3fd4939ca1c727d01c591a6d7f62e6b97be59ad8357a5568662ae1e638af6c56e3569acbafe8b7f7fdb2250ef442e7d54a63f2740086d74cec826dbb0703244fbda67125511311c1eb07ba89dac303f4d891f6400fefe79b505cc439b1a80a047d74ac110caa18f549314c165217806cf18274e6e49fa2117f67f5ec90d40bf31ed12c89fdef1fa7486f5a2e414d3f42072cdbf7cf358b96810bb6c73bb17e362921a72ae0f819142e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输个密码吧</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231229_期末，寒假，以及下学期</title>
      <link href="/2023/12/29/20231229-%E6%9C%9F%E6%9C%AB%EF%BC%8C%E5%AF%92%E5%81%87%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8B%E5%AD%A6%E6%9C%9F/"/>
      <url>/2023/12/29/20231229-%E6%9C%9F%E6%9C%AB%EF%BC%8C%E5%AF%92%E5%81%87%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8B%E5%AD%A6%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=394648&amp;auto=0&amp;height=66"></iframe><p>上次写这种类型的博客还是10月24日，那是期中考试之后，成绩刚出来。当时看到成绩单，下定决心，痛定思痛，捋顺了一下思路，把各科的问题以及对应的解决思路记录了下来，并列了下TO-DO List。</p><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/Blog_Pic@master/20231229/%E6%88%AA%E5%B1%8F2023-12-29-23.29.26.4by500q3g5z4.webp" alt="TODOLIST"></p><p>目前看来，完成率还可以。下半学期基本可以说是拉足马力了，呆在正心的时间已经比呆在宿舍的时间要长了。期末的四门考试课：淑芬、近代史、程序设计、线代。只剩下<code>线代(1月4日)</code>一科了，应该问题不大，该练习的都练习到了，最近几天再把一些基本的知识点和方法看一看，把往年题的错题和一百题看一看。</p><p>这学期的学分绩还没有完全出来，只出来了<code>淑芬</code>一科——89(194/624)。其实是很不尽如人意的，但是没办法，期中扣分太多，期末无力回天😂感觉最后的学分绩排名能在150+就很不错了，等到最终的绩点出来再来Update一下吧。</p><hr><p>其实这篇文章的主要内容是即将到来的寒假的计划。目前我想了这么几件事，也算是接下来的TO-DO List吧</p><ul><li><input disabled="" type="checkbox"> 淑芬下先修</li><li><input disabled="" type="checkbox"> 大雾自学(由于大雾只有大二上，后半Part才有先修)</li><li><input disabled="" type="checkbox"> CS106X(计算机冲冲冲！)</li><li><input disabled="" type="checkbox"> 概率论与数理统计</li></ul><p>怎么说呢，感觉回到了中学那会儿的<strong>抢先抓早</strong>的打法。这四个TO-DO的Deadline还未定，不想齐头并进，还是突击来的比较爽快和高效一些。但是像<code>CS106X</code>这种课又没办法突击，让我再想想吧。</p><p>寒假还需要把体重和身体调理一下，这12月的后20天真的有些难顶，无奈了。</p><p>先写到这里吧，未完待续。</p><p>Mostly_Harmless</p><p>写于2023.12.30 凌晨0时20分 A02.2108的一张床上</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计划, 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231128_CS50_Data Stucture</title>
      <link href="/2023/11/28/20231128-CS50_Data%20Stucture/"/>
      <url>/2023/11/28/20231128-CS50_Data%20Stucture/</url>
      
        <content type="html"><![CDATA[<p>这应该是<code>CS50</code>笔记的最后一弹了，其C语言部分的最后一个lecture也是有关于<code>Data structure</code>的，今天写这些就当作复习了。</p><hr><h2 id="链表-LIST"><a href="#链表-LIST" class="headerlink" title="链表 LIST"></a>链表 LIST</h2><pre><code class="c">typedef struct node{    int number;    struct node *next;} node;</code></pre><p>This is the basic stucture of LIST. Every node has a part which contains data, and a pointer which stores the address of the next node. So that these node can be linked together one by one, forming a chain.</p><p>Let’s discuss  th below code from Malan.</p><pre><code class="c">int main(int argc, char *argv[]) // 加入命令行参数{    node *list = NULL; // 定义了一个空链表，即元素数量为0的链表    for (int i = 1; i &lt; argc; i++) // argv的第一个值是 程序的名称    {        int number = atoi(argv[i]); // atoi 将ASCII码转换为整数，只要你输入的是数字        node *n = malloc(sizeof(node));        if (n == NULL)        {            return 1;        }        n-&gt;number = number;        n-&gt;next = NULL;        n-&gt;next = list;        list = n;    }    // node *ptr = list;    // while (ptr != NULL)    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next) // 和上面的两行是等价的    {        printf("%i\n", ptr-&gt;number);    }    // 开始释放    node *ptr = list; // 回到开头    while (ptr != NULL)    {        node *next = ptr-&gt;next;        free(ptr);        ptr = next;    }    return 0;}</code></pre><p>This small program can create a LIST with numbers based on the input of the commandline arguments, and print them from front to back. After performing these operations, the memory can be freed all.</p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/WechatIMG406.5xrdesyyi2gw.webp" alt="WechatIMG406"></p><p>This photo shows that <code>HOW TO INSERT A NODE INTO A LIST</code>.</p><hr><p>Generally, if we want to read a LIST, we need a temporary pointer(like <code>ptr</code>)to traverse the entire chain, until it reaches the node we need.</p><pre><code class="c">// node *ptr = list;// while (ptr != NULL)    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next) // 和上面的两行是等价的    {        printf("%i\n", ptr-&gt;number);    }</code></pre><p><code>node *ptr = list</code> is to create a temporary pointer<code>ptr</code>.<br><code>ptr != NULL</code> serves as a limitation, preventing access to prohibited memory or handling cases where the memory allocated for ptr was not available during its creation.<br><code>ptr = ptr-&gt;next</code> enables us to obtain the next node in the sequence after the current one.</p><hr><p>A very important thing is the freeing of the linked list. This process relies on the temp pointer, but it also involves another pointer, <code>next</code>. Nodes are deleted from the front to the back one by one.</p><pre><code class="c">    node *ptr = list; // 回到开头    while (ptr != NULL)    {        node *next = ptr-&gt;next; // 先get下一个node        free(ptr);        ptr = next;    }</code></pre><hr><p><strong>Pros:</strong></p><ol><li>Dynamic Memory Allocation: We don’t need a complete memory space; instead, the structure allows us to adjust the amount of data by creating or deleting nodes. Knowing the total number of data elements in advance is unnecessary, and there is no pre-allocation of space.</li><li>Efficient Insertion and Deletion: Due to the pointer relationships between nodes, inserting and deleting nodes in a linked list is more efficient than in arrays. The adjustment mostly relies on changing the pointer.</li><li>Minor Impact: When you change a node, the only nodes on either side of it will be impacted.</li></ol><p><strong>Cons:</strong></p><ol><li>Memory Overhead/Extra Storage for Pointers: Each node in a linked list contains both data and a pointer to the next node. This additional overhead consumes more memory compared to arrays, where only the data needs to be stored.</li><li>Sequential Access: Unlike arrays, linked lists don’t provide constant-time access to individual elements. To access an element, you must start from the head (or another known node) and traverse the whole list sequentially. This makes random access time, especially for a large list.</li></ol><p><code>Doubly-Linked Lists</code> has a more pointer to contain the address of the previous node.</p><h2 id="Trees-🌲"><a href="#Trees-🌲" class="headerlink" title="Trees 🌲"></a>Trees 🌲</h2><p>The stucture of a tree contains many nodes, and every node has three parts<code>*left</code> <code>*right</code> <code>data</code>.</p><p><strong>Similarities:</strong></p><ol><li>Nodes.</li><li>Pointers.</li></ol><p><strong>Differences:</strong></p><ol><li>Hierarchical Structure: A tree is <strong>a hierarchical data structure</strong>, comprising a root node, internal nodes, and leaf nodes. The connections between nodes form a tree-like structure. In contrast, a linked list is <strong>a linear structure</strong>, where nodes have only predecessors and successors, creating a linear sequence.</li><li>Node Relationships: In a linked list, each node usually has <strong>a single successor</strong>. In a tree, nodes can have <strong>multiple child nodes</strong>, establishing parent-child relationships. A node’s parent is the node directly above it, and its children are the nodes directly below.</li><li>Traversal Patterns: Linked lists are typically traversed <strong>linearly</strong>, from the head to the tail or vice versa. Trees can be traversed <strong>in various ways</strong>, such as pre-order, in-order, and post-order traversals.</li></ol><p><strong>Binary search trees are another data structure that can be used to store data more efficiently such that it can be searched and retrieved.</strong></p><p><strong>If the BST has a balance, the time complexity is O(log n) for all cases.</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/trees1.19cxz5qrey1s.webp" alt="trees1"></p><pre><code class="c">bool search(node *tree, int number){    if (tree == NULL)    {        return false;    }    else if (number &lt; tree-&gt;number)    {        return search(tree-&gt;left, number);    }    else if (number &gt; tree-&gt;number)    {        return search(tree-&gt;right, number);    }    else if (number == tree-&gt;number)    {        return true;    }}</code></pre><h2 id="Hashing-and-Hash-Tables-哈希化-和-哈希表"><a href="#Hashing-and-Hash-Tables-哈希化-和-哈希表" class="headerlink" title="Hashing and Hash Tables 哈希化 和 哈希表"></a>Hashing and Hash Tables 哈希化 和 哈希表</h2><p><strong>Hashing</strong> is the idea of taking a value and being able to output a value that becoms a shortcut to it later.<br><strong>A hash table</strong> is a fantastic combination of both arrays and linked lists. When implemented in code, a hash table is an array of pointers to nodes.<br><strong>A hash function</strong> is an algorithm that reduces a larger value to something small and predictable. Generally, this function takes in an item you wish to add to your hash table, and returns an integer representing the array index in which the item should be placed.</p><p>For example, hasing <em>apple</em> may hash as a value of <code>1</code>, and <em>berry</em> may be hashed as <code>2</code>. Therefore, finding <em>apple</em> is as easy as aksing the hashed algorithm where <em>apple</em> is stored.<br>However, if we have a lot of words to store, relying solely on the first character to hash them is inefficient and not ideal. In such cases, it becomes necessary to create a larger hash table.<br><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/hash1.1tgun3ha4d5s.webp" alt="hash1"><br><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/hash2.122mvup0op7k.webp" alt="hash2"></p><p><em>You, as the programmer, have to make a decision about the advantages of <strong>using more memory to have a large hash table and potentially reducing search time</strong> or <strong>using less memory and potentially increasing search time.</strong></em></p><hr><h2 id="Tries-🌲"><a href="#Tries-🌲" class="headerlink" title="Tries 🌲"></a>Tries 🌲</h2><p><strong>Tries are always searchable in constant time.</strong></p><p><strong>One downside to Tries is that they tend to take up a large amount of memory. Notice that we need 26 X 5 = 120 <code>nodes</code> just to store <em>Hagrid!</em></strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/tries1.2ksls3umjg8w.webp" alt="tries1"></p><p><strong>Harry would then be stored as follows:</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/tries2.20f1qgbvjdpc.webp" alt="tries2"></p><hr><p>Goodbye, CS50! Have a nice day!</p><p>Mostly_Harmless</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CARE7_CHATGPT</title>
      <link href="/2023/11/20/CARE7-CHATGPT/"/>
      <url>/2023/11/20/CARE7-CHATGPT/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4fb1e53c97b21a3e2f7b91548971548c69ba3417cf61325e198b4f05af62f89e">bd25ed9264b080267271e137e33d0ce1c2bbccdc98003fe4014325307c3e2d14e94855f283ecb759d00b11f8989a7a4b460fc15b698abf9ae08d149c5be8e74235a5be3fc0bdd6b56f01e8b84ad1dad525e5e4b90cf30443d32afb22981a492a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输个密码吧</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> CARE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231119_排序算法 Sort</title>
      <link href="/2023/11/19/20231119-Sort/"/>
      <url>/2023/11/19/20231119-Sort/</url>
      
        <content type="html"><![CDATA[<p>写点排序算法的笔记：</p><h2 id="插入排序-InsertionSort-O-n-2"><a href="#插入排序-InsertionSort-O-n-2" class="headerlink" title="插入排序 InsertionSort O(n^2)"></a>插入排序 InsertionSort O(n^2)</h2><pre><code>void insertSort(int arr[], int begin, int end){    // int length = end - begin + 1;    for (int i = begin + 1; i &lt; end + 1; i++)    {        for (int j = i; j &gt; begin; j--)        {            if (arr[j] &lt; arr[j - 1])            {                swap(&amp;arr[j], &amp;arr[j - 1]);            }else            {                break;            }        }    }}</code></pre><p>插入排序的本质就是排个头，先把第一个固定住，然后看第二个，第二个要是比第一个矮，就swap一下。</p><p>然后看第三个，第三个有没有第二个矮，要是矮，swap，此时第三个变成了第二个，再判断一下它和第一个的关系…………</p><p>循环往复，最后就排序完毕了。</p><hr><h2 id="快速排序-QuickSort-O-nlogn"><a href="#快速排序-QuickSort-O-nlogn" class="headerlink" title="快速排序 QuickSort O(nlogn)"></a>快速排序 QuickSort O(nlogn)</h2><pre><code>void QuickSort(int array[], int low , int high){       if(low&lt;high){    int index = array[low];    int i = low;    int j = high;    while (i&lt;j)    {        while (i&lt;j &amp;&amp; array[j] &gt;= index)        {            j--;        }        if (i&lt;j)        {            swap(&amp;array[i], &amp;array[j]);            i++;        }        while (i&lt;j &amp;&amp; array[i]&lt;index)        {            i++;        }        if(i&lt;j)        {            swap(&amp;array[i], &amp;array[j]);            j--;        }     }    array[i] = index;    QuickSort(array,low,i-1);    QuickSort(array,i+1,high);    }}</code></pre><p>快速排序是我接触的第一个排序算法，也是第一个利用到了分治和递归思想的算法。</p><p>说大白话就是<strong>分堆</strong>，我们先选一个“标准/标杆”(index), 这里我直接选的是第一项，然后我们把所有小于index的元素，都swap到index左边，大于index的元素都swap到右边。这样我们就获得了两堆数。之后对着这两堆数进行递归操作，反复的分堆分堆，分到什么时候呢？分到每个堆只有一个数字了，这也就意味着我们分完了。</p><p>在分堆的过程也是有讲究的，我们从数组的两端向中间移动。</p><pre><code>while (i&lt;j &amp;&amp; array[j] &gt;= index){    j--;}if (i&lt;j) // 这个判断就是防止因为i &gt;= j导致while终止，误操作swap，下面的if也是同理{    swap(&amp;array[i], &amp;array[j]);    i++; // 注意这个i++；}</code></pre><p>上面这段就是从最右端往左走，大的我们就留下，一旦发现小的，我们就直接swap到左边，同时从左边swap一个数字过来。可能你想问，如果我们swap过来的那个数字也小于index，应该放在左边怎么办呢？不急，我们接着往下看。</p><pre><code>while (i&lt;j &amp;&amp; array[i]&lt;index){    i++;}if(i&lt;j){    swap(&amp;array[i], &amp;array[j]);    j--;} </code></pre><p>这段开始我们从左端往右走，和上面的同理，小的我们留下，一旦发现大的，我们直接swap到右边，同时从右边swap一个数字过来。这个疑问又出现了，我们如果swap了一个大于index数字过来怎么办？</p><p>还好，循环会解决这些疑问。</p><p>当你进入下一轮最外层的while循环时，我们首先就会判断上一轮swap过来的**array [ j ]**满不满足我们的需求，如果不满足，果断扔回去。第二个也是同理。</p><p>就这样，不断的把数字扔来扔去，我们就得到了一个排好序的数组。</p><hr><h2 id="并归排序-mergeSort-O-nlogn"><a href="#并归排序-mergeSort-O-nlogn" class="headerlink" title="并归排序 mergeSort O(nlogn)"></a>并归排序 mergeSort O(nlogn)</h2><pre><code>void merge(int arr[], int left, int mid, int right){    int i, j, k;    int l = mid - left + 1;    int r = right - mid;    // 创建两个临时数组 L/R    int *L = (int *)malloc(l * sizeof(int));    int *R = (int *)malloc(r * sizeof(int));    // 把数字放进去    for (i = 0; i &lt; l; i++)    {        L[i] = arr[left + i];    }    for (j = 0; j &lt; r; j++)    {        R[j] = arr[mid + 1 + j];    }    // 开始分吧    i = 0;    j = 0;    k = left; // 众神归位    while (i &lt; l &amp;&amp; j &lt; r)    {        if (L[i] &lt;= R[j])        {            arr[k] = L[i];            i++;        }        else        {            arr[k] = R[j];            j++;        }        k++;    }    // 把剩下的元素处理干净    while (i &lt; l)    {        arr[k] = L[i];        i++;        k++;    }    while (j &lt; r)    {        arr[k] = R[j];        j++;        k++;    }    // free一下，养成好习惯    free(L);    free(R);}void mergeSort(int arr[], int left, int right){    if (left &lt; right) // 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊，不要忘了比较这个啊啊啊啊啊啊啊啊啊啊啊啊啊啊    {        int mid = left + (right - left) / 2;        mergeSort(arr, left, mid);        mergeSort(arr, mid + 1, right);        merge(arr, left, mid, right);    }}</code></pre><p>并归排序的实质，在我理解看来就是局部的有序，然后进行整合。我们通过递归，获得了大量的size为2(或1)的有序的子数组，然后我们选两个，因为在他们内部已经有序了，所以我们比第一个数字的大小，谁大谁放第一个…………就这样，两个有序数组合并成了一个大的有序数组，最终实现了排序。</p><hr><p>先写到这里，未完待续</p><p>Mostly_Harmless</p><p>写于2023.11.20 上午十时</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231117_指针，地址，字符串</title>
      <link href="/2023/11/17/20231117-Notes/"/>
      <url>/2023/11/17/20231117-Notes/</url>
      
        <content type="html"><![CDATA[<p>写一下CS50学习过程中关于指针和地址部分的笔记和心得，其实就是在下面的注释部分，但是还是整理一下。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(void){    int n = 50;    char *s = "HI!";    int *p = &amp;n; // p 是一个 指向int类型变量 的地址 的 整数 8 bytes    // p 用来存储地址    printf("%i\n", n);    printf("%p\n", p); // %p 获取地址 &amp;n    // p 存储 n的位置 OR p 指向 n的位置    printf("%i\n", *p);    // 打印 p所指向的那个东西，De-reference 解引用=    printf("%p\n", s);    printf("%s\n", s);    // %s (String) 不仅仅是打印了个变量值，更是根据你提供的地址找到了TA！    // 这块一定要理解好，printf不需要找到*s,他只需要找到s，也就是这个字符串的第一位(s[0])开始的地方，然后遍历到\0就可以了，所以    // 我们这里没有写 *s，而是直接s。因为*s对应的就是s[0]这么一个单字母了，我们不需要这个    printf("%s\n", s + 1);    // s + 1 就是将起始位置向后移动了一位，于是只会打印出 “I!”    printf("%c %c\n", s[0], *(s + 0));    // %c 打印 *s 的字符 就是相当于s[0]，因为s指向的就是这个字符串起始位置，也就是H所在的位置    printf("%c %c\n", s[1], *(s + 1));    printf("%c %c\n", s[2], *(s + 2));    // 其实类似于 s[i] 的这种 “语法糖” ，在编译时是这样处理的：    // s[i] --&gt; *(s + i)    // 不用在乎数据类型的问题，编译器会自动为你换算    // 所以让我们做点禁忌的事情    // printf("%c\n", *(s + 20000));    // Segmentation fault (core dumped)    // 访问了不该访问的内存    // strcmp 做了个什么事情呢？    // 比如 s, t 是两个strings    // 我们怎么判断他们是否相等？    // i form 1 to n 判断 *(s + i) ?= *(t + i)    // strcmp(s, t) 就是帮你干了这么件事情    // 若是相同的，return 0;    // 若是字典序 s &gt; t, return 1;    // 若是字典序 s &lt; t, return -1;    string m = get_string("m: ");    string t = get_string("t: ");    printf("%p\n", m);    printf("%p\n", t);}</code></pre><p>其实指针部分的主要问题就是C语言对于 * 这个符号的“滥用”。</p><p>1.int *p = &amp;n;<br>此时*的作用是<strong>定义指针</strong>，p 是一个<strong>指向int类型变量的地址</strong>的<strong>整数</strong>，大小为8 bytes。</p><p>p 可以理解为存储了<strong>n的位置</strong>，你知道p，也就能找到n，并且n在内存中的位置是确定的，尽管n的数值会改变，但是这个变量所在的位置是在其被定义的那个时候就确定了。</p><p>2.printf(“%i\n”, *p);<br>此时*的作用就是<strong>De-reference 解引用指针</strong>，寻找到p对应的那个“东西”。</p><hr><p>剩下的就是一些细枝末节的东西，例如：</p><p>%p就是打印p所指向的<strong>地址</strong><br>e.g:printf(“%p\n”, p); 输出的就是0x16b6c710c，也就是n所在的地址。</p><p>对于字符串 (char数组) 而言，printf中的%s，你只需要提供你想要打印的起始位置，printf函数会自动替你完成“<strong>往下走，直到\0</strong>”的步骤。</p><p>e.g:</p><pre><code>char *s = "HI!";printf("%p\n", s); // out:0x16ae1f108printf("%s\n", s); // out:HI! printf("%s\n", s + 1); // out:I!</code></pre><p>我们这里没有写 *s，而是直接写s。因为*s对应的就是s[0]所对应的这么一个单字母(H)了，我们不需要这个，我们需要的是起始位置，也就是起始的地址。</p><p>类似于 s[i] 的这种 “语法糖” ，在编译时是这样处理的：<strong>s[i] –&gt; *(s + i)</strong><br>不用担心，编译器会为你做好一切，这类语法🍬还是很好用的。</p><hr><p>来点<strong>禁忌</strong>的事情</p><p>比如我们写这么一个东西</p><pre><code>printf("%c\n", *(s + 200000));</code></pre><p>我们想访问一下 s后200000位内存存着些什么，但是运行的时候就是**Segmentation fault (core dumped)**，你访问了（我访问了/计算机访问了）不该访问的内存。</p><hr><p>我们再围绕字符串写一点点东西，比如<strong>strings.h</strong>库中的<strong>strcmp</strong>函数，它的实现原理就是：输入s, t两个strings。然后开始判断 *(s + i) ?= *(t + i)，其中i从0到n遍历。</p><p>若是相同的，return 0;<br>若是字典序 s &gt; t, return 1;<br>若是字典序 s &lt; t, return -1;</p><p>Mostly_Harmless</p><p>写于2023.11.16 下午二时</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231011_新创世纪</title>
      <link href="/2023/10/11/20231011-%E6%96%B0%E5%88%9B%E4%B8%96%E7%BA%AA/"/>
      <url>/2023/10/11/20231011-%E6%96%B0%E5%88%9B%E4%B8%96%E7%BA%AA/</url>
      
        <content type="html"><![CDATA[<p>新创世纪</p><p>Hello，World！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
