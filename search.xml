<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>20231128_CS50_Data Stucture</title>
      <link href="/2023/11/28/20231128-CS50_Data%20Stucture/"/>
      <url>/2023/11/28/20231128-CS50_Data%20Stucture/</url>
      
        <content type="html"><![CDATA[<p>这应该是<code>CS50</code>笔记的最后一弹了，其C语言部分的最后一个lecture也是有关于<code>Data structure</code>的，今天写这些就当作复习了。</p><hr><h2 id="链表-LIST"><a href="#链表-LIST" class="headerlink" title="链表 LIST"></a>链表 LIST</h2><pre><code class="c">typedef struct node{    int number;    struct node *next;} node;</code></pre><p>This is the basic stucture of LIST. Every node has a part which contains data, and a pointer which stores the address of the next node. So that these node can be linked together one by one, forming a chain.</p><p>Let’s discuss  th below code from Malan.</p><pre><code class="c">int main(int argc, char *argv[]) // 加入命令行参数{    node *list = NULL; // 定义了一个空链表，即元素数量为0的链表    for (int i = 1; i &lt; argc; i++) // argv的第一个值是 程序的名称    {        int number = atoi(argv[i]); // atoi 将ASCII码转换为整数，只要你输入的是数字        node *n = malloc(sizeof(node));        if (n == NULL)        {            return 1;        }        n-&gt;number = number;        n-&gt;next = NULL;        n-&gt;next = list;        list = n;    }    // node *ptr = list;    // while (ptr != NULL)    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next) // 和上面的两行是等价的    {        printf("%i\n", ptr-&gt;number);    }    // 开始释放    node *ptr = list; // 回到开头    while (ptr != NULL)    {        node *next = ptr-&gt;next;        free(ptr);        ptr = next;    }    return 0;}</code></pre><p>This small program can create a LIST with numbers based on the input of the commandline arguments, and print them from front to back. After performing these operations, the memory can be freed all.</p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/WechatIMG406.5xrdesyyi2gw.webp" alt="WechatIMG406"></p><p>This photo shows that <code>HOW TO INSERT A NODE INTO A LIST</code>.</p><hr><p>Generally, if we want to read a LIST, we need a temporary pointer(like <code>ptr</code>)to traverse the entire chain, until it reaches the node we need.</p><pre><code class="c">// node *ptr = list;// while (ptr != NULL)    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next) // 和上面的两行是等价的    {        printf("%i\n", ptr-&gt;number);    }</code></pre><p><code>node *ptr = list</code> is to create a temporary pointer<code>ptr</code>.<br><code>ptr != NULL</code> serves as a limitation, preventing access to prohibited memory or handling cases where the memory allocated for ptr was not available during its creation.<br><code>ptr = ptr-&gt;next</code> enables us to obtain the next node in the sequence after the current one.</p><hr><p>A very important thing is the freeing of the linked list. This process relies on the temp pointer, but it also involves another pointer, <code>next</code>. Nodes are deleted from the front to the back one by one.</p><pre><code class="c">    node *ptr = list; // 回到开头    while (ptr != NULL)    {        node *next = ptr-&gt;next; // 先get下一个node        free(ptr);        ptr = next;    }</code></pre><hr><p><strong>Pros:</strong></p><ol><li>Dynamic Memory Allocation: We don’t need a complete memory space; instead, the structure allows us to adjust the amount of data by creating or deleting nodes. Knowing the total number of data elements in advance is unnecessary, and there is no pre-allocation of space.</li><li>Efficient Insertion and Deletion: Due to the pointer relationships between nodes, inserting and deleting nodes in a linked list is more efficient than in arrays. The adjustment mostly relies on changing the pointer.</li><li>Minor Impact: When you change a node, the only nodes on either side of it will be impacted.</li></ol><p><strong>Cons:</strong></p><ol><li>Memory Overhead/Extra Storage for Pointers: Each node in a linked list contains both data and a pointer to the next node. This additional overhead consumes more memory compared to arrays, where only the data needs to be stored.</li><li>Sequential Access: Unlike arrays, linked lists don’t provide constant-time access to individual elements. To access an element, you must start from the head (or another known node) and traverse the whole list sequentially. This makes random access time, especially for a large list.</li></ol><p><code>Doubly-Linked Lists</code> has a more pointer to contain the address of the previous node.</p><h2 id="Trees-🌲"><a href="#Trees-🌲" class="headerlink" title="Trees 🌲"></a>Trees 🌲</h2><p>The stucture of a tree contains many nodes, and every node has three parts<code>*left</code> <code>*right</code> <code>data</code>.</p><p><strong>Similarities:</strong></p><ol><li>Nodes.</li><li>Pointers.</li></ol><p><strong>Differences:</strong></p><ol><li>Hierarchical Structure: A tree is <strong>a hierarchical data structure</strong>, comprising a root node, internal nodes, and leaf nodes. The connections between nodes form a tree-like structure. In contrast, a linked list is <strong>a linear structure</strong>, where nodes have only predecessors and successors, creating a linear sequence.</li><li>Node Relationships: In a linked list, each node usually has <strong>a single successor</strong>. In a tree, nodes can have <strong>multiple child nodes</strong>, establishing parent-child relationships. A node’s parent is the node directly above it, and its children are the nodes directly below.</li><li>Traversal Patterns: Linked lists are typically traversed <strong>linearly</strong>, from the head to the tail or vice versa. Trees can be traversed <strong>in various ways</strong>, such as pre-order, in-order, and post-order traversals.</li></ol><p><strong>Binary search trees are another data structure that can be used to store data more efficiently such that it can be searched and retrieved.</strong></p><p><strong>If the BST has a balance, the time complexity is O(log n) for all cases.</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/trees1.19cxz5qrey1s.webp" alt="trees1"></p><pre><code class="c">bool search(node *tree, int number){    if (tree == NULL)    {        return false;    }    else if (number &lt; tree-&gt;number)    {        return search(tree-&gt;left, number);    }    else if (number &gt; tree-&gt;number)    {        return search(tree-&gt;right, number);    }    else if (number == tree-&gt;number)    {        return true;    }}</code></pre><h2 id="Hashing-and-Hash-Tables-哈希化-和-哈希表"><a href="#Hashing-and-Hash-Tables-哈希化-和-哈希表" class="headerlink" title="Hashing and Hash Tables 哈希化 和 哈希表"></a>Hashing and Hash Tables 哈希化 和 哈希表</h2><p><strong>Hashing</strong> is the idea of taking a value and being able to output a value that becoms a shortcut to it later.<br><strong>A hash table</strong> is a fantastic combination of both arrays and linked lists. When implemented in code, a hash table is an array of pointers to nodes.<br><strong>A hash function</strong> is an algorithm that reduces a larger value to something small and predictable. Generally, this function takes in an item you wish to add to your hash table, and returns an integer representing the array index in which the item should be placed.</p><p>For example, hasing <em>apple</em> may hash as a value of <code>1</code>, and <em>berry</em> may be hashed as <code>2</code>. Therefore, finding <em>apple</em> is as easy as aksing the hashed algorithm where <em>apple</em> is stored.<br>However, if we have a lot of words to store, relying solely on the first character to hash them is inefficient and not ideal. In such cases, it becomes necessary to create a larger hash table.<br><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/hash1.1tgun3ha4d5s.webp" alt="hash1"><br><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/hash2.122mvup0op7k.webp" alt="hash2"></p><p><em>You, as the programmer, have to make a decision about the advantages of <strong>using more memory to have a large hash table and potentially reducing search time</strong> or <strong>using less memory and potentially increasing search time.</strong></em></p><hr><h2 id="Tries-🌲"><a href="#Tries-🌲" class="headerlink" title="Tries 🌲"></a>Tries 🌲</h2><p><strong>Tries are always searchable in constant time.</strong></p><p><strong>One downside to Tries is that they tend to take up a large amount of memory. Notice that we need 26 X 5 = 120 <code>nodes</code> just to store <em>Hagrid!</em></strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/tries1.2ksls3umjg8w.webp" alt="tries1"></p><p><strong>Harry would then be stored as follows:</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/tries2.20f1qgbvjdpc.webp" alt="tries2"></p><hr><p>Goodbye, CS50! Have a nice day!</p><p>Mostly_Harmless</p>]]></content>
      
      
      
        <tags>
            
            <tag> Notes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CS106x_Notes</title>
      <link href="/2023/11/26/CS106x-Notes/"/>
      <url>/2023/11/26/CS106x-Notes/</url>
      
        <content type="html"><![CDATA[<h2 id="lecture3-Strings-Streams-Grid"><a href="#lecture3-Strings-Streams-Grid" class="headerlink" title="lecture3 Strings, Streams, Grid"></a>lecture3 Strings, Streams, Grid</h2><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void){    string s = "Hello,world!";    cout &lt;&lt; s &lt;&lt; endl;    cout &lt;&lt; s[0] &lt;&lt;endl;    cout &lt;&lt; (int)s[0] &lt;&lt; endl; // 72    s += "HAHA"; // Hello,world!HAHA    return 0;}</code></pre><p>和Java以及其他语言的的相同点：<br>1.index索引，s[0],s[1]……<br>2.字符位于’’/“”中，同时也有前面带有反斜杠\的转义序列。</p><p>一些不同：<br>类似于string相关函数的命名，C++有一些特有的命名与函数行为。以及存在一些特殊的结构差异。<br>最令人惊讶的是<strong>C++中居然有两种不同类型的字符串</strong></p><p>对于字符以及数组的处理，和C是一样的，当时更强大了。</p><p>你可以直接进行加+的操作，把一段字符串接到已知字符串的尾部，string+string/char。但是注意：使用 + 操作符会<strong>创建新的字符串对象，并复制两个操作数的内容</strong>。这可能导致频繁的<strong>内存分配和释放</strong>，影响性能，特别是在循环中。std::append方法在原始字符串的基础上<strong>直接追加内容，避免了创建新对象和复制的开销</strong>。这在<strong>大量连接操作</strong>时更为高效。<br>平时直接用+=就可以，简单方便</p><pre><code>// +std::string str1 = "Hello";std::string str2 = "World";std::string result = str1 + str2;  // 创建新对象，效率相对较低// appendstd::string str1 = "Hello";std::string str2 = "World";str1.append(str2);  // 在原始字符串上直接追加内容，更高效</code></pre><p>他可以直接比较字典序了，用&lt;/&gt;来进行，类似于!=/==的符号也可以直接使用。这是由于C++的一个特性决定的，operator overloaing，意味着你可以<strong>重新定义操作符</strong>，以让他们处理不同的数据类型。</p><p>string的一些member function如下：</p><ol><li>s.append(str) // add text to the end of a string</li><li>s.compare(str) // return -1, 0, 1 depending on relative ordering</li><li>s.erase(index, length) // delete text from a string starting at given index</li><li>s.find(str) / s.rfind(str) // first / last index where the start of <strong>str</strong> appears(returns string::nops if not found， string::nops means Invalid or non-existent position)</li><li>s.insert(index, str) //  add text into a string at a given index</li><li>s.length() / s.size() // return number of characters in this string</li><li>s.replace(index, len, str) // replace len chars at given index with new str</li><li>s.substr(start, length) / s.substr(start) //  the next length characters beginning at start(inclusive); if length omitted, grabs till end of string.</li></ol><p><strong>C++兼容C中的string类型(即char arrays)，处理方式也一样，但是不具备任何C++中string(string objects)的特性和相应函数</strong></p><p>转换：C-&gt;C++ string(“text”)<br>    C++-&gt;C string.c_str()</p><p>C string 会如何搞乱你的代码呢？</p><pre><code>string s = "hi" + "there"; // C-string + C-string</code></pre><p>注意，程序是先处理等号右边的内容，然后返回给等号左边。此时<strong>hi</strong> 是一个C string，<strong>there</strong>也是C string，<strong>两个string无法进行相加</strong>，也就出现了bug。恐怖的事情是，编译器不会报错，你可以顺利编译，但是会发生：程序中断OR程序崩溃。<br>编译器背后的运行原理和**指针(pointer)**有关，程序会取得there的内存地址，将其与hi的内存地址相加后返回，所以无论相加后的内存地址是什么，都会在完成相加后被返回，就导致内存越界程序崩溃或者打印了一个垃圾内容。</p><pre><code>string s = "hi" + '?'; // C-string + charstring s = "hi" + 42; // C-string + int</code></pre><p>这两个也是同理，都是对内存进行操作并返回内存地址。第二个是将42个byte的偏移量加到hi的内存地址上。<br>这里可以联系到C string的一个特性，比如我们定义了一个很长的char arrays，叫做cs，那么**(cs + 10)**就是取cs这个string的第10个byte的位置，也就是第10个元素(因为char只占用1 byte，运算时先取cs的地址，然后偏移10个byte)。</p><pre><code>string s = "hi";s += 41; // "hi)" ASCII 41 -&gt; ')'</code></pre><p>这个就会好很多，先按照规范定义一个C++ string，然后进行其特有的操作。</p><p><strong>类型加强(type enhanced): stringA + stringB中任何一个是C++ string，那么结果就会是C++ string</strong></p><p>下面是一些例子：</p><pre><code>string s = string("hi") + "there"; &lt;-&gt; string s = "hi"; s += "there";// using Stanford librarys += integerToString(41); // "hi there41"int n = stringToInteger("42"); // 42</code></pre><hr><h3 id="streams"><a href="#streams" class="headerlink" title="streams"></a>streams</h3><p>如果你想读取文件中的内容，可以调用<strong>fstream</strong>这个系统库，里面有一个ifstream的class，用来处理文件输入的内容；同时有一个ofstream的class，用来处理输出至文件的内容。<br>其原理和cin/cout同源，可以用十分相似的语法去执行文件的写入和读取。</p><p>一个普遍的模式：打开文件，读取你所需要的东西，关闭文件。<br>下面是一个例子：</p><pre><code>// read and print every line of a file#include &lt;fstream&gt;...ifstream input; // 初始化，已经分配了内存空间input.open("poem.txt");string line;while(getline(input, line)) // getline()会返回一个boolean值，如果读到了就返回true，没读到东西就是false{    cout &lt;&lt; line &lt;&lt; endl;}input.close(); // 关闭input这个对象</code></pre><p>但是像下面这么写就会出大问题——最后一行会被多打印一次：</p><pre><code>while(!input.fail()) {    string line;    getline(input, line);    cout &lt;&lt; line &lt;&lt; endl;}</code></pre><p>主要问题就是 getline读取到文件最后一行时，并不会改变failbit(即input.fail()的真假性)，直到下一次尝试读取，也就是读不到东西的时候才会改变failbit。因此可能会多跑一次循环，将最后一行内容输出两次。</p><p>如果你想将文件中的一整行读入后再将文本分解成一个个character或者word，可以用<strong>istringstram</strong>(包含在sstream库中)<br>如果你想先把一些character和word存进一个buffer中，逐步累积后再进行输出的话，可以用<strong>ostringstream</strong>，这种方式来创建大型的string对象更加有效率。</p><pre><code>    int age = 45, iq = 95;    ostringstream output;    output &lt;&lt; "Z's age is " &lt;&lt; age &lt;&lt; endl;    output &lt;&lt; "and his IQ is " &lt;&lt; iq &lt;&lt; endl;    string result = output.str();    cout &lt;&lt; result &lt;&lt; endl;    return 0;    // result = "Z's age is 45\nand his IQ is 95\n"</code></pre><hr><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><p>Grid是一种collection，二维数组。在SPL中，#include “grid.h”。<br>为什么不用C++自带的二维数组呢？<br>因为C++自带的二维数组当你访问越界而读取到无关内容的时候，其不能像grid那样报出提示。类似于你学习二维数组时的“辅助轮”，是更好的选择。</p><pre><code>Grid&lt;int&gt; matrix(3, 4); // matrix(row, column)martix[0][0] = 75;</code></pre><p>Grid后的&lt;&gt;中需要填写grid中存储的数据类型，我们称之为<strong>类型参数</strong>OR<strong>模板(template)</strong>.</p><p>初始化的Grid存储的元素值根据类型参数来决定，比如int-&gt;0, double-&gt;0.0, bool-&gt;false……</p><p><strong>C++中大部分的语言库都不会将collection中的未赋值元素设为默认值</strong></p><p>当你写的函数需要用到一个Grid变量的时候，请你写引用参数&amp;，除了可以节省下Copy的时间资源外，还可以在函数中修改Grid对象中元素的值(当然，如果你想确保Grid对象不会被更改，在前面加一个 const就可以了)。</p><pre><code>int computeSum(const Grid&lt;int&gt;&amp; g){}void invert(Grid&lt;double&gt;&amp; matrix){}</code></pre><hr><p>尚未完结。 2023.11.26<br>Mostly_Harmless</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CARE7_CHATGPT</title>
      <link href="/2023/11/20/CARE7-CHATGPT/"/>
      <url>/2023/11/20/CARE7-CHATGPT/</url>
      
        <content type="html"><![CDATA[<p>CHATGPT IS FLUENT, CLEVER AND DANGEROUSLY CREATIVE.</p>]]></content>
      
      
      
        <tags>
            
            <tag> CARE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231119_排序算法 Sort</title>
      <link href="/2023/11/19/20231119-Sort/"/>
      <url>/2023/11/19/20231119-Sort/</url>
      
        <content type="html"><![CDATA[<p>写点排序算法的笔记：</p><h2 id="插入排序-InsertionSort-O-n-2"><a href="#插入排序-InsertionSort-O-n-2" class="headerlink" title="插入排序 InsertionSort O(n^2)"></a>插入排序 InsertionSort O(n^2)</h2><pre><code>void insertSort(int arr[], int begin, int end){    // int length = end - begin + 1;    for (int i = begin + 1; i &lt; end + 1; i++)    {        for (int j = i; j &gt; begin; j--)        {            if (arr[j] &lt; arr[j - 1])            {                swap(&amp;arr[j], &amp;arr[j - 1]);            }else            {                break;            }        }    }}</code></pre><p>插入排序的本质就是排个头，先把第一个固定住，然后看第二个，第二个要是比第一个矮，就swap一下。</p><p>然后看第三个，第三个有没有第二个矮，要是矮，swap，此时第三个变成了第二个，再判断一下它和第一个的关系…………</p><p>循环往复，最后就排序完毕了。</p><hr><h2 id="快速排序-QuickSort-O-nlogn"><a href="#快速排序-QuickSort-O-nlogn" class="headerlink" title="快速排序 QuickSort O(nlogn)"></a>快速排序 QuickSort O(nlogn)</h2><pre><code>void QuickSort(int array[], int low , int high){       if(low&lt;high){    int index = array[low];    int i = low;    int j = high;    while (i&lt;j)    {        while (i&lt;j &amp;&amp; array[j] &gt;= index)        {            j--;        }        if (i&lt;j)        {            swap(&amp;array[i], &amp;array[j]);            i++;        }        while (i&lt;j &amp;&amp; array[i]&lt;index)        {            i++;        }        if(i&lt;j)        {            swap(&amp;array[i], &amp;array[j]);            j--;        }     }    array[i] = index;    QuickSort(array,low,i-1);    QuickSort(array,i+1,high);    }}</code></pre><p>快速排序是我接触的第一个排序算法，也是第一个利用到了分治和递归思想的算法。</p><p>说大白话就是<strong>分堆</strong>，我们先选一个“标准/标杆”(index), 这里我直接选的是第一项，然后我们把所有小于index的元素，都swap到index左边，大于index的元素都swap到右边。这样我们就获得了两堆数。之后对着这两堆数进行递归操作，反复的分堆分堆，分到什么时候呢？分到每个堆只有一个数字了，这也就意味着我们分完了。</p><p>在分堆的过程也是有讲究的，我们从数组的两端向中间移动。</p><pre><code>while (i&lt;j &amp;&amp; array[j] &gt;= index){    j--;}if (i&lt;j) // 这个判断就是防止因为i &gt;= j导致while终止，误操作swap，下面的if也是同理{    swap(&amp;array[i], &amp;array[j]);    i++; // 注意这个i++；}</code></pre><p>上面这段就是从最右端往左走，大的我们就留下，一旦发现小的，我们就直接swap到左边，同时从左边swap一个数字过来。可能你想问，如果我们swap过来的那个数字也小于index，应该放在左边怎么办呢？不急，我们接着往下看。</p><pre><code>while (i&lt;j &amp;&amp; array[i]&lt;index){    i++;}if(i&lt;j){    swap(&amp;array[i], &amp;array[j]);    j--;} </code></pre><p>这段开始我们从左端往右走，和上面的同理，小的我们留下，一旦发现大的，我们直接swap到右边，同时从右边swap一个数字过来。这个疑问又出现了，我们如果swap了一个大于index数字过来怎么办？</p><p>还好，循环会解决这些疑问。</p><p>当你进入下一轮最外层的while循环时，我们首先就会判断上一轮swap过来的**array [ j ]**满不满足我们的需求，如果不满足，果断扔回去。第二个也是同理。</p><p>就这样，不断的把数字扔来扔去，我们就得到了一个排好序的数组。</p><hr><h2 id="并归排序-mergeSort-O-nlogn"><a href="#并归排序-mergeSort-O-nlogn" class="headerlink" title="并归排序 mergeSort O(nlogn)"></a>并归排序 mergeSort O(nlogn)</h2><pre><code>void merge(int arr[], int left, int mid, int right){    int i, j, k;    int l = mid - left + 1;    int r = right - mid;    // 创建两个临时数组 L/R    int *L = (int *)malloc(l * sizeof(int));    int *R = (int *)malloc(r * sizeof(int));    // 把数字放进去    for (i = 0; i &lt; l; i++)    {        L[i] = arr[left + i];    }    for (j = 0; j &lt; r; j++)    {        R[j] = arr[mid + 1 + j];    }    // 开始分吧    i = 0;    j = 0;    k = left; // 众神归位    while (i &lt; l &amp;&amp; j &lt; r)    {        if (L[i] &lt;= R[j])        {            arr[k] = L[i];            i++;        }        else        {            arr[k] = R[j];            j++;        }        k++;    }    // 把剩下的元素处理干净    while (i &lt; l)    {        arr[k] = L[i];        i++;        k++;    }    while (j &lt; r)    {        arr[k] = R[j];        j++;        k++;    }    // free一下，养成好习惯    free(L);    free(R);}void mergeSort(int arr[], int left, int right){    if (left &lt; right) // 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊，不要忘了比较这个啊啊啊啊啊啊啊啊啊啊啊啊啊啊    {        int mid = left + (right - left) / 2;        mergeSort(arr, left, mid);        mergeSort(arr, mid + 1, right);        merge(arr, left, mid, right);    }}</code></pre><p>并归排序的实质，在我理解看来就是局部的有序，然后进行整合。我们通过递归，获得了大量的size为2(或1)的有序的子数组，然后我们选两个，因为在他们内部已经有序了，所以我们比第一个数字的大小，谁大谁放第一个…………就这样，两个有序数组合并成了一个大的有序数组，最终实现了排序。</p><hr><p>先写到这里，未完待续</p><p>Mostly_Harmless</p><p>写于2023.11.20 上午十时</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231117_指针，地址，字符串</title>
      <link href="/2023/11/17/20231117-Notes/"/>
      <url>/2023/11/17/20231117-Notes/</url>
      
        <content type="html"><![CDATA[<p>写一下CS50学习过程中关于指针和地址部分的笔记和心得，其实就是在下面的注释部分，但是还是整理一下。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(void){    int n = 50;    char *s = "HI!";    int *p = &amp;n; // p 是一个 指向int类型变量 的地址 的 整数 8 bytes    // p 用来存储地址    printf("%i\n", n);    printf("%p\n", p); // %p 获取地址 &amp;n    // p 存储 n的位置 OR p 指向 n的位置    printf("%i\n", *p);    // 打印 p所指向的那个东西，De-reference 解引用=    printf("%p\n", s);    printf("%s\n", s);    // %s (String) 不仅仅是打印了个变量值，更是根据你提供的地址找到了TA！    // 这块一定要理解好，printf不需要找到*s,他只需要找到s，也就是这个字符串的第一位(s[0])开始的地方，然后遍历到\0就可以了，所以    // 我们这里没有写 *s，而是直接s。因为*s对应的就是s[0]这么一个单字母了，我们不需要这个    printf("%s\n", s + 1);    // s + 1 就是将起始位置向后移动了一位，于是只会打印出 “I!”    printf("%c %c\n", s[0], *(s + 0));    // %c 打印 *s 的字符 就是相当于s[0]，因为s指向的就是这个字符串起始位置，也就是H所在的位置    printf("%c %c\n", s[1], *(s + 1));    printf("%c %c\n", s[2], *(s + 2));    // 其实类似于 s[i] 的这种 “语法糖” ，在编译时是这样处理的：    // s[i] --&gt; *(s + i)    // 不用在乎数据类型的问题，编译器会自动为你换算    // 所以让我们做点禁忌的事情    // printf("%c\n", *(s + 20000));    // Segmentation fault (core dumped)    // 访问了不该访问的内存    // strcmp 做了个什么事情呢？    // 比如 s, t 是两个strings    // 我们怎么判断他们是否相等？    // i form 1 to n 判断 *(s + i) ?= *(t + i)    // strcmp(s, t) 就是帮你干了这么件事情    // 若是相同的，return 0;    // 若是字典序 s &gt; t, return 1;    // 若是字典序 s &lt; t, return -1;    string m = get_string("m: ");    string t = get_string("t: ");    printf("%p\n", m);    printf("%p\n", t);}</code></pre><p>其实指针部分的主要问题就是C语言对于 * 这个符号的“滥用”。</p><p>1.int *p = &amp;n;<br>此时*的作用是<strong>定义指针</strong>，p 是一个<strong>指向int类型变量的地址</strong>的<strong>整数</strong>，大小为8 bytes。</p><p>p 可以理解为存储了<strong>n的位置</strong>，你知道p，也就能找到n，并且n在内存中的位置是确定的，尽管n的数值会改变，但是这个变量所在的位置是在其被定义的那个时候就确定了。</p><p>2.printf(“%i\n”, *p);<br>此时*的作用就是<strong>De-reference 解引用指针</strong>，寻找到p对应的那个“东西”。</p><hr><p>剩下的就是一些细枝末节的东西，例如：</p><p>%p就是打印p所指向的<strong>地址</strong><br>e.g:printf(“%p\n”, p); 输出的就是0x16b6c710c，也就是n所在的地址。</p><p>对于字符串 (char数组) 而言，printf中的%s，你只需要提供你想要打印的起始位置，printf函数会自动替你完成“<strong>往下走，直到\0</strong>”的步骤。</p><p>e.g:</p><pre><code>char *s = "HI!";printf("%p\n", s); // out:0x16ae1f108printf("%s\n", s); // out:HI! printf("%s\n", s + 1); // out:I!</code></pre><p>我们这里没有写 *s，而是直接写s。因为*s对应的就是s[0]所对应的这么一个单字母(H)了，我们不需要这个，我们需要的是起始位置，也就是起始的地址。</p><p>类似于 s[i] 的这种 “语法糖” ，在编译时是这样处理的：<strong>s[i] –&gt; *(s + i)</strong><br>不用担心，编译器会为你做好一切，这类语法🍬还是很好用的。</p><hr><p>来点<strong>禁忌</strong>的事情</p><p>比如我们写这么一个东西</p><pre><code>printf("%c\n", *(s + 200000));</code></pre><p>我们想访问一下 s后200000位内存存着些什么，但是运行的时候就是**Segmentation fault (core dumped)**，你访问了（我访问了/计算机访问了）不该访问的内存。</p><hr><p>我们再围绕字符串写一点点东西，比如<strong>strings.h</strong>库中的<strong>strcmp</strong>函数，它的实现原理就是：输入s, t两个strings。然后开始判断 *(s + i) ?= *(t + i)，其中i从0到n遍历。</p><p>若是相同的，return 0;<br>若是字典序 s &gt; t, return 1;<br>若是字典序 s &lt; t, return -1;</p><p>Mostly_Harmless</p><p>写于2023.11.16 下午二时</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231024_近期计划</title>
      <link href="/2023/10/24/20231024-%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/"/>
      <url>/2023/10/24/20231024-%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=2005470573&amp;auto=0&amp;height=66"></iframe><p>好久没写博客了，今天线代出分 11/15。其实随着这两天看一些东西，包括进行一些自己的简单思考，也逐渐把大学的一个方向定了下来。</p><h1 id="近期计划"><a href="#近期计划" class="headerlink" title="近期计划"></a>近期计划</h1><p>先讲讲近期计划吧，我已经把Markdown语法忘的差不多了，所以我现在去复习一下markdown语法。</p><p>复习的差不多了，突然想到，按照惯例，我应该在开头放一首歌的。妈的，好多网易云的歌曲由于VIP不能生成外联播放器了，First Love！</p><p>目前第一学期主要是三门课: </p><ol><li>工科数学分析 // 微积分</li><li>线性代数 // 代数与几何</li><li>程序设计 // C语言</li></ol><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h2><p>为什么先从它说起呢？因为这个小家伙在开学初期，甚至是整个9月份，极大的拖慢了我的学习进度。当然，肯定不是这门课的问题，而是我太久没<strong>学习</strong>，以至于失去了自己的<strong>学习节奏</strong>的问题。</p><p>我首先选中了Strang讲授的MIT 18.06课程，但是犯了一个大毛病：</p><blockquote><p>只听课，不记笔记；<br>只看视频，不写题；<br>只顾赶进度，忘记了质量；<br>听课的时候注意力极度不集中，经常一整手机就拿起来了，外加 <strong>倍速和非母语</strong> 这两个DeBuff的加持下，听课效果大打折扣。</p></blockquote><p>当然，我也很快的意识到这个情况，并且采取了补救措施：</p><blockquote><p>直接重开，从lecture1开始听，边听边记笔记；<br>重听的过程中，降低倍速，刹下心来认真的去听讲。</p></blockquote><p>目前进度已经来到了lecture11结束，明天Review一下。一共是35个lectures，争取11月底结课。</p><hr><p>你以为只有这么点问题？如果真的只有这么点，那也不会让我这么头大。</p><p>另一个深深困扰到我的问题就是：学校的课程编排与18.06完全不同，以及一些名词和概念的不尽相同，使得我脑瓜子嗡嗡的。</p><p>举个例子：我们学校的教材上来就是行列式，而Strang全程围绕着矩阵展开，行列式要等到极其靠后的位置才会展开。</p><p>后来我得解决方案是什么呢？那就是<strong>我全都要</strong>。</p><p>学校这边，作业+教材+习题册一把抓，外加一个B站up主<a href="https://space.bilibili.com/1896150601">@当年线代</a>，完美的将我的线代补完了。</p><p>但是由于当时的欠缺与延误，在某些细节的知识点处理上还是出现了些问题，外加刷题量不够，期中考试还是有些失误，但是不重要，区区15%。</p><p>那接下来要干些什么呢？</p><p>我把所有的TODO-list扔到了文章的结尾。</p><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>之前在听 OLD_CS50 + 浙江大学翁恺教授 这两门C语言课，OLD_CS50由于实在太过古老，听了几讲就放弃了；而后者则听到了字符串。<strong>注意：这里我犯了和线代一样的问题，赶进度，没有巩固练习</strong>。</p><p>于是我就转头去打了洛谷。由于完成洛谷的题单也占我们这门课分数的一部分，所以也就做的乐此不疲。</p><p>但是做着做着发现问题了：虽然做题是一个很好的巩固知识点的方式，但是之前的知识太零碎了，不成体系，做题的时候就极其不爽，还总爆WA。再继续做下去的话，那就是为了做题而做题了，达不到锻炼能力的目的了。</p><p>外加上准备 数学分析和线性代数 两门课的期中考试，我在期中考试前暂停了洛谷的刷题。</p><p>期中考试后，偶然间发现了B站热心人士人工翻译的新版CS50，于是就开始：<strong>CS50，启动!</strong></p><p>目前做到了lecture4，不得不说，这个课程的Lab和Pest(Problem Set)的设计都很牛逼，除了英语这个障碍，我没什么好说的。</p><p>这门课程的C语言部分到Lecture5就结束了，这周末(2023/10/29)弄完之后，我就准备回到洛谷刷题+复习一下基本的东西(比如字符串、数组、指针……)</p><p>收拾收拾就得开始下一轮课程了</p><blockquote><p>你学了CS50，106x进行完前十集，就可以走起csapp了<br>学完106x，就可以走起MIT 6.006算法导论</p></blockquote><p>目前感觉尚可。</p><h2 id="工科数学分析"><a href="#工科数学分析" class="headerlink" title="工科数学分析"></a>工科数学分析</h2><p>从我把它扔到最后来讲你就知道我对这个课的感情。</p><p>先给结论：<strong>学的不好</strong></p><p>补救措施：<strong>认真的把教材/习题册/习题集上的题老老实实做一遍</strong></p><p>期中考试的分数一定不会很好看。是我的问题，老师讲的很好。</p><hr><p>我有点困了，想回宿舍睡觉了，淑芬的内容我明后天有时间再补充吧。</p><p>先把TODOList写了。</p><ul><li><input checked="" disabled="" type="checkbox"> MIT 18.06 DDL:2023/12/10</li><li><input disabled="" type="checkbox"> 线性代数100题 DDL:2023/12/20</li><li><input checked="" disabled="" type="checkbox"> CS50 Lecture5 DDL:2023/10/29</li><li><input checked="" disabled="" type="checkbox"> 洛谷入门题单 DDL:2023/12/7</li><li><input checked="" disabled="" type="checkbox"> 写几篇CS50有关的总结笔记并发在Blog上 DDL:2023/12/1</li><li><input disabled="" type="checkbox"> CS 106X DDL:2024/1/1</li><li><input disabled="" type="checkbox"> 微积分教材习题(追上进度) DDL:2023/11/30</li><li><input disabled="" type="checkbox"> 抢进度，抢进度，抢进度 DDL: NULL</li></ul><p>Mostly_Harmless</p><p>写于2023.10.25 凌晨一点 正心804</p><hr><p>UPDATE 20231116：</p><p>MIT 18.06 lecture15 锐意进行中；</p><p>CS50 Lecture5已经结束，但是Lab和pest还没有做；</p><p>微积分教材习题已经追到了 不定积分，目前课程进度是定积分部分；</p><p>DDL部分推迟。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20231011_新创世纪</title>
      <link href="/2023/10/11/20231011-%E6%96%B0%E5%88%9B%E4%B8%96%E7%BA%AA/"/>
      <url>/2023/10/11/20231011-%E6%96%B0%E5%88%9B%E4%B8%96%E7%BA%AA/</url>
      
        <content type="html"><![CDATA[<p>新创世纪</p><p>Hello，World！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
