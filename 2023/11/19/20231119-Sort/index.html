<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>20231119_排序算法 Sort</title><meta name="description" content="May the Force be with you"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="写点排序算法的笔记：
插入排序 InsertionSort O(n^2)
void insertSort(int arr[], int begin, int end)
{
    // int length = end - begin + 1;
    for (int i = begin + 1; i &amp;lt; end + 1; i++)
    {
        for (int j = i; j &amp;gt; begin; j--)
        {
            if (arr[j] &amp;lt; arr[j - 1])
            {
                swap(&amp;amp;arr[j], &amp;amp;arr[j - 1]);
            }else
   .."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Mostly_Harmless的碎碎念" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mostly_Hamrless's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">20231119_排序算法 Sort</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-InsertionSort-O-n-2"><span class="toc-text">插入排序 InsertionSort O(n^2)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-QuickSort-O-nlogn"><span class="toc-text">快速排序 QuickSort O(nlogn)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%BD%92%E6%8E%92%E5%BA%8F-mergeSort-O-nlogn"><span class="toc-text">并归排序 mergeSort O(nlogn)</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E7%AC%94%E8%AE%B0"><i class="tag post-item-tag">笔记</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">20231119_排序算法 Sort</h1><time class="has-text-grey" datetime="2023-11-19T15:09:59.000Z">2023-11-19</time><article class="mt-2 post-content"><p>写点排序算法的笔记：</p>
<h2 id="插入排序-InsertionSort-O-n-2"><a href="#插入排序-InsertionSort-O-n-2" class="headerlink" title="插入排序 InsertionSort O(n^2)"></a>插入排序 InsertionSort O(n^2)</h2><pre><code>
void insertSort(int arr[], int begin, int end)
{
    // int length = end - begin + 1;
    for (int i = begin + 1; i &lt; end + 1; i++)
    {
        for (int j = i; j &gt; begin; j--)
        {
            if (arr[j] &lt; arr[j - 1])
            {
                swap(&amp;arr[j], &amp;arr[j - 1]);
            }else
            {
                break;
            }
        }
    }
}
</code></pre>
<p>插入排序的本质就是排个头，先把第一个固定住，然后看第二个，第二个要是比第一个矮，就swap一下。</p>
<p>然后看第三个，第三个有没有第二个矮，要是矮，swap，此时第三个变成了第二个，再判断一下它和第一个的关系…………</p>
<p>循环往复，最后就排序完毕了。</p>
<hr>
<h2 id="快速排序-QuickSort-O-nlogn"><a href="#快速排序-QuickSort-O-nlogn" class="headerlink" title="快速排序 QuickSort O(nlogn)"></a>快速排序 QuickSort O(nlogn)</h2><pre><code>void QuickSort(int array[], int low , int high)
{   
    if(low&lt;high){
    int index = array[low];
    int i = low;
    int j = high;
    while (i&lt;j)
    {
        while (i&lt;j &amp;&amp; array[j] &gt;= index)
        {
            j--;
        }

        if (i&lt;j)
        {
            swap(&amp;array[i], &amp;array[j]);
            i++;
        }

        while (i&lt;j &amp;&amp; array[i]&lt;index)
        {
            i++;
        }

        if(i&lt;j)
        {
            swap(&amp;array[i], &amp;array[j]);
            j--;
        } 
    }
    array[i] = index;
    QuickSort(array,low,i-1);
    QuickSort(array,i+1,high);
    }
}
</code></pre>
<p>快速排序是我接触的第一个排序算法，也是第一个利用到了分治和递归思想的算法。</p>
<p>说大白话就是<strong>分堆</strong>，我们先选一个“标准/标杆”(index), 这里我直接选的是第一项，然后我们把所有小于index的元素，都swap到index左边，大于index的元素都swap到右边。这样我们就获得了两堆数。之后对着这两堆数进行递归操作，反复的分堆分堆，分到什么时候呢？分到每个堆只有一个数字了，这也就意味着我们分完了。</p>
<p>在分堆的过程也是有讲究的，我们从数组的两端向中间移动。</p>
<pre><code>while (i&lt;j &amp;&amp; array[j] &gt;= index)
{
    j--;
}

if (i&lt;j) // 这个判断就是防止因为i &gt;= j导致while终止，误操作swap，下面的if也是同理
{
    swap(&amp;array[i], &amp;array[j]);
    i++; // 注意这个i++；
}
</code></pre>
<p>上面这段就是从最右端往左走，大的我们就留下，一旦发现小的，我们就直接swap到左边，同时从左边swap一个数字过来。可能你想问，如果我们swap过来的那个数字也小于index，应该放在左边怎么办呢？不急，我们接着往下看。</p>
<pre><code>while (i&lt;j &amp;&amp; array[i]&lt;index)
{
    i++;
}

if(i&lt;j)
{
    swap(&amp;array[i], &amp;array[j]);
    j--;
} 
</code></pre>
<p>这段开始我们从左端往右走，和上面的同理，小的我们留下，一旦发现大的，我们直接swap到右边，同时从右边swap一个数字过来。这个疑问又出现了，我们如果swap了一个大于index数字过来怎么办？</p>
<p>还好，循环会解决这些疑问。</p>
<p>当你进入下一轮最外层的while循环时，我们首先就会判断上一轮swap过来的**array [ j ]**满不满足我们的需求，如果不满足，果断扔回去。第二个也是同理。</p>
<p>就这样，不断的把数字扔来扔去，我们就得到了一个排好序的数组。</p>
<hr>
<h2 id="并归排序-mergeSort-O-nlogn"><a href="#并归排序-mergeSort-O-nlogn" class="headerlink" title="并归排序 mergeSort O(nlogn)"></a>并归排序 mergeSort O(nlogn)</h2><pre><code>void merge(int arr[], int left, int mid, int right)
{
    int i, j, k;
    int l = mid - left + 1;
    int r = right - mid;

    // 创建两个临时数组 L/R
    int *L = (int *)malloc(l * sizeof(int));
    int *R = (int *)malloc(r * sizeof(int));

    // 把数字放进去
    for (i = 0; i &lt; l; i++)
    {
        L[i] = arr[left + i];
    }
    for (j = 0; j &lt; r; j++)
    {
        R[j] = arr[mid + 1 + j];
    }

    // 开始分吧
    i = 0;
    j = 0;
    k = left; // 众神归位
    while (i &lt; l &amp;&amp; j &lt; r)
    {
        if (L[i] &lt;= R[j])
        {
            arr[k] = L[i];
            i++;
        }
        else
        {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // 把剩下的元素处理干净
    while (i &lt; l)
    {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j &lt; r)
    {
        arr[k] = R[j];
        j++;
        k++;
    }

    // free一下，养成好习惯
    free(L);
    free(R);
}

void mergeSort(int arr[], int left, int right)
{
    if (left &lt; right) // 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊，不要忘了比较这个啊啊啊啊啊啊啊啊啊啊啊啊啊啊
    {
        int mid = left + (right - left) / 2;

        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        merge(arr, left, mid, right);
    }
}
</code></pre>
<p>并归排序的实质，在我理解看来就是局部的有序，然后进行整合。我们通过递归，获得了大量的size为2(或1)的有序的子数组，然后我们选两个，因为在他们内部已经有序了，所以我们比第一个数字的大小，谁大谁放第一个…………就这样，两个有序数组合并成了一个大的有序数组，最终实现了排序。</p>
<hr>
<p>先写到这里，未完待续</p>
<p>Mostly_Harmless</p>
<p>写于2023.11.20 上午十时</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/11/20/CARE7-CHATGPT/" title="CARE7_CHATGPT"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: CARE7_CHATGPT</span></a><a class="button is-default" href="/2023/11/17/20231117-Notes/" title="20231117_指针，地址，字符串"><span class="has-text-weight-semibold">下一页: 20231117_指针，地址，字符串</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mostlyharmlessxyz"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mostly_Hamrless 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>