<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mostly_Harmless的碎碎念</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-12-29T16:19:36.962Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mostly_Harmless</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20231229_期末，寒假，以及下学期</title>
    <link href="http://example.com/2023/12/29/20231229-%E6%9C%9F%E6%9C%AB%EF%BC%8C%E5%AF%92%E5%81%87%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8B%E5%AD%A6%E6%9C%9F/"/>
    <id>http://example.com/2023/12/29/20231229-%E6%9C%9F%E6%9C%AB%EF%BC%8C%E5%AF%92%E5%81%87%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8B%E5%AD%A6%E6%9C%9F/</id>
    <published>2023-12-29T15:10:23.000Z</published>
    <updated>2023-12-29T16:19:36.962Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=394648&amp;auto=0&amp;height=66"></iframe><p>上次写这种类型的博客还是10月24日，那是期中考试之后，成绩刚出来。当时看到成绩单，下定决心，痛定思痛，捋顺了一下思路，把各科的问题以及对应的解决思路记录了下来，并列了下TO-DO List。</p><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/Blog_Pic@master/20231229/%E6%88%AA%E5%B1%8F2023-12-29-23.29.26.4by500q3g5z4.webp" alt="TODOLIST"></p><p>目前看来，完成率还可以。下半学期基本可以说是拉足马力了，呆在正心的时间已经比呆在宿舍的时间要长了。期末的四门考试课：淑芬、近代史、程序设计、线代。只剩下<code>线代(1月4日)</code>一科了，应该问题不大，该练习的都练习到了，最近几天再把一些基本的知识点和方法看一看，把往年题的错题和一百题看一看。</p><p>这学期的学分绩还没有完全出来，只出来了<code>淑芬</code>一科——89(194/624)。其实是很不尽如人意的，但是没办法，期中扣分太多，期末无力回天😂感觉最后的学分绩排名能在150+就很不错了，等到最终的绩点出来再来Update一下吧。</p><hr><p>其实这篇文章的主要内容是即将到来的寒假的计划。目前我想了这么几件事，也算是接下来的TO-DO List吧</p><ul><li><input disabled="" type="checkbox"> 淑芬下先修</li><li><input disabled="" type="checkbox"> 大雾自学(由于大雾只有大二上，后半Part才有先修)</li><li><input disabled="" type="checkbox"> CS106X(计算机冲冲冲！)</li><li><input disabled="" type="checkbox"> 概率论与数理统计</li></ul><p>怎么说呢，感觉回到了中学那会儿的<strong>抢先抓早</strong>的打法。这四个TO-DO的Deadline还未定，不想齐头并进，还是突击来的比较爽快和高效一些。但是像<code>CS106X</code>这种课又没办法突击，让我再想想吧。</p><p>寒假还需要把体重和身体调理一下，这12月的后20天真的有些难顶，无奈了。</p><p>先写到这里吧，未完待续。</p><p>Mostly_Harmless</p><p>写于2023.12.30 凌晨0时20分 A02.2108的一张床上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;amp</summary>
      
    
    
    
    
    <category term="计划, 总结" scheme="http://example.com/tags/%E8%AE%A1%E5%88%92-%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>20231128_CS50_Data Stucture</title>
    <link href="http://example.com/2023/11/28/20231128-CS50_Data%20Stucture/"/>
    <id>http://example.com/2023/11/28/20231128-CS50_Data%20Stucture/</id>
    <published>2023-11-28T06:20:58.000Z</published>
    <updated>2023-11-28T08:21:52.756Z</updated>
    
    <content type="html"><![CDATA[<p>这应该是<code>CS50</code>笔记的最后一弹了，其C语言部分的最后一个lecture也是有关于<code>Data structure</code>的，今天写这些就当作复习了。</p><hr><h2 id="链表-LIST"><a href="#链表-LIST" class="headerlink" title="链表 LIST"></a>链表 LIST</h2><pre><code class="c">typedef struct node{    int number;    struct node *next;} node;</code></pre><p>This is the basic stucture of LIST. Every node has a part which contains data, and a pointer which stores the address of the next node. So that these node can be linked together one by one, forming a chain.</p><p>Let’s discuss  th below code from Malan.</p><pre><code class="c">int main(int argc, char *argv[]) // 加入命令行参数{    node *list = NULL; // 定义了一个空链表，即元素数量为0的链表    for (int i = 1; i &lt; argc; i++) // argv的第一个值是 程序的名称    {        int number = atoi(argv[i]); // atoi 将ASCII码转换为整数，只要你输入的是数字        node *n = malloc(sizeof(node));        if (n == NULL)        {            return 1;        }        n-&gt;number = number;        n-&gt;next = NULL;        n-&gt;next = list;        list = n;    }    // node *ptr = list;    // while (ptr != NULL)    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next) // 和上面的两行是等价的    {        printf("%i\n", ptr-&gt;number);    }    // 开始释放    node *ptr = list; // 回到开头    while (ptr != NULL)    {        node *next = ptr-&gt;next;        free(ptr);        ptr = next;    }    return 0;}</code></pre><p>This small program can create a LIST with numbers based on the input of the commandline arguments, and print them from front to back. After performing these operations, the memory can be freed all.</p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/WechatIMG406.5xrdesyyi2gw.webp" alt="WechatIMG406"></p><p>This photo shows that <code>HOW TO INSERT A NODE INTO A LIST</code>.</p><hr><p>Generally, if we want to read a LIST, we need a temporary pointer(like <code>ptr</code>)to traverse the entire chain, until it reaches the node we need.</p><pre><code class="c">// node *ptr = list;// while (ptr != NULL)    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next) // 和上面的两行是等价的    {        printf("%i\n", ptr-&gt;number);    }</code></pre><p><code>node *ptr = list</code> is to create a temporary pointer<code>ptr</code>.<br><code>ptr != NULL</code> serves as a limitation, preventing access to prohibited memory or handling cases where the memory allocated for ptr was not available during its creation.<br><code>ptr = ptr-&gt;next</code> enables us to obtain the next node in the sequence after the current one.</p><hr><p>A very important thing is the freeing of the linked list. This process relies on the temp pointer, but it also involves another pointer, <code>next</code>. Nodes are deleted from the front to the back one by one.</p><pre><code class="c">    node *ptr = list; // 回到开头    while (ptr != NULL)    {        node *next = ptr-&gt;next; // 先get下一个node        free(ptr);        ptr = next;    }</code></pre><hr><p><strong>Pros:</strong></p><ol><li>Dynamic Memory Allocation: We don’t need a complete memory space; instead, the structure allows us to adjust the amount of data by creating or deleting nodes. Knowing the total number of data elements in advance is unnecessary, and there is no pre-allocation of space.</li><li>Efficient Insertion and Deletion: Due to the pointer relationships between nodes, inserting and deleting nodes in a linked list is more efficient than in arrays. The adjustment mostly relies on changing the pointer.</li><li>Minor Impact: When you change a node, the only nodes on either side of it will be impacted.</li></ol><p><strong>Cons:</strong></p><ol><li>Memory Overhead/Extra Storage for Pointers: Each node in a linked list contains both data and a pointer to the next node. This additional overhead consumes more memory compared to arrays, where only the data needs to be stored.</li><li>Sequential Access: Unlike arrays, linked lists don’t provide constant-time access to individual elements. To access an element, you must start from the head (or another known node) and traverse the whole list sequentially. This makes random access time, especially for a large list.</li></ol><p><code>Doubly-Linked Lists</code> has a more pointer to contain the address of the previous node.</p><h2 id="Trees-🌲"><a href="#Trees-🌲" class="headerlink" title="Trees 🌲"></a>Trees 🌲</h2><p>The stucture of a tree contains many nodes, and every node has three parts<code>*left</code> <code>*right</code> <code>data</code>.</p><p><strong>Similarities:</strong></p><ol><li>Nodes.</li><li>Pointers.</li></ol><p><strong>Differences:</strong></p><ol><li>Hierarchical Structure: A tree is <strong>a hierarchical data structure</strong>, comprising a root node, internal nodes, and leaf nodes. The connections between nodes form a tree-like structure. In contrast, a linked list is <strong>a linear structure</strong>, where nodes have only predecessors and successors, creating a linear sequence.</li><li>Node Relationships: In a linked list, each node usually has <strong>a single successor</strong>. In a tree, nodes can have <strong>multiple child nodes</strong>, establishing parent-child relationships. A node’s parent is the node directly above it, and its children are the nodes directly below.</li><li>Traversal Patterns: Linked lists are typically traversed <strong>linearly</strong>, from the head to the tail or vice versa. Trees can be traversed <strong>in various ways</strong>, such as pre-order, in-order, and post-order traversals.</li></ol><p><strong>Binary search trees are another data structure that can be used to store data more efficiently such that it can be searched and retrieved.</strong></p><p><strong>If the BST has a balance, the time complexity is O(log n) for all cases.</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/trees1.19cxz5qrey1s.webp" alt="trees1"></p><pre><code class="c">bool search(node *tree, int number){    if (tree == NULL)    {        return false;    }    else if (number &lt; tree-&gt;number)    {        return search(tree-&gt;left, number);    }    else if (number &gt; tree-&gt;number)    {        return search(tree-&gt;right, number);    }    else if (number == tree-&gt;number)    {        return true;    }}</code></pre><h2 id="Hashing-and-Hash-Tables-哈希化-和-哈希表"><a href="#Hashing-and-Hash-Tables-哈希化-和-哈希表" class="headerlink" title="Hashing and Hash Tables 哈希化 和 哈希表"></a>Hashing and Hash Tables 哈希化 和 哈希表</h2><p><strong>Hashing</strong> is the idea of taking a value and being able to output a value that becoms a shortcut to it later.<br><strong>A hash table</strong> is a fantastic combination of both arrays and linked lists. When implemented in code, a hash table is an array of pointers to nodes.<br><strong>A hash function</strong> is an algorithm that reduces a larger value to something small and predictable. Generally, this function takes in an item you wish to add to your hash table, and returns an integer representing the array index in which the item should be placed.</p><p>For example, hasing <em>apple</em> may hash as a value of <code>1</code>, and <em>berry</em> may be hashed as <code>2</code>. Therefore, finding <em>apple</em> is as easy as aksing the hashed algorithm where <em>apple</em> is stored.<br>However, if we have a lot of words to store, relying solely on the first character to hash them is inefficient and not ideal. In such cases, it becomes necessary to create a larger hash table.<br><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/hash1.1tgun3ha4d5s.webp" alt="hash1"><br><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/hash2.122mvup0op7k.webp" alt="hash2"></p><p><em>You, as the programmer, have to make a decision about the advantages of <strong>using more memory to have a large hash table and potentially reducing search time</strong> or <strong>using less memory and potentially increasing search time.</strong></em></p><hr><h2 id="Tries-🌲"><a href="#Tries-🌲" class="headerlink" title="Tries 🌲"></a>Tries 🌲</h2><p><strong>Tries are always searchable in constant time.</strong></p><p><strong>One downside to Tries is that they tend to take up a large amount of memory. Notice that we need 26 X 5 = 120 <code>nodes</code> just to store <em>Hagrid!</em></strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/tries1.2ksls3umjg8w.webp" alt="tries1"></p><p><strong>Harry would then be stored as follows:</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/tries2.20f1qgbvjdpc.webp" alt="tries2"></p><hr><p>Goodbye, CS50! Have a nice day!</p><p>Mostly_Harmless</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这应该是&lt;code&gt;CS50&lt;/code&gt;笔记的最后一弹了，其C语言部分的最后一个lecture也是有关于&lt;code&gt;Data structure&lt;/code&gt;的，今天写这些就当作复习了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;链表-LIST&quot;&gt;&lt;a href=&quot;#链表-LIS</summary>
      
    
    
    
    
    <category term="Notes" scheme="http://example.com/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>CS106x_Notes</title>
    <link href="http://example.com/2023/11/26/CS106x-Notes/"/>
    <id>http://example.com/2023/11/26/CS106x-Notes/</id>
    <published>2023-11-26T00:42:30.000Z</published>
    <updated>2023-11-26T12:42:28.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="lecture3-Strings-Streams-Grid"><a href="#lecture3-Strings-Streams-Grid" class="headerlink" title="lecture3 Strings, Streams, Grid"></a>lecture3 Strings, Streams, Grid</h2><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void){    string s = "Hello,world!";    cout &lt;&lt; s &lt;&lt; endl;    cout &lt;&lt; s[0] &lt;&lt;endl;    cout &lt;&lt; (int)s[0] &lt;&lt; endl; // 72    s += "HAHA"; // Hello,world!HAHA    return 0;}</code></pre><p>和Java以及其他语言的的相同点：<br>1.index索引，s[0],s[1]……<br>2.字符位于’’/“”中，同时也有前面带有反斜杠\的转义序列。</p><p>一些不同：<br>类似于string相关函数的命名，C++有一些特有的命名与函数行为。以及存在一些特殊的结构差异。<br>最令人惊讶的是<strong>C++中居然有两种不同类型的字符串</strong></p><p>对于字符以及数组的处理，和C是一样的，当时更强大了。</p><p>你可以直接进行加+的操作，把一段字符串接到已知字符串的尾部，string+string/char。但是注意：使用 + 操作符会<strong>创建新的字符串对象，并复制两个操作数的内容</strong>。这可能导致频繁的<strong>内存分配和释放</strong>，影响性能，特别是在循环中。std::append方法在原始字符串的基础上<strong>直接追加内容，避免了创建新对象和复制的开销</strong>。这在<strong>大量连接操作</strong>时更为高效。<br>平时直接用+=就可以，简单方便</p><pre><code>// +std::string str1 = "Hello";std::string str2 = "World";std::string result = str1 + str2;  // 创建新对象，效率相对较低// appendstd::string str1 = "Hello";std::string str2 = "World";str1.append(str2);  // 在原始字符串上直接追加内容，更高效</code></pre><p>他可以直接比较字典序了，用&lt;/&gt;来进行，类似于!=/==的符号也可以直接使用。这是由于C++的一个特性决定的，operator overloaing，意味着你可以<strong>重新定义操作符</strong>，以让他们处理不同的数据类型。</p><p>string的一些member function如下：</p><ol><li>s.append(str) // add text to the end of a string</li><li>s.compare(str) // return -1, 0, 1 depending on relative ordering</li><li>s.erase(index, length) // delete text from a string starting at given index</li><li>s.find(str) / s.rfind(str) // first / last index where the start of <strong>str</strong> appears(returns string::nops if not found， string::nops means Invalid or non-existent position)</li><li>s.insert(index, str) //  add text into a string at a given index</li><li>s.length() / s.size() // return number of characters in this string</li><li>s.replace(index, len, str) // replace len chars at given index with new str</li><li>s.substr(start, length) / s.substr(start) //  the next length characters beginning at start(inclusive); if length omitted, grabs till end of string.</li></ol><p><strong>C++兼容C中的string类型(即char arrays)，处理方式也一样，但是不具备任何C++中string(string objects)的特性和相应函数</strong></p><p>转换：C-&gt;C++ string(“text”)<br>    C++-&gt;C string.c_str()</p><p>C string 会如何搞乱你的代码呢？</p><pre><code>string s = "hi" + "there"; // C-string + C-string</code></pre><p>注意，程序是先处理等号右边的内容，然后返回给等号左边。此时<strong>hi</strong> 是一个C string，<strong>there</strong>也是C string，<strong>两个string无法进行相加</strong>，也就出现了bug。恐怖的事情是，编译器不会报错，你可以顺利编译，但是会发生：程序中断OR程序崩溃。<br>编译器背后的运行原理和**指针(pointer)**有关，程序会取得there的内存地址，将其与hi的内存地址相加后返回，所以无论相加后的内存地址是什么，都会在完成相加后被返回，就导致内存越界程序崩溃或者打印了一个垃圾内容。</p><pre><code>string s = "hi" + '?'; // C-string + charstring s = "hi" + 42; // C-string + int</code></pre><p>这两个也是同理，都是对内存进行操作并返回内存地址。第二个是将42个byte的偏移量加到hi的内存地址上。<br>这里可以联系到C string的一个特性，比如我们定义了一个很长的char arrays，叫做cs，那么**(cs + 10)**就是取cs这个string的第10个byte的位置，也就是第10个元素(因为char只占用1 byte，运算时先取cs的地址，然后偏移10个byte)。</p><pre><code>string s = "hi";s += 41; // "hi)" ASCII 41 -&gt; ')'</code></pre><p>这个就会好很多，先按照规范定义一个C++ string，然后进行其特有的操作。</p><p><strong>类型加强(type enhanced): stringA + stringB中任何一个是C++ string，那么结果就会是C++ string</strong></p><p>下面是一些例子：</p><pre><code>string s = string("hi") + "there"; &lt;-&gt; string s = "hi"; s += "there";// using Stanford librarys += integerToString(41); // "hi there41"int n = stringToInteger("42"); // 42</code></pre><hr><h3 id="streams"><a href="#streams" class="headerlink" title="streams"></a>streams</h3><p>如果你想读取文件中的内容，可以调用<strong>fstream</strong>这个系统库，里面有一个ifstream的class，用来处理文件输入的内容；同时有一个ofstream的class，用来处理输出至文件的内容。<br>其原理和cin/cout同源，可以用十分相似的语法去执行文件的写入和读取。</p><p>一个普遍的模式：打开文件，读取你所需要的东西，关闭文件。<br>下面是一个例子：</p><pre><code>// read and print every line of a file#include &lt;fstream&gt;...ifstream input; // 初始化，已经分配了内存空间input.open("poem.txt");string line;while(getline(input, line)) // getline()会返回一个boolean值，如果读到了就返回true，没读到东西就是false{    cout &lt;&lt; line &lt;&lt; endl;}input.close(); // 关闭input这个对象</code></pre><p>但是像下面这么写就会出大问题——最后一行会被多打印一次：</p><pre><code>while(!input.fail()) {    string line;    getline(input, line);    cout &lt;&lt; line &lt;&lt; endl;}</code></pre><p>主要问题就是 getline读取到文件最后一行时，并不会改变failbit(即input.fail()的真假性)，直到下一次尝试读取，也就是读不到东西的时候才会改变failbit。因此可能会多跑一次循环，将最后一行内容输出两次。</p><p>如果你想将文件中的一整行读入后再将文本分解成一个个character或者word，可以用<strong>istringstram</strong>(包含在sstream库中)<br>如果你想先把一些character和word存进一个buffer中，逐步累积后再进行输出的话，可以用<strong>ostringstream</strong>，这种方式来创建大型的string对象更加有效率。</p><pre><code>    int age = 45, iq = 95;    ostringstream output;    output &lt;&lt; "Z's age is " &lt;&lt; age &lt;&lt; endl;    output &lt;&lt; "and his IQ is " &lt;&lt; iq &lt;&lt; endl;    string result = output.str();    cout &lt;&lt; result &lt;&lt; endl;    return 0;    // result = "Z's age is 45\nand his IQ is 95\n"</code></pre><hr><h3 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h3><p>Grid是一种collection，二维数组。在SPL中，#include “grid.h”。<br>为什么不用C++自带的二维数组呢？<br>因为C++自带的二维数组当你访问越界而读取到无关内容的时候，其不能像grid那样报出提示。类似于你学习二维数组时的“辅助轮”，是更好的选择。</p><pre><code>Grid&lt;int&gt; matrix(3, 4); // matrix(row, column)martix[0][0] = 75;</code></pre><p>Grid后的&lt;&gt;中需要填写grid中存储的数据类型，我们称之为<strong>类型参数</strong>OR<strong>模板(template)</strong>.</p><p>初始化的Grid存储的元素值根据类型参数来决定，比如int-&gt;0, double-&gt;0.0, bool-&gt;false……</p><p><strong>C++中大部分的语言库都不会将collection中的未赋值元素设为默认值</strong></p><p>当你写的函数需要用到一个Grid变量的时候，请你写引用参数&amp;，除了可以节省下Copy的时间资源外，还可以在函数中修改Grid对象中元素的值(当然，如果你想确保Grid对象不会被更改，在前面加一个 const就可以了)。</p><pre><code>int computeSum(const Grid&lt;int&gt;&amp; g){}void invert(Grid&lt;double&gt;&amp; matrix){}</code></pre><hr><p>尚未完结。 2023.11.26<br>Mostly_Harmless</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;lecture3-Strings-Streams-Grid&quot;&gt;&lt;a href=&quot;#lecture3-Strings-Streams-Grid&quot; class=&quot;headerlink&quot; title=&quot;lecture3 Strings, Streams, Grid&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CARE7_CHATGPT</title>
    <link href="http://example.com/2023/11/20/CARE7-CHATGPT/"/>
    <id>http://example.com/2023/11/20/CARE7-CHATGPT/</id>
    <published>2023-11-20T03:04:41.000Z</published>
    <updated>2023-12-31T14:06:32.541Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4fb1e53c97b21a3e2f7b91548971548c69ba3417cf61325e198b4f05af62f89e">bd25ed9264b080267271e137e33d0ce1c2bbccdc98003fe4014325307c3e2d14e94855f283ecb759d00b11f8989a7a4b460fc15b698abf9ae08d149c5be8e74235a5be3fc0bdd6b56f01e8b84ad1dad525e5e4b90cf30443d32afb22981a492a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输个密码吧</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="CARE" scheme="http://example.com/tags/CARE/"/>
    
  </entry>
  
  <entry>
    <title>20231119_排序算法 Sort</title>
    <link href="http://example.com/2023/11/19/20231119-Sort/"/>
    <id>http://example.com/2023/11/19/20231119-Sort/</id>
    <published>2023-11-19T15:09:59.000Z</published>
    <updated>2023-11-20T02:09:19.943Z</updated>
    
    <content type="html"><![CDATA[<p>写点排序算法的笔记：</p><h2 id="插入排序-InsertionSort-O-n-2"><a href="#插入排序-InsertionSort-O-n-2" class="headerlink" title="插入排序 InsertionSort O(n^2)"></a>插入排序 InsertionSort O(n^2)</h2><pre><code>void insertSort(int arr[], int begin, int end){    // int length = end - begin + 1;    for (int i = begin + 1; i &lt; end + 1; i++)    {        for (int j = i; j &gt; begin; j--)        {            if (arr[j] &lt; arr[j - 1])            {                swap(&amp;arr[j], &amp;arr[j - 1]);            }else            {                break;            }        }    }}</code></pre><p>插入排序的本质就是排个头，先把第一个固定住，然后看第二个，第二个要是比第一个矮，就swap一下。</p><p>然后看第三个，第三个有没有第二个矮，要是矮，swap，此时第三个变成了第二个，再判断一下它和第一个的关系…………</p><p>循环往复，最后就排序完毕了。</p><hr><h2 id="快速排序-QuickSort-O-nlogn"><a href="#快速排序-QuickSort-O-nlogn" class="headerlink" title="快速排序 QuickSort O(nlogn)"></a>快速排序 QuickSort O(nlogn)</h2><pre><code>void QuickSort(int array[], int low , int high){       if(low&lt;high){    int index = array[low];    int i = low;    int j = high;    while (i&lt;j)    {        while (i&lt;j &amp;&amp; array[j] &gt;= index)        {            j--;        }        if (i&lt;j)        {            swap(&amp;array[i], &amp;array[j]);            i++;        }        while (i&lt;j &amp;&amp; array[i]&lt;index)        {            i++;        }        if(i&lt;j)        {            swap(&amp;array[i], &amp;array[j]);            j--;        }     }    array[i] = index;    QuickSort(array,low,i-1);    QuickSort(array,i+1,high);    }}</code></pre><p>快速排序是我接触的第一个排序算法，也是第一个利用到了分治和递归思想的算法。</p><p>说大白话就是<strong>分堆</strong>，我们先选一个“标准/标杆”(index), 这里我直接选的是第一项，然后我们把所有小于index的元素，都swap到index左边，大于index的元素都swap到右边。这样我们就获得了两堆数。之后对着这两堆数进行递归操作，反复的分堆分堆，分到什么时候呢？分到每个堆只有一个数字了，这也就意味着我们分完了。</p><p>在分堆的过程也是有讲究的，我们从数组的两端向中间移动。</p><pre><code>while (i&lt;j &amp;&amp; array[j] &gt;= index){    j--;}if (i&lt;j) // 这个判断就是防止因为i &gt;= j导致while终止，误操作swap，下面的if也是同理{    swap(&amp;array[i], &amp;array[j]);    i++; // 注意这个i++；}</code></pre><p>上面这段就是从最右端往左走，大的我们就留下，一旦发现小的，我们就直接swap到左边，同时从左边swap一个数字过来。可能你想问，如果我们swap过来的那个数字也小于index，应该放在左边怎么办呢？不急，我们接着往下看。</p><pre><code>while (i&lt;j &amp;&amp; array[i]&lt;index){    i++;}if(i&lt;j){    swap(&amp;array[i], &amp;array[j]);    j--;} </code></pre><p>这段开始我们从左端往右走，和上面的同理，小的我们留下，一旦发现大的，我们直接swap到右边，同时从右边swap一个数字过来。这个疑问又出现了，我们如果swap了一个大于index数字过来怎么办？</p><p>还好，循环会解决这些疑问。</p><p>当你进入下一轮最外层的while循环时，我们首先就会判断上一轮swap过来的**array [ j ]**满不满足我们的需求，如果不满足，果断扔回去。第二个也是同理。</p><p>就这样，不断的把数字扔来扔去，我们就得到了一个排好序的数组。</p><hr><h2 id="并归排序-mergeSort-O-nlogn"><a href="#并归排序-mergeSort-O-nlogn" class="headerlink" title="并归排序 mergeSort O(nlogn)"></a>并归排序 mergeSort O(nlogn)</h2><pre><code>void merge(int arr[], int left, int mid, int right){    int i, j, k;    int l = mid - left + 1;    int r = right - mid;    // 创建两个临时数组 L/R    int *L = (int *)malloc(l * sizeof(int));    int *R = (int *)malloc(r * sizeof(int));    // 把数字放进去    for (i = 0; i &lt; l; i++)    {        L[i] = arr[left + i];    }    for (j = 0; j &lt; r; j++)    {        R[j] = arr[mid + 1 + j];    }    // 开始分吧    i = 0;    j = 0;    k = left; // 众神归位    while (i &lt; l &amp;&amp; j &lt; r)    {        if (L[i] &lt;= R[j])        {            arr[k] = L[i];            i++;        }        else        {            arr[k] = R[j];            j++;        }        k++;    }    // 把剩下的元素处理干净    while (i &lt; l)    {        arr[k] = L[i];        i++;        k++;    }    while (j &lt; r)    {        arr[k] = R[j];        j++;        k++;    }    // free一下，养成好习惯    free(L);    free(R);}void mergeSort(int arr[], int left, int right){    if (left &lt; right) // 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊，不要忘了比较这个啊啊啊啊啊啊啊啊啊啊啊啊啊啊    {        int mid = left + (right - left) / 2;        mergeSort(arr, left, mid);        mergeSort(arr, mid + 1, right);        merge(arr, left, mid, right);    }}</code></pre><p>并归排序的实质，在我理解看来就是局部的有序，然后进行整合。我们通过递归，获得了大量的size为2(或1)的有序的子数组，然后我们选两个，因为在他们内部已经有序了，所以我们比第一个数字的大小，谁大谁放第一个…………就这样，两个有序数组合并成了一个大的有序数组，最终实现了排序。</p><hr><p>先写到这里，未完待续</p><p>Mostly_Harmless</p><p>写于2023.11.20 上午十时</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写点排序算法的笔记：&lt;/p&gt;
&lt;h2 id=&quot;插入排序-InsertionSort-O-n-2&quot;&gt;&lt;a href=&quot;#插入排序-InsertionSort-O-n-2&quot; class=&quot;headerlink&quot; title=&quot;插入排序 InsertionSort O(n^2)&quot;</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>20231117_指针，地址，字符串</title>
    <link href="http://example.com/2023/11/17/20231117-Notes/"/>
    <id>http://example.com/2023/11/17/20231117-Notes/</id>
    <published>2023-11-17T00:19:16.000Z</published>
    <updated>2023-11-17T06:55:47.797Z</updated>
    
    <content type="html"><![CDATA[<p>写一下CS50学习过程中关于指针和地址部分的笔记和心得，其实就是在下面的注释部分，但是还是整理一下。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(void){    int n = 50;    char *s = "HI!";    int *p = &amp;n; // p 是一个 指向int类型变量 的地址 的 整数 8 bytes    // p 用来存储地址    printf("%i\n", n);    printf("%p\n", p); // %p 获取地址 &amp;n    // p 存储 n的位置 OR p 指向 n的位置    printf("%i\n", *p);    // 打印 p所指向的那个东西，De-reference 解引用=    printf("%p\n", s);    printf("%s\n", s);    // %s (String) 不仅仅是打印了个变量值，更是根据你提供的地址找到了TA！    // 这块一定要理解好，printf不需要找到*s,他只需要找到s，也就是这个字符串的第一位(s[0])开始的地方，然后遍历到\0就可以了，所以    // 我们这里没有写 *s，而是直接s。因为*s对应的就是s[0]这么一个单字母了，我们不需要这个    printf("%s\n", s + 1);    // s + 1 就是将起始位置向后移动了一位，于是只会打印出 “I!”    printf("%c %c\n", s[0], *(s + 0));    // %c 打印 *s 的字符 就是相当于s[0]，因为s指向的就是这个字符串起始位置，也就是H所在的位置    printf("%c %c\n", s[1], *(s + 1));    printf("%c %c\n", s[2], *(s + 2));    // 其实类似于 s[i] 的这种 “语法糖” ，在编译时是这样处理的：    // s[i] --&gt; *(s + i)    // 不用在乎数据类型的问题，编译器会自动为你换算    // 所以让我们做点禁忌的事情    // printf("%c\n", *(s + 20000));    // Segmentation fault (core dumped)    // 访问了不该访问的内存    // strcmp 做了个什么事情呢？    // 比如 s, t 是两个strings    // 我们怎么判断他们是否相等？    // i form 1 to n 判断 *(s + i) ?= *(t + i)    // strcmp(s, t) 就是帮你干了这么件事情    // 若是相同的，return 0;    // 若是字典序 s &gt; t, return 1;    // 若是字典序 s &lt; t, return -1;    string m = get_string("m: ");    string t = get_string("t: ");    printf("%p\n", m);    printf("%p\n", t);}</code></pre><p>其实指针部分的主要问题就是C语言对于 * 这个符号的“滥用”。</p><p>1.int *p = &amp;n;<br>此时*的作用是<strong>定义指针</strong>，p 是一个<strong>指向int类型变量的地址</strong>的<strong>整数</strong>，大小为8 bytes。</p><p>p 可以理解为存储了<strong>n的位置</strong>，你知道p，也就能找到n，并且n在内存中的位置是确定的，尽管n的数值会改变，但是这个变量所在的位置是在其被定义的那个时候就确定了。</p><p>2.printf(“%i\n”, *p);<br>此时*的作用就是<strong>De-reference 解引用指针</strong>，寻找到p对应的那个“东西”。</p><hr><p>剩下的就是一些细枝末节的东西，例如：</p><p>%p就是打印p所指向的<strong>地址</strong><br>e.g:printf(“%p\n”, p); 输出的就是0x16b6c710c，也就是n所在的地址。</p><p>对于字符串 (char数组) 而言，printf中的%s，你只需要提供你想要打印的起始位置，printf函数会自动替你完成“<strong>往下走，直到\0</strong>”的步骤。</p><p>e.g:</p><pre><code>char *s = "HI!";printf("%p\n", s); // out:0x16ae1f108printf("%s\n", s); // out:HI! printf("%s\n", s + 1); // out:I!</code></pre><p>我们这里没有写 *s，而是直接写s。因为*s对应的就是s[0]所对应的这么一个单字母(H)了，我们不需要这个，我们需要的是起始位置，也就是起始的地址。</p><p>类似于 s[i] 的这种 “语法糖” ，在编译时是这样处理的：<strong>s[i] –&gt; *(s + i)</strong><br>不用担心，编译器会为你做好一切，这类语法🍬还是很好用的。</p><hr><p>来点<strong>禁忌</strong>的事情</p><p>比如我们写这么一个东西</p><pre><code>printf("%c\n", *(s + 200000));</code></pre><p>我们想访问一下 s后200000位内存存着些什么，但是运行的时候就是**Segmentation fault (core dumped)**，你访问了（我访问了/计算机访问了）不该访问的内存。</p><hr><p>我们再围绕字符串写一点点东西，比如<strong>strings.h</strong>库中的<strong>strcmp</strong>函数，它的实现原理就是：输入s, t两个strings。然后开始判断 *(s + i) ?= *(t + i)，其中i从0到n遍历。</p><p>若是相同的，return 0;<br>若是字典序 s &gt; t, return 1;<br>若是字典序 s &lt; t, return -1;</p><p>Mostly_Harmless</p><p>写于2023.11.16 下午二时</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写一下CS50学习过程中关于指针和地址部分的笔记和心得，其实就是在下面的注释部分，但是还是整理一下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;cs50.h&amp;gt;

int main(void)
{
    </summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>20231011_新创世纪</title>
    <link href="http://example.com/2023/10/11/20231011-%E6%96%B0%E5%88%9B%E4%B8%96%E7%BA%AA/"/>
    <id>http://example.com/2023/10/11/20231011-%E6%96%B0%E5%88%9B%E4%B8%96%E7%BA%AA/</id>
    <published>2023-10-11T11:31:53.000Z</published>
    <updated>2023-10-11T11:33:04.373Z</updated>
    
    <content type="html"><![CDATA[<p>新创世纪</p><p>Hello，World！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;新创世纪&lt;/p&gt;
&lt;p&gt;Hello，World！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
