<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mostly_Harmless的碎碎念</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-16T10:39:03.544Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mostly_Harmless</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS106X_Note1</title>
    <link href="http://example.com/2024/01/16/CS106X-Note1/"/>
    <id>http://example.com/2024/01/16/CS106X-Note1/</id>
    <published>2024-01-16T02:16:21.000Z</published>
    <updated>2024-01-16T10:39:03.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h1><p>C++ 的语法和 Java 是大体相似的<br>（岂不是我学完C++可以速通Java了</p><pre><code class="cpp">using namespace name;</code></pre><p>其中 <code>namespace</code>就是变量的作用域(scope)</p><p>这种写法的好处就是我们可以让各个文件中相同名字的函数名、变量名、类名 <strong>各自独立</strong>。<br>例如我们有很多类似于<code>cout</code>的标识符，如歌你需要用<code>cout</code>来打印你的内容，那就代表着你不能将一个变量命名为cout(这样会导致冲突)</p><p>如果你在两个不同的<code>namespace</code>中使用了相同名称的变量、方法或者类的时候，这都是OK的。</p><p>你在代码开头打上<code>using namespace xxx;</code>，这代表你希望获得<code>xxx</code>中所有东西的命名，以及你希望在程序中可以访问其所有内容。</p><p>例如：<code>cout</code>的全称是<code>std::cout</code>，这代表它是一个位于<code>std namespace</code>的变量。<br>但是我们一遍遍打 <strong>std::</strong> 有些痛苦，加上<code>using namespace std;</code>，就可以不用在<code>cout</code>的前面加上<code>std::</code>了。</p><hr><p><code>cin</code>是一个糟糕的用法</p><p><code>cin&gt;&gt;(int age)</code>是语法错误，无法编译。</p><p>FUCK，Vscode 无法使用StanfordLib，你妈的。</p><p>cin无法判断用户输入的内容是否匹配对应的类型，所以我们不用。</p><p>我们用<code>simpio.h</code>中的<code>getInteger("prompt")</code>,<code>getReal("prompt")</code>,<code>getLine("prompt")</code>,<code>getYesOrNo("prompt")</code>.</p><hr><h1 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h1><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><pre><code class="cpp">double circleArea(double r) {    return 3.14159265359 * r * r;}</code></pre><ol><li><p>可以利用函数指针来将一个函数作为参数传入另一个函数，也就是回调(call back)</p></li><li><p>C++对类型转换较为宽容，类似于<code>Java</code>和<code>Python</code>。例如你传入<code>1</code>到<code>circleArea</code>中，会自动转换为<code>1.0</code></p></li><li><p>C++允许默认参数<code>default parameters</code>，这是C++的一个特性，C不具备。它允许你在函数中声明一个具有默认值的参数。如果在调用函数的时候没有为这个参数提供值，它将会自动使用默认值。</p></li></ol><pre><code class="cpp">void printLine(int width = 10, char letter = '*') {    for (int i = 0; i &lt; width; i++) {        cout &lt;&lt; letter;    }}···printLine(7, '?'); // ???????printLine(5);      // *****printLine();       // **********</code></pre><p>需要注意的一点是：<strong>有默认值的参数必须在参数列表的末尾</strong>，否则函数无法判断你的参数是传递给谁的。我们也不能跳过第一个默认值，去直接给第二个默认值参数传值。默认参数只能<strong>从右至左连续地省略</strong>。</p><ol start="4"><li>一切的函数必须在使用之前就被声明或定义。这一点和C是一致的。如果有大量的函数需要被声明的话，那就可以单独建立一个头文件，然后在main函数的文件头include一下”.h”。<br>所有的默认参数值在开头的声明处写明就好，如果在函数定义处重申一遍默认值，编译器会报错。例如下面：</li></ol><pre><code class="cpp">void song(int times = 5);····void song(int times) {    ·····}</code></pre><ol start="5"><li>数学函数<br><code>#include &lt;cmath&gt;</code><br>以下来自ChatGPT:</li></ol><p><strong>三角函数</strong>:</p><ul><li><code>sin(double x)</code>: 计算角 x（以弧度为单位）的正弦。</li><li><code>cos(double x)</code>: 计算角 x（以弧度为单位）的余弦。</li><li><code>tan(double x)</code>: 计算角 x（以弧度为单位）的正切。</li><li><code>asin(double x)</code>: 计算 x 的反正弦值，结果以弧度为单位。</li><li><code>acos(double x)</code>: 计算 x 的反余弦值，结果以弧度为单位。</li><li><code>atan(double x)</code>: 计算 x 的反正切值，结果以弧度为单位。</li><li><code>atan2(double y, double x)</code>: 计算以点 (x, y) 为坐标的角度，结果以弧度为单位。</li></ul><p><strong>指数和对数函数</strong>:</p><ul><li><code>exp(double x)</code>: 计算 e 的 x 次幂。</li><li><code>log(double x)</code>: 计算 x 的自然对数（基数是 e）。</li><li><code>log10(double x)</code>: 计算 x 的常用对数（基数是 10）。</li><li><code>pow(double base, double exp)</code>: 计算 base 的 exp 次幂。</li></ul><p><strong>平方根和绝对值函数</strong>:</p><ul><li><code>sqrt(double x)</code>: 计算 x 的平方根。</li><li><code>cbrt(double x)</code>: 计算 x 的立方根。</li><li><code>abs(int n)</code> / <code>fabs(double x)</code>: 计算整数或浮点数 x 的绝对值。</li></ul><p><strong>取整函数</strong>:</p><ul><li><code>ceil(double x)</code>: 计算大于或等于 x 的最小整数。</li><li><code>floor(double x)</code>: 计算小于或等于 x 的最大整数。</li><li><code>round(double x)</code>: 返回 x 四舍五入到最接近的整数。</li></ul><p><strong>其他函数</strong>:</p><ul><li><code>fmod(double x, double y)</code>: 返回 x 除以 y 的余数。</li><li><code>hypot(double x, double y)</code>: 计算直角三角形的斜边长度，给定两个边长 x 和 y。</li></ul><ol start="6"><li>值语意(value semantics) / 引用语意(reference semantics)</li></ol><ul><li>值语意：当变量(int, double, char)作为参数传入函数时，只会<strong>复制它们的值</strong>，两者是完全独立的</li><li>引用语意：当较为复杂的对象或者数组作为参数传入函数时，会使用引用语意。两者是关联在一起的</li><li>当然，你可以自己选择语意的类型，例如你写一个<code>swap</code>函数。需要注意的是，这里的<code>int&amp; a, int&amp; b</code>的写法和<strong>指针</strong>是不同的：引用更像给<strong>变量起一个别名</strong>，你使用a, b就和使用x, y是一样的，而不是像是指针一样去访问地址。你也不需要用什么*a, *b之类的去<strong>解引用</strong>。你也就不可以将字面值作为一个引用参数传入函数中去</li></ul><pre><code class="cpp">void swap(int&amp; a, int&amp; b) {   int temp = a;   a = b;   b = temp;}····swap(x, y);</code></pre><ul><li>我们也可以通过引用参数来实现<strong>一次返回多个值</strong>的操作，例如下面：我在<code>datingRange</code>中对min, max做的任何操作，其实都是直接作用在<code>main</code>中的young, old上的。</li></ul><pre><code class="cpp">void datingRange(int age, int&amp; min, int&amp; max) {   min = age / 2 + 7;   max = (age - 7) * 2;}int main() {   int young;   int old;   datingRange(48, young, old);   ·····}</code></pre><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p><code>#include &lt;string&gt;</code> &amp; <code>string s = "hello";</code></p><p>C++中的字符串支持运算符<code>Operators</code>，例如：</p><ul><li>Concatenation串联 +/+=</li></ul><pre><code class="cpp">string s1 = "Mar";s1 += "ty"; // "Marty"</code></pre><ul><li><p>Q1:为什么有了<code>+</code>这种操作，在<code>cout</code>中还要用<code>&lt;&lt;</code>呢？</p></li><li><p>A1:因为串联操作<strong>仅支持string+string/char</strong>，对于int、double等类型无效</p></li><li><p>Compare比较 利用 == != &lt; &lt;= &gt; &gt;= 根据ASCII码大小，注意<strong>大写字母的ASCII码小</strong></p></li></ul><pre><code class="cpp">string s2 = "Cynthia";if (s1 &gt; s2 &amp;&amp; s2 != "Joe") { // true   ···}</code></pre><ul><li><p>operator overloading操作符重载<br>这是一种C++特有的语言特性，你可以<strong>重新定义操作符，让它们能处理不同的数据类型</strong>。Compare这里就用到了这一特性</p></li><li><p>Mutable可变性</p></li></ul><pre><code class="cpp">s1.append(" Stepp");       //"Marty Stepp"s1.erase(3, 2);            //"Mar  Stepp"s1[6] = 'o';               //"Mar  Stopp"</code></pre><ul><li>Q2:<code>append</code>和<code>+=</code>的区别是?</li><li>A2:前者是<strong>直接修改原有的string</strong>，后者是<strong>创建了一个新的string</strong>，相比之下，内存方面会有一些差异。</li></ul><hr><p>下面是一些string内部定义的一些函数：</p><table><thead><tr><th>函数调用</th><th>解释和用法</th></tr></thead><tbody><tr><td><code>s.append(str)</code></td><td>向字符串 <code>s</code> 的末尾追加另一个字符串 <code>str</code>。</td></tr><tr><td><code>s.assign(str)</code></td><td>将字符串 <code>s</code> 的内容替换为字符串 <code>str</code> 的副本。</td></tr><tr><td><code>s.clear()</code></td><td>清除字符串 <code>s</code> 中的所有内容，使其变为空字符串。</td></tr><tr><td><code>s.compare(str)</code></td><td>比较字符串 <code>s</code> 和 <code>str</code>。返回值 &lt; 0 表示 <code>s</code> 小于 <code>str</code>，0 表示两者相等，&gt; 0 表示 <code>s</code> 大于 <code>str</code>。</td></tr><tr><td><code>s.empty()</code></td><td>如果字符串 <code>s</code> 为空返回 <code>true</code>，否则返回 <code>false</code>。</td></tr><tr><td><code>s.erase(pos, len)</code></td><td>从字符串 <code>s</code> 中移除从 <code>pos</code> 位置开始的 <code>len</code> 个字符。</td></tr><tr><td><code>s.find(str, pos)</code></td><td>从字符串 <code>s</code> 中的 <code>pos</code> 位置开始查找子字符串 <code>str</code>。如果找到，返回子字符串的起始位置；否则返回 <code>std::string::npos</code>。</td></tr><tr><td><code>s.rfind(str, pos)</code></td><td>从字符串 <code>s</code> 中的 <code>pos</code> 位置开始回头查找子字符串 <code>str</code>。如果找到，返回子字符串的起始位置；否则返回 <code>std::string::npos</code>。 (pos为空，则默认从末尾开始)</td></tr><tr><td><code>s.length()</code></td><td>返回字符串 <code>s</code> 中的字符数。</td></tr><tr><td><code>s.replace(pos, len, str)</code></td><td>将字符串 <code>s</code> 中从 <code>pos</code> 开始的 <code>len</code> 个字符替换为字符串 <code>str</code>。</td></tr><tr><td><code>s.substr(pos, len)</code></td><td>返回一个新字符串，包含从字符串 <code>s</code> 的 <code>pos</code> 位置开始的 <code>len</code> 个字符。</td></tr><tr><td><code>s.insert(pos, str)</code></td><td>在字符串 <code>s</code> 的 <code>pos</code> 位置插入字符串 <code>str</code>。</td></tr></tbody></table><p>下面是<code>StanfordLib</code>中<code>strlib.h</code>的函数</p><table><thead><tr><th>Function name</th><th>Description</th></tr></thead><tbody><tr><td><code>endswith(str, suffix)</code></td><td>如果字符串以给定的文本结束，则为真</td></tr><tr><td><code>startswith(str, prefix)</code></td><td>如果字符串以给定的文本开始，则为真</td></tr><tr><td><code>integerToString(int)</code></td><td>将整数转换成字符串</td></tr><tr><td><code>realToString(double)</code></td><td>将实数转换成字符串</td></tr><tr><td><code>stringToInteger(str)</code></td><td>将字符串转换成整数</td></tr><tr><td><code>stringToReal(str)</code></td><td>将字符串转换成实数</td></tr><tr><td><code>equalsIgnoreCase(s1, s2)</code></td><td>如果s1和s2有相同的字符，忽略大小写，则为真</td></tr><tr><td><code>toLowerCase(str)</code></td><td>返回字符串的小写版本</td></tr><tr><td><code>toUpperCase(str)</code></td><td>返回字符串的大写版本</td></tr><tr><td><code>trim(str)</code></td><td>返回去除周围空白的字符串</td></tr></tbody></table><hr><p>C++中有两种并行的字符串存储处理方式-C(char arrays)/C++(string objects)</p><p>类似于<code>"Hi there"</code>就是<code>C string</code>，当你打出<code>s1 = "xxx"</code>,其实后台默认做了个转换，将<code>C string</code>转换为了<code>C++ string</code>并存储在<code>s1</code>中。</p><p>一切适用于C++ string的特性都不适用于C string。</p><ul><li>Q3:什么时候会出现Bug呢？</li><li>A3:例如<code>string s2 = "Hi" + "there";</code> 这是一个<code>C-string</code> + <code>C-string</code>,这个bug甚至不会导致编译错误，只是会使你的程序崩溃。因为这里只是在<strong>将地址相加</strong>，并返回一个<strong>不知道在什么地方的地址</strong>。正确的写法应该是**<code>string s2 = string("Hi") + "there";</code>,先将<code>Hi</code>转换为<code>C++-string</code>,再进行处理，就OK了。</li><li>同理，<code>C-string</code> + <code>char/int.....</code>都是不行的</li></ul><h2 id="I-O-Stream"><a href="#I-O-Stream" class="headerlink" title="I/O Stream"></a>I/O Stream</h2><p><code>#include &lt;fstream&gt;</code><br>由于<code>继承</code>的机制，例如：<code>cin</code>-&gt;<code>ifstream</code>,<code>cout</code>-&gt;<code>ofstream</code> </p><p>⬇️<code>ifstream</code></p><table><thead><tr><th>成员函数</th><th>描述</th></tr></thead><tbody><tr><td><code>f.clear();</code></td><td>重置流的错误状态（如果有的话）</td></tr><tr><td><code>f.close();</code></td><td>停止读取文件</td></tr><tr><td><code>f.eof();</code></td><td>如果流已经过了文件末尾（EOF），则返回真</td></tr><tr><td><code>f.fail();</code></td><td>如果最后一次读取调用失败（例如 EOF），则返回真</td></tr><tr><td><code>f.get();</code></td><td>读取并返回一个字符</td></tr><tr><td><code>f.open("filename");</code></td><td>用给定的C字符串打开文件（如果传递了C++字符串，可能需要写 <code>.c_str()</code>）</td></tr><tr><td><code>f.open(s.c_str());</code></td><td>同上</td></tr><tr><td><code>f.unget(ch);</code></td><td>取消读取一个字符</td></tr><tr><td><code>f &gt;&gt; var;</code></td><td>从输入文件读取数据到变量（类似 cin）；一次读取一个由空白分隔的标记</td></tr><tr><td><code>getline(f&amp;, s&amp;);</code></td><td>将输入行读取到字符串，通过引用；返回成功/失败的真/假指示器</td></tr></tbody></table><p><strong>open</strong> a file,<strong>read</strong> each line,<strong>close</strong> it.</p><pre><code class="cpp">// read and print every line of a file#include &lt;fstream&gt;...ifstream input;input.open("poem.txt"); string line;while (getline(intput, line)) {   cout &lt;&lt; line &lt;&lt; endl;}input.close();</code></pre><p>一个常见的错误⬇️</p><pre><code class="cpp">// incorrect (why?)while (!input.fail()) {   string line;   getline(input, line);   cout &lt;&lt; line &lt;&lt; endl;}</code></pre><p>问题点在于：<code>getline</code>读取到文件的末尾时，并不会立刻将<code>input</code>的<code>fail</code>状态设置成<code>true</code>，而是先设置<code>eof</code>，当下一次尝试读取时(即读取一个<code>eof</code>状态的文件，才会将他的<code>fail</code>状态更为<code>true</code>)。这就会产生一个问题：最后一次读取<code>input</code>的时候失败了，没有对<code>line</code>进行任何更改，也就导致<em>最后一行输出了两次</em>，随后才会终止while循环 </p><hr><p><code>#include &lt;sstream&gt;</code></p><p><code>istringstream</code>可以将一整个<code>string</code>读取进来，然后逐个<code>word</code>进行处理</p><pre><code class="cpp">// read specific word tokends from a stringistringstream input("Jenny Smith 8675309");string first, last;int phone;input &gt;&gt; first &gt;&gt; last;input &gt;&gt; phone;cout &lt;&lt; first &lt;&lt; " " &lt;&lt; last &lt;&lt; " " &lt;&lt; phone &lt;&lt; endl;// Jenny Smith 8675309</code></pre><pre><code class="cpp">istringstream input2("To be or not to be");string word; while (input2 &gt;&gt; word) {    cout &lt;&lt; word &lt;&lt; endl;}</code></pre><p><code>ostringstream</code>可以创建一个<code>string</code>的<code>buffer</code>缓冲区，将你的输出存储起来。最后使用<code>str</code>来读取其内容。</p><pre><code class="cpp">ostringstream output;int age = 42, iq = 79;output &lt;&lt; "My age is " &lt;&lt; age &lt;&lt; endl;output &lt;&lt; "and my IQ is " &lt;&lt; iq &lt;&lt; endl;string result = output.str();cout &lt;&lt; result &lt;&lt; endl;// My age is 42\nand my IQ is 79\n</code></pre><p><code>StanfordLib</code>-<code>filelib.h</code></p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>createDirectory(name);</code></td><td>用给定的名称创建一个新目录</td></tr><tr><td><code>deleteFile(name);</code></td><td>从磁盘中删除一个文件</td></tr><tr><td><code>fileExists(name)</code></td><td>如果给定的文件在磁盘上存在，则返回真</td></tr><tr><td><code>getCurrentDirectory()</code></td><td>返回C++程序目录的字符串形式</td></tr><tr><td><code>isDirectory(name), isFile(name)</code></td><td>基于文件路径的类型返回真</td></tr><tr><td><code>openFile(ifstream&amp;, name);</code></td><td>方便地使用C++字符串打开文件</td></tr><tr><td><code>promptUserForFile(ifstream&amp;, prompt)</code></td><td>重复提示用户输入现有文件的名称</td></tr><tr><td><code>readEntireFile(ifstream&amp;, Lines&amp;);</code></td><td>将文件数据读入到行的集合中</td></tr><tr><td><code>renameFile(oldname, newname);</code></td><td>更改文件的名称</td></tr></tbody></table><hr><h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><p><code>#include "grid.h"</code><br>一种<code>collection</code>容器-&gt;<strong>存储数据的数据结构</strong>，数据的独立片段则被称为<strong>elements</strong>元素。</p><p><code>Grid</code>是二维数组,**一定要标明元素的数据类型。默认值是0/false(bool)</p><p>需要强调的一点是：<strong>当你想把一个<code>Grid</code>作为参数传入到函数当中去的时候，<code>Copying</code>是很慢的，严重拖慢效率，直接reference(&amp;)引用传递就好</strong></p><p>还需要强调的一点是：<strong>当你不希望你传入的<code>Grid</code>被修改时，请善用<code>const</code></strong></p><pre><code class="cpp">// constructing a GridGrid&lt;int&gt; matrix(3, 4);martix[0][0] = 75;...// or specify elements in {}Grid&lt;int&gt; matrix = {   {75,24,3,3},   {23,4,5,4},   {1,2,1,1}};</code></pre><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Grid&lt;type&gt; name(r, c);</code></td><td>创建一个给定行数/列数的网格；如果省略，则创建一个空的0x0网格</td></tr><tr><td><code>g[r][c];</code></td><td>返回给定行/列的值</td></tr><tr><td><code>g.fill(value);</code></td><td>设置每个格子为给定的值</td></tr><tr><td><code>g.inBounds(r, c)</code></td><td>如果给定位置在网格内，则返回真</td></tr><tr><td><code>g.numCols()</code> 或 <code>g.width()</code></td><td>返回列数</td></tr><tr><td><code>g.numRows()</code> 或 <code>g.height()</code></td><td>返回行数</td></tr><tr><td><code>g.resize(nRows, nCols);</code></td><td>将网格调整为新的大小，并丢弃旧内容</td></tr><tr><td><code>g[r][c] = value;</code> 或 <code>g.set(r, c, value);</code></td><td>在给定行/列存储值</td></tr><tr><td><code>g.toString()</code></td><td>返回网格的字符串表示形式，例如 <code>"{{3, 42}, {-7, 1}, {5, 19}}"</code></td></tr><tr><td><code>ostr &lt;&lt; g</code></td><td>打印网格，例如 <code>{{3, 42}, {-7, 1}, {5, 19}}</code></td></tr></tbody></table><hr><h1 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h1><h2 id="Vector-aka-list"><a href="#Vector-aka-list" class="headerlink" title="Vector(aka list)"></a>Vector(aka list)</h2><p><code>#include "vector.h"</code></p><p>依旧是一个<code>collection</code> 容器，负责<strong>从0开始索引存储内容</strong>，一个可以<strong>动态调整大小</strong>的数组。</p><pre><code class="cpp">// initialize a vector containing 5 integers//          index 0  1  2  3  4Vector&lt;int&gt; nums {1, 2, 3, 4, 5} //不需要加"="Vector&lt;string&gt; names;names.add("Tom");       //{"Tom"}names.add("Jay");       //{"Tom", "Jay"}names.insert(0, "Liu")  //{"Liu", "Tom", "Jay"}</code></pre><ul><li>Q4: 为什么不用<code>Arrays</code>?</li><li>A4: 1. Arrays有着固定的大小，且很难更改其大小。  2. 无法判断访问是否越界，是否会访问到垃圾内存上。  3.没有那些实用的函数</li></ul><p>一些常用的函数如下⬇️</p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>v.add(value);</code> 或 <code>v += value;</code> 或 <code>v += v1, v2, ..., vN;</code></td><td>在向量末尾添加一个或多个值</td></tr><tr><td><code>v.clear();</code></td><td>移除所有元素</td></tr><tr><td><code>v[i]</code> 或 <code>v.get(i);</code></td><td>返回给定索引处的值</td></tr><tr><td><code>v.insert(i, value);</code></td><td>在给定索引之前插入值，并将后续的值向右移动</td></tr><tr><td><code>v.isEmpty();</code></td><td>如果向量不包含任何元素，则返回真</td></tr><tr><td><code>v.remove(i);</code></td><td>移除/返回给定索引处的值，并将后续的值向左移动</td></tr><tr><td><code>v[i] = value;</code> 或 <code>v.set(i, value);</code></td><td>在给定索引处替换值</td></tr><tr><td><code>v.subList(start, length);</code></td><td>返回索引子范围的新向量</td></tr><tr><td><code>v.size();</code></td><td>返回向量中元素的数量</td></tr><tr><td><code>v.toString();</code></td><td>返回向量的字符串表示形式，例 如 <code>"{{3, 42, -7, 15}}"</code></td></tr><tr><td><code>ostr &lt;&lt; v;</code></td><td>打印向量中的元素</td></tr></tbody></table><p>C++在<code>c++17</code>后开始有了<strong>模板推断</strong>的特性，也就是你在<code>&lt;&gt;</code>输入为空的话，编译器会<strong>自行判断数据类型</strong></p><p>下面是一个小练习，写一个函数，目的是删除整个<code>vector</code>里所有的<code>string s</code></p><pre><code class="cpp">void removeAll(Vector&lt;string&gt;&amp; v, string s) {   for (int i = v.size() - 1; i &gt;= 0; i--) {      if (v[i] == s) {         v.remove(i);      }   }}</code></pre><ul><li><strong>注意⚠️！！</strong> <strong>是<code>Vector</code>,V要大写</strong></li></ul><h3 id="Vector-insert"><a href="#Vector-insert" class="headerlink" title="Vector insert"></a>Vector insert</h3><p><code>Vector</code>内部是用<code>Arrays</code>来实现的，那么是如何实现动态容量的呢？</p><p>由于<code>Arrays</code>本身并没有调整大小的功能，所以size总会比我们实际所需的大一些。例如我们创建了一个包含<code>6个int的Vector</code>，那么他的实际大小可能是10/20/30… 但是<strong>这个实际大小确实是固定的</strong>，当我们所需的大小超过了目前的实际大小，那么就会<strong>重新创建</strong>一个实际大小更大的<code>Arrays</code>，<strong>并把原来的数据Copy过去</strong></p><hr><h2 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h2><p>一种通过代码来判断计算机资源使用情况的方法：通常与<strong>速度(运行时间)/内存(占用空间)<strong>有关，大多数都是</strong>参考运行时间</strong></p><p>为了方便评估，我们有如下假设：</p><ul><li>A single statement’s runtime = 1</li><li>A function call’s runtime = (sum of runtime of statements in function’s body)</li><li>A loop of N iterations   ‘ runtime = (N * (loop body’s runtime))</li></ul><p>下面是一个例子：⬇️</p><pre><code class="cpp">statement1;                // runtime = 1for (int i = 1; i &lt;= N; i++) {      // runtime = N^2    for (int j = 1; j &lt;= N; j++) {  // runtime = N        statement2;    }}for (int i = 1; i &lt;= N; i++) {      // runtime = 3N    statement3;    statement4;    statement5;}// total = N^2 + 3N + 1</code></pre><p>通常来说我们只关心<strong>影响运行时间的最大因素</strong>，并将<strong>表达式中的参数都忽略掉</strong>。例如上面👆这个例子我们就可以用O(N^2)来概括</p><hr><h1 id="Part4"><a href="#Part4" class="headerlink" title="Part4"></a>Part4</h1><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><code>#include "list.h"</code><br><code>LinkedList</code>提供了和<code>Vector</code>几乎一样的函数。</p><pre><code class="cpp">LinkedList&lt;int&gt; list; // 要声明元素存储类型for (int i = 1; i &lt;= 8; i++) {   list.add(10 * i); // {10, 20, 30, 40, 50, 60, 70, 80}}</code></pre><p>一个笑话：计算机科学家讨厌三件东西,redundancy(冗余),inefficiency(低效)和redundancy(冗余)</p><ul><li>Q5:为什么要在已经有<code>Vector</code>的情况下，还要在设计一个几乎相同的collection <code>LinkedList</code>呢？</li><li>A5:因为两者内部是不同的实现方式，前者是<code>Arrays</code>，后者是<code>Nodes</code></li></ul><hr><h2 id="Abstract-data-types-ADTs"><a href="#Abstract-data-types-ADTs" class="headerlink" title="Abstract data types (ADTs)"></a>Abstract data types (ADTs)</h2><p>一类<strong>数据类型和操作方法</strong>的集合，主要关注<strong>这个集合能做什么</strong>，而不是<strong>它如何做什么</strong></p><p>我们可以将<code>Vector</code>和<code>LinkedList</code>都归类为<code>list</code>.其他的一些ADTs还有：<code>stack, queue, set, map, graph</code></p><h2 id="Stacks-and-queues"><a href="#Stacks-and-queues" class="headerlink" title="Stacks and queues"></a>Stacks and queues</h2><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240116/1705372931222.webp" alt="1705372931222"></p><h3 id="Stacks"><a href="#Stacks" class="headerlink" title="Stacks"></a>Stacks</h3><p><code>#include "stack.h"</code></p><ul><li>Add/remove from “top” only. Last-In, First-Out (LIFO)</li><li>元素按照插入的顺序进行存储。我们认为他们没有序号(index)</li><li>只能对最上面的(最后一个插入的)元素进行操作(add/remove/examine)</li><li>基础的一些操作⬇️</li><li><strong>push</strong>: Add an element to the top.</li><li><strong>pop</strong>:  Remove the top element.</li><li><strong>peek</strong>: Examine the top element.</li></ul><table><thead><tr><th>方法</th><th>时间复杂度</th><th>描述</th></tr></thead><tbody><tr><td><code>s.isEmpty()</code></td><td>O(1)</td><td>如果栈没有元素则返回真</td></tr><tr><td><code>s.peek()</code></td><td>O(1)</td><td>返回栈顶元素但不移除它；如果栈为空则抛出错误</td></tr><tr><td><code>s.pop()</code></td><td>O(1)</td><td>移除并返回栈顶元素；如果栈为空则抛出错误</td></tr><tr><td><code>s.push(value);</code></td><td>O(1)</td><td>将给定值放到栈顶</td></tr><tr><td><code>s.size()</code></td><td>O(1)</td><td>返回栈中元素的数量</td></tr></tbody></table><pre><code class="cpp">Stack&lt;int&gt; s;              // {}s.push(42);                // {42}s.push(-3);                // {42, -3}s.push(17);                // {42, -3, 17}cout &lt;&lt; s.pop() &lt;&lt; endl;   // 17  (s is {42, -3})cout &lt;&lt; s.peek() &lt;&lt; endl;  // -3  (s is {42, -3})cout &lt;&lt; s.pop() &lt;&lt; endl;   // -3  (s is {42})</code></pre><p><code>Stack</code>内部是通过<code>Arrays</code>或者<code>Vector</code>实现的</p><ul><li>“bottom” = index 0</li><li>“top”    = index (size - 1)   (便于进行操作)</li></ul><p>当然，你也可以用<code>LinkedList</code>来实现</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><code>#include "queue.h"</code></p><ul><li>Add to “back” only; remove from “front” only. First-In, First-Out(FIFO)</li><li>元素按照按照插入顺序进行存储，没有index</li><li>只能在队尾<code>add</code>，在前面<code>examine/remove</code></li><li>基础的一些操作⬇️</li><li><strong>enqueue</strong>: Add an element to the back.</li><li><strong>dequeue</strong>: Remove the front element.</li><li><strong>peek</strong>:    Examine the front element.</li></ul><table><thead><tr><th>方法</th><th>时间复杂度</th><th>描述</th></tr></thead><tbody><tr><td><code>q.dequeue()</code></td><td>O(1)</td><td>移除并返回队列前端的值；如果队列为空则抛出错误</td></tr><tr><td><code>q.enqueue(value);</code></td><td>O(1)</td><td>在队列后端放置给定的值</td></tr><tr><td><code>q.isEmpty()</code></td><td>O(1)</td><td>如果队列没有元素则返回真</td></tr><tr><td><code>q.peek()</code></td><td>O(1)</td><td>返回队列前端的值但不移除；如果队列为空则抛出错误</td></tr><tr><td><code>q.size()</code></td><td>O(1)</td><td>返回队列中元素的数量</td></tr></tbody></table><p>和<code>Stacks</code>一样，必须将<strong>所有的元素出列</strong>才可以遍历它们。</p><pre><code class="cpp">// process (and destory) an entire queuewhile (!q.isEmpty()) {   do something with q.dequeue();}</code></pre><p>Another version:</p><pre><code class="cpp">int size = q.size(); // 要注意，queue是FIFO，这一套操作下来，其实整体是没有改变的，先出来，再塞到末尾。这种方式不会丢失内容for (int i = 0; i &lt; size; i++) {   do something with q.dequeue();   (including possibly re-adding it to the queue)}</code></pre><pre><code class="cpp">void mirror (Queue&lt;string&gt;&amp; p) {    Stack&lt;string&gt; s;    int size = p.size();    string tmp;    for (int i = 0; i &lt; size; i++) {        tmp = p.dequeue();        s.push(tmp);        p.enqueue(tmp);    }    for (int i = 0; i &lt; size; i++) {        p.enqueue(s.pop());    }}</code></pre><hr><p>P16</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Part1&quot;&gt;&lt;a href=&quot;#Part1&quot; class=&quot;headerlink&quot; title=&quot;Part1&quot;&gt;&lt;/a&gt;Part1&lt;/h1&gt;&lt;p&gt;C++ 的语法和 Java 是大体相似的&lt;br&gt;（岂不是我学完C++可以速通Java了&lt;/p&gt;
&lt;pre&gt;&lt;code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>20231231_信</title>
    <link href="http://example.com/2023/12/31/20231231-%E4%BF%A1/"/>
    <id>http://example.com/2023/12/31/20231231-%E4%BF%A1/</id>
    <published>2023-12-31T14:18:58.000Z</published>
    <updated>2023-12-31T15:36:42.046Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7eb7b5782f85d600b5cc129e0b73046edfa0f06f9d5abde0e6f6d64714073fc7">98c6ec152bf6953f1fca972fa992a23e63d9c9469c76045fa7081e36a3d877c5e86782397c141d0cf180fb9c84b5b09176ea0085f23cda2a9f8545c17ed8ff0d31a19cdd561f61554de358feb09f62532dd0ea3658d3eddf60e9b9bf381d7d8f79114e733b956bf0055707a37542a4122738ee76b3985c49f5dafb9cb3b9072a454d2905cfca2923e3ad3eba1fc80b5d516e0c39e69a970c9a9e437ae7f24899e2857be53fd9fab8cdd303d7f4d0a1e4eebb195d9f3f80a514cbfb34a766618377fe18a568406d55fb83b4f784245b82180dfda4db25f6f8ba2ae3cb0030a4c2896b873e5d0e95adb2dfad42e4b83f41694ad8e9d418531b3c15e0d2db3b61df1369ffe22ac1fe336bfb318ccad2a63fc0bbebe3b7c458d18743fa8fad1fc61e2b2f46c4d1069ce16d8554b2742011b7d7bb4ad98634f725415bd48e80e54ca63201a1576d8d72da487b2d394aeeb909ad6528a14418dd9f91899e7082d1ab1a33a16fb1991876eb1ecffbcb6450543910a3d8b2b867b463712ebba1325cbe1c9db1c123c8d617ae5fa363617c2b7acdc1a336267d6518d9c0a0a0a0ddfee7dd2090c2e9145a22da71cbfb739624f8add814a2f77e5c7a14ecbe79c30a73e89983fc1cf2890de5be0f0680502dcdc9660b4c0828668b87bfbac9c52c61ebb460f0c0e48a97a86283f7cdb9baa2aa127643e66cfd06accf82ebeeb30c9045626e7cb91279fedf9fe5e38330d5ee55e0e3fce8916beaa8ff15cbe94e1deedd6af2ecefa1d31f5a5fedd70dc8048f0749a0d7789fbada6936925cfdb3612aa2691f2b267445b0797f5aede5156e78c3496533bf65377dd790b7cab244bab0987c2ae52ccd8a9d1769a665edfc62600b364504807e1cda5095c0c7063805f38c534f3af3cd4e2f5b7f026afce04cc03c3cbac9b7d355194e95228a79f2a2023ca7dc43f787a7d5d065f941d1be719a78af7ca9e8e2292f25b7983ccdafae30f4d257cc93bcb3a4bb8483c099d8f4aa38e97c5b0240d23a6314a271a4331392add2d12c8373574c560847c835d8c7a85e1c53ee76673dfde6c95063490a08a248e4d779fa99f300490fab9267aff818a1d161e910408e0f373118f1ef60c602b762ef9eb227f18e04d595bbd674a05530ffd76996e850e7d6c8f3461c4371fbda2a2cac0537c92690cb4f25bee65ca71314b777816063c79ddf79858ace5c72e2702389fa2af97c4341cca7f7278b96f3f9cf1db0f9e11b30d9f20c4c2c7face0cf571a2f9b27d38a513a4ae94978b371d9a2b4cd59643ba7b969657a69f053bd9d54960a9e792f668f89fde33ca66334570c0c9c4c0c0e8610a80072c2df761f76f339851d7b66737531063bdb6f62c608b44311fa119356d27226be3f2c536832fb1ac57205e008380dff56f7e88e5d9321ca6e6c31df14bdd6b3ebfa05732293a77a61b21268dc4650780af415b1641c3961c6c9c0c4acfb61c30410732f88a4481dd70d2594c329d723066cf38c215511f25dec19a317708b4ab6698a370b857096fd7b3367cd49026c43b13b464524a825a840cf17911e39a5bea7246bb7559b01fc92f53cbe8c9990dea76b85b6f47077eaffa5e9708e3be4a9f78101a3b055e46012c525b7bdef02a0bc442dcbb752080df98db2ad1bd88745594ffb125b4d19ee0c8de928f77eb05f48e7064194857e44eac0c9ef1cf5eb3b0254bc7f42f857921d6ad3497be3c5b57f08565e40b023720cd1886898669f43caf1233e39eb673290ab6943ef27d593be6f49d8e5d19f83044970f68bfa736574f4dd99e136da0a61f841760fa2b324cb699a7b023f0d360d70222896451585565a4747557495af44c4e822a035b8090a0c4236054c3131e33ad009fc50743c0e3f0d5082c063d604d5949716434e975ded50f9cf3486920320cae2c0dcab35ff38bb9d1d0febe18fd998efc8ed76d9825aefa17552aec45b1868d7180400ea2e89e5c4965426b55a172d21423567cdbe29a0b4cb0b800a9b41bc8cb5757a7793d4002fac7b916a5e43b14a1644ae866efe7bd9c414175da6c5ce7dcc9042c2161f0decdc77d103a56df139c21cb2b17fdc783dd8cd0a55eac80cecc9f7898ec6e30ed0ddae2a2dc6478f5f2e8ca6d816fa7c9f2484bec6befb6f337149f54c5442f49c2f57ce8c804f401af9431fa6e65d6e53aeade068cd4e86d5308de791a488398411db502fb96a7ca26bef8cc3c6af82d54cc69143e3f7d244e1d85d51b877fae681f3f436a3532a03f5e01274fbd58a4467ed805af75cf8c9bcce40093029d5673ff1e3649a7681196c259bf2d50aab10a75731fea9d0c99814d3b854f60bd2ccb558ff76ad87ec1b1e0ce4d85663d1c1377cc5e4730d4910f6351700e988ec9ae6634664b56ef42df4432da8f9727eed34af12b365c7319406ce51cba9b92d01775e859bc58674b3451190dff1fca32a0acb053d58e6403fdf78126802d20c04242b75f3e5288dec352d67dd647b9267cc94b3058fc06530b88d57d19a4b8e89c516d0ea7b2f0cfea5fa02bd8ef784dfbdee4f2faed9370746258cae7adbacefe4b9d499500259f352b2081995c7bcc51680ff94a21e02c238102d7f1b016d4a60ef927bdf89557cbadbecb881c283792d48bfd4edad4eeacb9aecbb45ef92442d114e4646f51c89303812cea17ad8a1085f26e5124008e5bec2de003c5079e24eefdc4f36d8212ad955e10bcfc811a68dc26e81e0ce9b01880d5ad028a3d4d5f5cacfb86721b189126d3dfe70a1d47d144694492826e75d337746a4b73c3a3ac24189ed10b05db63920c60e29aba72be332330940b29d3f2f0873a232266df6e0185968afe59f4b8989ef34b17c434890931fe58ca87e564c7b97f3ae5565cbbbdc57d2a614cd3b5ce288127ac99890f48a5394e3eaa84caff010f268e179811e2e325503aac610f55a0ab83fd809d6bc51d7ad9b7d2506dd2f27ea918945ceff5188935e1bc88db9162b00af2f95f23dd757a6f0381efe63007962943a4f44b31a876d0c2d33a318286049b40db8e1ffcbe7cfb1fcca1e57d7dbdb3f61c79f29be8529f1437a0bd5bedfa2b2a964eb603f92753b48c075116c78d7e35fefc8941424173ecbff19d1e17727bd87f25be332ee15867431cac25566f58855f2d41b3184b8a712572c7de8bc4339eabc7f6daea5561b7a95debb7e8e3629755ad689d48a6489b278ccf31eec59051473e15026b2698cd78cf0042e50f119c512d427ad69c5ddf38631ce917fb9196cc1e6592bae2229f8bae95930cb292ebbb7743b03b5fd065296a14eb7bc948f3f7acb6bc3947c3797320a079d75c0447f9fdf04a962b7ddef14bb68b93ee146b01b85c88a1b4354600fc5ed62d7ef8480ba8acb37138392f838907b8fa0e4b42a1093be8ad967db77a7824ce0b80b6ed49dafc943089c1bf79add6080f2842b0d204ec48da97aed85406b1b052f270f2be843eb84cfb01e13c6c77c63e36b93d433da6f9647748cc5c480cbc7aced67939630d3d3310e8f5e4772449e09af3a9cf90abfa183807268d6a90eb282d8ab8385b7b8c0bdf7db636531f2682a1d338d6790c2a80fa8b222fa961eecf2cf17bb013ff23d32a4caa2fbf436d5d209f114770f7ab06db078e81a2caf52619b0eda2168f882b58e88c919b2f452c482f2e9646b28356166e08c33693a226b3ded48e9124fc0bb7072cac1d21e9c2e6d054c8f8306ef7a4b2881a0b2b38b9aa485ebc5569a84cf1806019c3663ee7eeae45f7392e41e42b616995fb499ba399f6fcda2f2da929c8f377d96f3215377cd7eb889b1e508c79188e2d1e249e7dba10b2b46116a1a6f771bb30fda8afc6e21faa982bec6a63ace23440c2320faa5bbb7c04b3fcea7d6d7e118d547e49830e3bfcce4e622f96fd8ec291e61547cb0637f6b98481a12d8574f70129e4c9e8a6fe74a203fdba6811ca675737066d4a4d8a973ad4b93117b9d503df0a356345ea59fa1ad145018ac52f838a0e40667fd0421a3227270b82edba67507decf3905fc7608b5d3d276f7fe3d823c0c317d90a1ea0999d0b9e794e6bcefbe62508ffee289abb5e6066e996eb8ea46d523fd0e51d09c666ddaa9f49a07adb0dbff8a93f520a692b2b083ee1b1bd7229908a6b1fc4bd6590cde45aa72b1cc30cb24f0f44306a4f8ef63f9b45775ac14394165df0805fb209b66a960df38ca5905e89e188e0615c21c38d2e4fc6fa3ee69ea240a0d2c8a4665bbe1c4f15b7278ea7020775f05a8b9a8b22697a325a92634d85bb34671179ff54875c8d7859d56389ea5bfd80fc0dbe5269347a96b94eb9c9c4eb4225944accb36c834931ef5309fc0ef6862d96fb1d92d5e954a95d4b3f273b067b233f04e940409209fc7b402f721af9caa4b672d428745970b34692c288e7f077f28e75659b54e47cbc8f92e49949276313533676c46f36e6a1f6136a234c798d09674c3790d2880070fdf3063e1e659770840990ec4359d34f7af8ce3190d97c85b2b9278e42ec2f52a66879a588282f4c2458e290c84b60df7ba8ff7acd6902ebdea8c11ee5567bfbfb1cfdc4c0f20f36e42e7f6d86ac3c2aca02ff94221b617ce439af5dd13a54e846257e5d045306ee9dc287eb885209511d3562e45569deeed718f7da44a2da7e826c412c38951af98510213985be0a553f4be8d55b9b704d6aaddd5fa74378d9cba11138f3fd4939ca1c727d01c591a6d7f62e6b97be59ad8357a5568662ae1e638af6c56e3569acbafe8b7f7fdb2250ef442e7d54a63f2740086d74cec826dbb0703244fbda67125511311c1eb07ba89dac303f4d891f6400fefe79b505cc439b1a80a047d74ac110caa18f549314c165217806cf18274e6e49fa2117f67f5ec90d40bf31ed12c89fdef1fa7486f5a2e414d3f42072cdbf7cf358b96810bb6c73bb17e362921a72ae0f819142e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输个密码吧</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="信" scheme="http://example.com/tags/%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>20231229_期末，寒假，以及下学期</title>
    <link href="http://example.com/2023/12/29/20231229-%E6%9C%9F%E6%9C%AB%EF%BC%8C%E5%AF%92%E5%81%87%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8B%E5%AD%A6%E6%9C%9F/"/>
    <id>http://example.com/2023/12/29/20231229-%E6%9C%9F%E6%9C%AB%EF%BC%8C%E5%AF%92%E5%81%87%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8B%E5%AD%A6%E6%9C%9F/</id>
    <published>2023-12-29T15:10:23.000Z</published>
    <updated>2023-12-29T16:19:36.962Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=394648&amp;auto=0&amp;height=66"></iframe><p>上次写这种类型的博客还是10月24日，那是期中考试之后，成绩刚出来。当时看到成绩单，下定决心，痛定思痛，捋顺了一下思路，把各科的问题以及对应的解决思路记录了下来，并列了下TO-DO List。</p><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/Blog_Pic@master/20231229/%E6%88%AA%E5%B1%8F2023-12-29-23.29.26.4by500q3g5z4.webp" alt="TODOLIST"></p><p>目前看来，完成率还可以。下半学期基本可以说是拉足马力了，呆在正心的时间已经比呆在宿舍的时间要长了。期末的四门考试课：淑芬、近代史、程序设计、线代。只剩下<code>线代(1月4日)</code>一科了，应该问题不大，该练习的都练习到了，最近几天再把一些基本的知识点和方法看一看，把往年题的错题和一百题看一看。</p><p>这学期的学分绩还没有完全出来，只出来了<code>淑芬</code>一科——89(194/624)。其实是很不尽如人意的，但是没办法，期中扣分太多，期末无力回天😂感觉最后的学分绩排名能在150+就很不错了，等到最终的绩点出来再来Update一下吧。</p><hr><p>其实这篇文章的主要内容是即将到来的寒假的计划。目前我想了这么几件事，也算是接下来的TO-DO List吧</p><ul><li><input disabled="" type="checkbox"> 淑芬下先修</li><li><input disabled="" type="checkbox"> 大雾自学(由于大雾只有大二上，后半Part才有先修)</li><li><input disabled="" type="checkbox"> CS106X(计算机冲冲冲！)</li><li><input disabled="" type="checkbox"> 概率论与数理统计</li></ul><p>怎么说呢，感觉回到了中学那会儿的<strong>抢先抓早</strong>的打法。这四个TO-DO的Deadline还未定，不想齐头并进，还是突击来的比较爽快和高效一些。但是像<code>CS106X</code>这种课又没办法突击，让我再想想吧。</p><p>寒假还需要把体重和身体调理一下，这12月的后20天真的有些难顶，无奈了。</p><p>先写到这里吧，未完待续。</p><p>Mostly_Harmless</p><p>写于2023.12.30 凌晨0时20分 A02.2108的一张床上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;amp</summary>
      
    
    
    
    
    <category term="计划, 总结" scheme="http://example.com/tags/%E8%AE%A1%E5%88%92-%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>20231128_CS50_Data Stucture</title>
    <link href="http://example.com/2023/11/28/20231128-CS50_Data%20Stucture/"/>
    <id>http://example.com/2023/11/28/20231128-CS50_Data%20Stucture/</id>
    <published>2023-11-28T06:20:58.000Z</published>
    <updated>2023-11-28T08:21:52.756Z</updated>
    
    <content type="html"><![CDATA[<p>这应该是<code>CS50</code>笔记的最后一弹了，其C语言部分的最后一个lecture也是有关于<code>Data structure</code>的，今天写这些就当作复习了。</p><hr><h2 id="链表-LIST"><a href="#链表-LIST" class="headerlink" title="链表 LIST"></a>链表 LIST</h2><pre><code class="c">typedef struct node{    int number;    struct node *next;} node;</code></pre><p>This is the basic stucture of LIST. Every node has a part which contains data, and a pointer which stores the address of the next node. So that these node can be linked together one by one, forming a chain.</p><p>Let’s discuss  th below code from Malan.</p><pre><code class="c">int main(int argc, char *argv[]) // 加入命令行参数{    node *list = NULL; // 定义了一个空链表，即元素数量为0的链表    for (int i = 1; i &lt; argc; i++) // argv的第一个值是 程序的名称    {        int number = atoi(argv[i]); // atoi 将ASCII码转换为整数，只要你输入的是数字        node *n = malloc(sizeof(node));        if (n == NULL)        {            return 1;        }        n-&gt;number = number;        n-&gt;next = NULL;        n-&gt;next = list;        list = n;    }    // node *ptr = list;    // while (ptr != NULL)    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next) // 和上面的两行是等价的    {        printf("%i\n", ptr-&gt;number);    }    // 开始释放    node *ptr = list; // 回到开头    while (ptr != NULL)    {        node *next = ptr-&gt;next;        free(ptr);        ptr = next;    }    return 0;}</code></pre><p>This small program can create a LIST with numbers based on the input of the commandline arguments, and print them from front to back. After performing these operations, the memory can be freed all.</p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/WechatIMG406.5xrdesyyi2gw.webp" alt="WechatIMG406"></p><p>This photo shows that <code>HOW TO INSERT A NODE INTO A LIST</code>.</p><hr><p>Generally, if we want to read a LIST, we need a temporary pointer(like <code>ptr</code>)to traverse the entire chain, until it reaches the node we need.</p><pre><code class="c">// node *ptr = list;// while (ptr != NULL)    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next) // 和上面的两行是等价的    {        printf("%i\n", ptr-&gt;number);    }</code></pre><p><code>node *ptr = list</code> is to create a temporary pointer<code>ptr</code>.<br><code>ptr != NULL</code> serves as a limitation, preventing access to prohibited memory or handling cases where the memory allocated for ptr was not available during its creation.<br><code>ptr = ptr-&gt;next</code> enables us to obtain the next node in the sequence after the current one.</p><hr><p>A very important thing is the freeing of the linked list. This process relies on the temp pointer, but it also involves another pointer, <code>next</code>. Nodes are deleted from the front to the back one by one.</p><pre><code class="c">    node *ptr = list; // 回到开头    while (ptr != NULL)    {        node *next = ptr-&gt;next; // 先get下一个node        free(ptr);        ptr = next;    }</code></pre><hr><p><strong>Pros:</strong></p><ol><li>Dynamic Memory Allocation: We don’t need a complete memory space; instead, the structure allows us to adjust the amount of data by creating or deleting nodes. Knowing the total number of data elements in advance is unnecessary, and there is no pre-allocation of space.</li><li>Efficient Insertion and Deletion: Due to the pointer relationships between nodes, inserting and deleting nodes in a linked list is more efficient than in arrays. The adjustment mostly relies on changing the pointer.</li><li>Minor Impact: When you change a node, the only nodes on either side of it will be impacted.</li></ol><p><strong>Cons:</strong></p><ol><li>Memory Overhead/Extra Storage for Pointers: Each node in a linked list contains both data and a pointer to the next node. This additional overhead consumes more memory compared to arrays, where only the data needs to be stored.</li><li>Sequential Access: Unlike arrays, linked lists don’t provide constant-time access to individual elements. To access an element, you must start from the head (or another known node) and traverse the whole list sequentially. This makes random access time, especially for a large list.</li></ol><p><code>Doubly-Linked Lists</code> has a more pointer to contain the address of the previous node.</p><h2 id="Trees-🌲"><a href="#Trees-🌲" class="headerlink" title="Trees 🌲"></a>Trees 🌲</h2><p>The stucture of a tree contains many nodes, and every node has three parts<code>*left</code> <code>*right</code> <code>data</code>.</p><p><strong>Similarities:</strong></p><ol><li>Nodes.</li><li>Pointers.</li></ol><p><strong>Differences:</strong></p><ol><li>Hierarchical Structure: A tree is <strong>a hierarchical data structure</strong>, comprising a root node, internal nodes, and leaf nodes. The connections between nodes form a tree-like structure. In contrast, a linked list is <strong>a linear structure</strong>, where nodes have only predecessors and successors, creating a linear sequence.</li><li>Node Relationships: In a linked list, each node usually has <strong>a single successor</strong>. In a tree, nodes can have <strong>multiple child nodes</strong>, establishing parent-child relationships. A node’s parent is the node directly above it, and its children are the nodes directly below.</li><li>Traversal Patterns: Linked lists are typically traversed <strong>linearly</strong>, from the head to the tail or vice versa. Trees can be traversed <strong>in various ways</strong>, such as pre-order, in-order, and post-order traversals.</li></ol><p><strong>Binary search trees are another data structure that can be used to store data more efficiently such that it can be searched and retrieved.</strong></p><p><strong>If the BST has a balance, the time complexity is O(log n) for all cases.</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/trees1.19cxz5qrey1s.webp" alt="trees1"></p><pre><code class="c">bool search(node *tree, int number){    if (tree == NULL)    {        return false;    }    else if (number &lt; tree-&gt;number)    {        return search(tree-&gt;left, number);    }    else if (number &gt; tree-&gt;number)    {        return search(tree-&gt;right, number);    }    else if (number == tree-&gt;number)    {        return true;    }}</code></pre><h2 id="Hashing-and-Hash-Tables-哈希化-和-哈希表"><a href="#Hashing-and-Hash-Tables-哈希化-和-哈希表" class="headerlink" title="Hashing and Hash Tables 哈希化 和 哈希表"></a>Hashing and Hash Tables 哈希化 和 哈希表</h2><p><strong>Hashing</strong> is the idea of taking a value and being able to output a value that becoms a shortcut to it later.<br><strong>A hash table</strong> is a fantastic combination of both arrays and linked lists. When implemented in code, a hash table is an array of pointers to nodes.<br><strong>A hash function</strong> is an algorithm that reduces a larger value to something small and predictable. Generally, this function takes in an item you wish to add to your hash table, and returns an integer representing the array index in which the item should be placed.</p><p>For example, hasing <em>apple</em> may hash as a value of <code>1</code>, and <em>berry</em> may be hashed as <code>2</code>. Therefore, finding <em>apple</em> is as easy as aksing the hashed algorithm where <em>apple</em> is stored.<br>However, if we have a lot of words to store, relying solely on the first character to hash them is inefficient and not ideal. In such cases, it becomes necessary to create a larger hash table.<br><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/hash1.1tgun3ha4d5s.webp" alt="hash1"><br><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/hash2.122mvup0op7k.webp" alt="hash2"></p><p><em>You, as the programmer, have to make a decision about the advantages of <strong>using more memory to have a large hash table and potentially reducing search time</strong> or <strong>using less memory and potentially increasing search time.</strong></em></p><hr><h2 id="Tries-🌲"><a href="#Tries-🌲" class="headerlink" title="Tries 🌲"></a>Tries 🌲</h2><p><strong>Tries are always searchable in constant time.</strong></p><p><strong>One downside to Tries is that they tend to take up a large amount of memory. Notice that we need 26 X 5 = 120 <code>nodes</code> just to store <em>Hagrid!</em></strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/tries1.2ksls3umjg8w.webp" alt="tries1"></p><p><strong>Harry would then be stored as follows:</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/tries2.20f1qgbvjdpc.webp" alt="tries2"></p><hr><p>Goodbye, CS50! Have a nice day!</p><p>Mostly_Harmless</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这应该是&lt;code&gt;CS50&lt;/code&gt;笔记的最后一弹了，其C语言部分的最后一个lecture也是有关于&lt;code&gt;Data structure&lt;/code&gt;的，今天写这些就当作复习了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;链表-LIST&quot;&gt;&lt;a href=&quot;#链表-LIS</summary>
      
    
    
    
    
    <category term="Notes" scheme="http://example.com/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>CARE7_CHATGPT</title>
    <link href="http://example.com/2023/11/20/CARE7-CHATGPT/"/>
    <id>http://example.com/2023/11/20/CARE7-CHATGPT/</id>
    <published>2023-11-20T03:04:41.000Z</published>
    <updated>2023-12-31T14:06:32.541Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4fb1e53c97b21a3e2f7b91548971548c69ba3417cf61325e198b4f05af62f89e">bd25ed9264b080267271e137e33d0ce1c2bbccdc98003fe4014325307c3e2d14e94855f283ecb759d00b11f8989a7a4b460fc15b698abf9ae08d149c5be8e74235a5be3fc0bdd6b56f01e8b84ad1dad525e5e4b90cf30443d32afb22981a492a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输个密码吧</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="CARE" scheme="http://example.com/tags/CARE/"/>
    
  </entry>
  
  <entry>
    <title>20231119_排序算法 Sort</title>
    <link href="http://example.com/2023/11/19/20231119-Sort/"/>
    <id>http://example.com/2023/11/19/20231119-Sort/</id>
    <published>2023-11-19T15:09:59.000Z</published>
    <updated>2023-11-20T02:09:19.943Z</updated>
    
    <content type="html"><![CDATA[<p>写点排序算法的笔记：</p><h2 id="插入排序-InsertionSort-O-n-2"><a href="#插入排序-InsertionSort-O-n-2" class="headerlink" title="插入排序 InsertionSort O(n^2)"></a>插入排序 InsertionSort O(n^2)</h2><pre><code>void insertSort(int arr[], int begin, int end){    // int length = end - begin + 1;    for (int i = begin + 1; i &lt; end + 1; i++)    {        for (int j = i; j &gt; begin; j--)        {            if (arr[j] &lt; arr[j - 1])            {                swap(&amp;arr[j], &amp;arr[j - 1]);            }else            {                break;            }        }    }}</code></pre><p>插入排序的本质就是排个头，先把第一个固定住，然后看第二个，第二个要是比第一个矮，就swap一下。</p><p>然后看第三个，第三个有没有第二个矮，要是矮，swap，此时第三个变成了第二个，再判断一下它和第一个的关系…………</p><p>循环往复，最后就排序完毕了。</p><hr><h2 id="快速排序-QuickSort-O-nlogn"><a href="#快速排序-QuickSort-O-nlogn" class="headerlink" title="快速排序 QuickSort O(nlogn)"></a>快速排序 QuickSort O(nlogn)</h2><pre><code>void QuickSort(int array[], int low , int high){       if(low&lt;high){    int index = array[low];    int i = low;    int j = high;    while (i&lt;j)    {        while (i&lt;j &amp;&amp; array[j] &gt;= index)        {            j--;        }        if (i&lt;j)        {            swap(&amp;array[i], &amp;array[j]);            i++;        }        while (i&lt;j &amp;&amp; array[i]&lt;index)        {            i++;        }        if(i&lt;j)        {            swap(&amp;array[i], &amp;array[j]);            j--;        }     }    array[i] = index;    QuickSort(array,low,i-1);    QuickSort(array,i+1,high);    }}</code></pre><p>快速排序是我接触的第一个排序算法，也是第一个利用到了分治和递归思想的算法。</p><p>说大白话就是<strong>分堆</strong>，我们先选一个“标准/标杆”(index), 这里我直接选的是第一项，然后我们把所有小于index的元素，都swap到index左边，大于index的元素都swap到右边。这样我们就获得了两堆数。之后对着这两堆数进行递归操作，反复的分堆分堆，分到什么时候呢？分到每个堆只有一个数字了，这也就意味着我们分完了。</p><p>在分堆的过程也是有讲究的，我们从数组的两端向中间移动。</p><pre><code>while (i&lt;j &amp;&amp; array[j] &gt;= index){    j--;}if (i&lt;j) // 这个判断就是防止因为i &gt;= j导致while终止，误操作swap，下面的if也是同理{    swap(&amp;array[i], &amp;array[j]);    i++; // 注意这个i++；}</code></pre><p>上面这段就是从最右端往左走，大的我们就留下，一旦发现小的，我们就直接swap到左边，同时从左边swap一个数字过来。可能你想问，如果我们swap过来的那个数字也小于index，应该放在左边怎么办呢？不急，我们接着往下看。</p><pre><code>while (i&lt;j &amp;&amp; array[i]&lt;index){    i++;}if(i&lt;j){    swap(&amp;array[i], &amp;array[j]);    j--;} </code></pre><p>这段开始我们从左端往右走，和上面的同理，小的我们留下，一旦发现大的，我们直接swap到右边，同时从右边swap一个数字过来。这个疑问又出现了，我们如果swap了一个大于index数字过来怎么办？</p><p>还好，循环会解决这些疑问。</p><p>当你进入下一轮最外层的while循环时，我们首先就会判断上一轮swap过来的**array [ j ]**满不满足我们的需求，如果不满足，果断扔回去。第二个也是同理。</p><p>就这样，不断的把数字扔来扔去，我们就得到了一个排好序的数组。</p><hr><h2 id="并归排序-mergeSort-O-nlogn"><a href="#并归排序-mergeSort-O-nlogn" class="headerlink" title="并归排序 mergeSort O(nlogn)"></a>并归排序 mergeSort O(nlogn)</h2><pre><code>void merge(int arr[], int left, int mid, int right){    int i, j, k;    int l = mid - left + 1;    int r = right - mid;    // 创建两个临时数组 L/R    int *L = (int *)malloc(l * sizeof(int));    int *R = (int *)malloc(r * sizeof(int));    // 把数字放进去    for (i = 0; i &lt; l; i++)    {        L[i] = arr[left + i];    }    for (j = 0; j &lt; r; j++)    {        R[j] = arr[mid + 1 + j];    }    // 开始分吧    i = 0;    j = 0;    k = left; // 众神归位    while (i &lt; l &amp;&amp; j &lt; r)    {        if (L[i] &lt;= R[j])        {            arr[k] = L[i];            i++;        }        else        {            arr[k] = R[j];            j++;        }        k++;    }    // 把剩下的元素处理干净    while (i &lt; l)    {        arr[k] = L[i];        i++;        k++;    }    while (j &lt; r)    {        arr[k] = R[j];        j++;        k++;    }    // free一下，养成好习惯    free(L);    free(R);}void mergeSort(int arr[], int left, int right){    if (left &lt; right) // 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊，不要忘了比较这个啊啊啊啊啊啊啊啊啊啊啊啊啊啊    {        int mid = left + (right - left) / 2;        mergeSort(arr, left, mid);        mergeSort(arr, mid + 1, right);        merge(arr, left, mid, right);    }}</code></pre><p>并归排序的实质，在我理解看来就是局部的有序，然后进行整合。我们通过递归，获得了大量的size为2(或1)的有序的子数组，然后我们选两个，因为在他们内部已经有序了，所以我们比第一个数字的大小，谁大谁放第一个…………就这样，两个有序数组合并成了一个大的有序数组，最终实现了排序。</p><hr><p>先写到这里，未完待续</p><p>Mostly_Harmless</p><p>写于2023.11.20 上午十时</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写点排序算法的笔记：&lt;/p&gt;
&lt;h2 id=&quot;插入排序-InsertionSort-O-n-2&quot;&gt;&lt;a href=&quot;#插入排序-InsertionSort-O-n-2&quot; class=&quot;headerlink&quot; title=&quot;插入排序 InsertionSort O(n^2)&quot;</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>20231117_指针，地址，字符串</title>
    <link href="http://example.com/2023/11/17/20231117-Notes/"/>
    <id>http://example.com/2023/11/17/20231117-Notes/</id>
    <published>2023-11-17T00:19:16.000Z</published>
    <updated>2023-11-17T06:55:47.797Z</updated>
    
    <content type="html"><![CDATA[<p>写一下CS50学习过程中关于指针和地址部分的笔记和心得，其实就是在下面的注释部分，但是还是整理一下。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(void){    int n = 50;    char *s = "HI!";    int *p = &amp;n; // p 是一个 指向int类型变量 的地址 的 整数 8 bytes    // p 用来存储地址    printf("%i\n", n);    printf("%p\n", p); // %p 获取地址 &amp;n    // p 存储 n的位置 OR p 指向 n的位置    printf("%i\n", *p);    // 打印 p所指向的那个东西，De-reference 解引用=    printf("%p\n", s);    printf("%s\n", s);    // %s (String) 不仅仅是打印了个变量值，更是根据你提供的地址找到了TA！    // 这块一定要理解好，printf不需要找到*s,他只需要找到s，也就是这个字符串的第一位(s[0])开始的地方，然后遍历到\0就可以了，所以    // 我们这里没有写 *s，而是直接s。因为*s对应的就是s[0]这么一个单字母了，我们不需要这个    printf("%s\n", s + 1);    // s + 1 就是将起始位置向后移动了一位，于是只会打印出 “I!”    printf("%c %c\n", s[0], *(s + 0));    // %c 打印 *s 的字符 就是相当于s[0]，因为s指向的就是这个字符串起始位置，也就是H所在的位置    printf("%c %c\n", s[1], *(s + 1));    printf("%c %c\n", s[2], *(s + 2));    // 其实类似于 s[i] 的这种 “语法糖” ，在编译时是这样处理的：    // s[i] --&gt; *(s + i)    // 不用在乎数据类型的问题，编译器会自动为你换算    // 所以让我们做点禁忌的事情    // printf("%c\n", *(s + 20000));    // Segmentation fault (core dumped)    // 访问了不该访问的内存    // strcmp 做了个什么事情呢？    // 比如 s, t 是两个strings    // 我们怎么判断他们是否相等？    // i form 1 to n 判断 *(s + i) ?= *(t + i)    // strcmp(s, t) 就是帮你干了这么件事情    // 若是相同的，return 0;    // 若是字典序 s &gt; t, return 1;    // 若是字典序 s &lt; t, return -1;    string m = get_string("m: ");    string t = get_string("t: ");    printf("%p\n", m);    printf("%p\n", t);}</code></pre><p>其实指针部分的主要问题就是C语言对于 * 这个符号的“滥用”。</p><p>1.int *p = &amp;n;<br>此时*的作用是<strong>定义指针</strong>，p 是一个<strong>指向int类型变量的地址</strong>的<strong>整数</strong>，大小为8 bytes。</p><p>p 可以理解为存储了<strong>n的位置</strong>，你知道p，也就能找到n，并且n在内存中的位置是确定的，尽管n的数值会改变，但是这个变量所在的位置是在其被定义的那个时候就确定了。</p><p>2.printf(“%i\n”, *p);<br>此时*的作用就是<strong>De-reference 解引用指针</strong>，寻找到p对应的那个“东西”。</p><hr><p>剩下的就是一些细枝末节的东西，例如：</p><p>%p就是打印p所指向的<strong>地址</strong><br>e.g:printf(“%p\n”, p); 输出的就是0x16b6c710c，也就是n所在的地址。</p><p>对于字符串 (char数组) 而言，printf中的%s，你只需要提供你想要打印的起始位置，printf函数会自动替你完成“<strong>往下走，直到\0</strong>”的步骤。</p><p>e.g:</p><pre><code>char *s = "HI!";printf("%p\n", s); // out:0x16ae1f108printf("%s\n", s); // out:HI! printf("%s\n", s + 1); // out:I!</code></pre><p>我们这里没有写 *s，而是直接写s。因为*s对应的就是s[0]所对应的这么一个单字母(H)了，我们不需要这个，我们需要的是起始位置，也就是起始的地址。</p><p>类似于 s[i] 的这种 “语法糖” ，在编译时是这样处理的：<strong>s[i] –&gt; *(s + i)</strong><br>不用担心，编译器会为你做好一切，这类语法🍬还是很好用的。</p><hr><p>来点<strong>禁忌</strong>的事情</p><p>比如我们写这么一个东西</p><pre><code>printf("%c\n", *(s + 200000));</code></pre><p>我们想访问一下 s后200000位内存存着些什么，但是运行的时候就是**Segmentation fault (core dumped)**，你访问了（我访问了/计算机访问了）不该访问的内存。</p><hr><p>我们再围绕字符串写一点点东西，比如<strong>strings.h</strong>库中的<strong>strcmp</strong>函数，它的实现原理就是：输入s, t两个strings。然后开始判断 *(s + i) ?= *(t + i)，其中i从0到n遍历。</p><p>若是相同的，return 0;<br>若是字典序 s &gt; t, return 1;<br>若是字典序 s &lt; t, return -1;</p><p>Mostly_Harmless</p><p>写于2023.11.16 下午二时</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写一下CS50学习过程中关于指针和地址部分的笔记和心得，其实就是在下面的注释部分，但是还是整理一下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;cs50.h&amp;gt;

int main(void)
{
    </summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>20231011_新创世纪</title>
    <link href="http://example.com/2023/10/11/20231011-%E6%96%B0%E5%88%9B%E4%B8%96%E7%BA%AA/"/>
    <id>http://example.com/2023/10/11/20231011-%E6%96%B0%E5%88%9B%E4%B8%96%E7%BA%AA/</id>
    <published>2023-10-11T11:31:53.000Z</published>
    <updated>2023-10-11T11:33:04.373Z</updated>
    
    <content type="html"><![CDATA[<p>新创世纪</p><p>Hello，World！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;新创世纪&lt;/p&gt;
&lt;p&gt;Hello，World！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
