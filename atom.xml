<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Mostly_Harmless的碎碎念</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-05T03:32:01.626Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Mostly_Harmless</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIT6.006</title>
    <link href="http://example.com/2024/03/05/MIT6-006/"/>
    <id>http://example.com/2024/03/05/MIT6-006/</id>
    <published>2024-03-05T03:31:11.000Z</published>
    <updated>2024-03-05T03:32:01.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h1><p>在现有的模型(有诸多限制)下执行find的时间不会低于 <code>logN</code>。<br>证明：利用 <code>comparison model(比较模型)</code> -&gt; =, &lt;, &gt;, &lt;=, &gt;= 其就是将待处理的数据视为黑箱，处理时不直接接触数据，而是比较两者所关联的Key。</p><p>比较模型的一个例子：决策树。来到某个节点，进行某种比较操作，如果是True，则xxxxx，如果是False，则xxxxx……继续接下来的计算操作，直到来到<strong>这棵树的叶子节点</strong>(意味着接下来没有比较操作了) 树内的每一个节点都是比较操作，但是在叶子节点，意味着我得停止现在的计算操作。</p><p>那么叶子节点的数量代表着什么呢？其代表<strong>可能的结果数</strong>。对于一个合格的比较搜索算法而言，我们需要一个额外的叶子节点，来代表<strong>无结果/异常情况/给定Key对应的item不在Set中</strong>，也就是说这里至少需要 <code>n+1</code>个叶子节点。</p><p>此时，我们可以得到：这个算法的<strong>比较次数</strong>就是<strong>这棵树的最小高度(平衡二叉树-&gt;logN)<strong>。我们考虑最坏的情况下，我们必须从Root走到Leaf，那条路径就是</strong>最长路径</strong>。</p><p>如果我们想更快，怎么办？ 现实中，如果给定的父节点下的子节点数是一个常数(常数因子)，只要节点数是被常数限制的，那么这个效率永远最快只能达到对数级别，无法再快下去了。所以我们<strong>必须将节点数扩大到N的量级</strong>。</p><p>我们在Lec2中的RAM有提到，可以根据<strong>一个数字(内存地址)<strong>在</strong>常数恒定时间</strong>来随机访问内存中的任何位置。</p><p>所以我们或许可以使用 <code>直接访问数组</code>，就是<strong>Array[key] = item</strong>，这使得我们在 <code>find</code>, <code>insert</code>, <code>delete</code>都达到了常数级的时间。其显著的缺点就是<strong>空间的极度浪费</strong>。于是我们要做一件事情: “将一组大范围的key映射到一个小空间内”</p><p>那如何解决碰撞问题呢？<strong>在发生碰撞的Key对应的位置处，存放一个指针，指向另一数据结构Q，通过Q来存储这些发生碰撞的数据</strong>我们称Q为<strong>链</strong>，我们要选择<strong>合适的Hash算法</strong>，确保每个链都<strong>足够短</strong></p><p>可以将数组的每个元素存放为一个我们自己设计的class对象，该class数据结构都会有一个指针指向另一chain数据结构和一个value字段用来存item以及一个 <code>ischain</code>的布尔字段，当有多个冲突item时，<code>ischain</code>为 <code>true</code>，然后<em>value设置一个固定的标记</em>，并将item存于chain中</p><p>最简单的Hash函数就是<strong>取模</strong>，我们称之为分割法。但是这种方法在对分散度不好的input时，效果比较差。故我们在其基础上加入<strong>乱序混合处理+位操作</strong>，创建<strong>通用Hash函数</strong></p><p>通用Hash函数：h(k) = ((ak+b) mod p) mod m (m是小范围的范围值，p为一个较大的素数)<br>然后我们使a,b在0～p-1内随机取值(a != 0)，借此来形成一个函数的族。<br>通用性：如下图，发生碰撞的概率不高于1/m，这就是衡量<strong>分布情况</strong>的指标<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/image.9dcp8iw4ad.webp" alt="image"></p><h1 id="Linear-Sort"><a href="#Linear-Sort" class="headerlink" title="Linear Sort"></a>Linear Sort</h1><h2 id="DAA-Direct-Access-Array-Sort"><a href="#DAA-Direct-Access-Array-Sort" class="headerlink" title="DAA(Direct Access Array) Sort"></a>DAA(Direct Access Array) Sort</h2><ul><li>构造DAA                                       -&gt; O(u)</li><li>存储所有的元素，将 <code>元素x</code>存储在 <code>index[x.key]</code>处   -&gt; n*O(1)</li><li>沿着DAA，按顺序返回所有存在的元素                 -&gt; O(u)</li><li>=&gt;需要O(n + u). u = θ(n) -&gt; O(n) 达成了线性排序<br>这里我们假定每个 <code>item</code>都有一个 <code>key</code>，这样我们在进行 <code>Step2</code>时就可以<strong>直接进行复制</strong>。使得排序的对象不仅仅局限在整数</li></ul><hr><p>Q：如果 u &lt; n^2， 那么按照上面的👆推算，此时效率来到了O(n^2) 如何解决？<br>A：我们可以将每一个key都用 **一组数字(a, b)** 来表示。k=&gt;(a, b) = a * n + b. 这样我们就可以根据a与b的大小来比较key之间的大小。<code>divmod</code>这个转换是常数时间操作<br>Eg： {17, 3, 24, 22, 12}, n = 5 -&gt; {(3, 2), (0, 3), (4, 4), (4, 2), (2, 2)}</p><ul><li>如何对这些数字进行排序？ ——<code>tuple sort</code>元组排序，类似于Excel表格排序(优先级)</li><li>把上面的数组写成{32, 03, 44, 42, 22}</li></ul><ol><li><strong>按照最高位的大小进行排序</strong> =&gt; {03, 22, 32, 44, 42}(不打乱相同最高位数字间的相对顺序，例如44与42) =&gt; 下移一位，Repeat这个过程 之后你就会发现，数组会完全变乱 {22, 32, 42, 03, 44} BAD!</li><li><strong>按照最低位的大小进行排序</strong> =&gt; {32, 42, 22, 03, 44} =&gt; {03, 22, 32, 42, 44} <strong>我们需要一个stable排序算法</strong></li><li>DAA？不行，因为这里有相同的元素(例如42，44 其最高位相同)</li></ol><p>tuples中的<strong>元素数量为k，k为常数</strong> (例如上面的例子里，k = 2) ，最终花费的时间为kn，渐进时间复杂度才为O(n).但是这里我们进行单次排序显然不能用 <code>DAA</code>来进行处理了，怎么办呢？</p><h2 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h2><ul><li>我们为什么不在一个key上放更多的元素？(key对应的value为一个list/vector之类的collection)</li><li>我们依旧维护一个0～u-1的数组，在 <code>index k</code>处，我们存储一个指向 <code>chain</code>的 <code>pointer</code>，<strong>重要的是，我们要确保在插入时，维护并保持它们进入时的顺序，也就是需要排序算法时stable的</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/image.45f9x8xa4.webp" alt="image"><br>这张图里 u = n，u的大小也是可以改变的。</p><h2 id="Radix-Sort"><a href="#Radix-Sort" class="headerlink" title="Radix Sort"></a>Radix Sort</h2><ul><li>Radix Sort会将最大为u的整数分解为一个base的tuple， 位数为logn(u),其中n为底数</li><li>随后用 <code>counting sort</code>对数字进行 <code>tuple sort</code> 从最低位到最高位</li><li>时间复杂度 = n + n*logn(u) 当 <code>u &lt; n^c</code>时，这是一个线性时间算法</li></ul><hr><p>总结(in-place即占用常数内存)</p><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/image.1aoqijjq8e.webp" alt="image"></p><h1 id="Binary-Trees-二叉树"><a href="#Binary-Trees-二叉树" class="headerlink" title="Binary Trees 二叉树"></a>Binary Trees 二叉树</h1><p>有史以来最酷的数据结构</p><p>将要介绍一个数据结构，它能够<strong>秒杀</strong>此前学过的所有数据结构，并能几乎做到所有事情。</p><h2 id="什么是二叉树？"><a href="#什么是二叉树？" class="headerlink" title="什么是二叉树？"></a>什么是二叉树？</h2><ul><li>由若干节点构成类似于树的形状</li><li>每个节点包含三个指针，分别指向<code>父节点</code>、<code>右子节点</code>、<code>左子节点</code>，节点内部存储<code>item</code></li><li>没有父节点的节点称作<code>根节点 root</code>，也是<strong>唯一</strong>没有父节点的节点</li><li>弥补了<strong>链表无法回溯/效率低的缺陷</strong>(通过增加指针数量)</li><li>数可以分解为<strong>子树</strong>: 以x为根节点的子树由其x本身及其所有后代节点构成</li><li>节点的<strong>深度(depth)<strong>：</strong>x到根节点的路径上边的数量</strong> / <strong>祖先数量</strong></li><li>节点的<strong>高度(height)</strong>: 该节点向下到叶子节点<strong>最长路径的边数</strong> = <strong>以该节点为根节点的子树的最大深度</strong></li><li>h = height(root) = height(tree)</li><li>🌲的高度是明确的，但是其<strong>深度</strong>是不明确的</li><li>每个树都有<strong>traversal order</strong>的方式，递归规则是：对于每个节点x来说，所有在X.left子树中的节点先于x，所有在X.right子树中的节点后于x</li><li><strong>不要尝试去维护一个traversal order的数组</strong>，成本太大，并且复杂</li><li>TODO: <strong>把我们所有关心的运算都变成O(h)类的效率</strong></li></ul><hr><ul><li><p>以下的方法除了特别说明以外，时空复杂度全部为<code>O(h)</code></p></li><li><p>subtree_first(node):<br>通过给定的节点来获得一棵子树，在这个子树的所有节点中，哪个在<code>traversal order</code>排在第一位。  </p><ul><li>也就是<strong>最左端的节点</strong>。一直往左走：遍历条件是<strong>node=node.left</strong>，遍历到<code>NULL</code>节点时停下</li><li>return node;</li></ul></li><li><p>successor(node):<br>在整棵树的<code>traversal order</code>中，该node的下一个节点是谁</p><ul><li>if 该节点有一个右子节点，那么就是<code>subtree_first(node.right)</code></li><li>else 该节点没有右子节点，那么策略就是：往上走，直到遇见第一个向左方向遍历的节点。遍历条件是<strong>node=node.parent</strong>, 遍历到<strong>node==node.parent.left</strong></li><li>return node;</li></ul></li><li><p>subtree_insert_after(node, new):<br>在<code>traversal order</code>中将<code>new</code>插入到<code>node</code>的后面</p><ul><li>if node无右子节点，直接令 <code>node.right = new</code></li><li>else 令 <code>subtree_first(node.right).left = new</code> / <code>successor(node).left = new</code></li></ul></li><li><p>subtree_delete(node):</p><ul><li>if node为叶子节点，直接delete</li><li>else <ul><li>if node.left存在:<ul><li>将node里的item与predecessor(node)里的item交换一下</li><li>递归执行<code>subtree_delete(predecessor(node))</code></li></ul></li><li>if node.right存在：<ul><li>将node里的item与successor(node)里的item交换一下</li><li>递归执行<code>subtree_delete(successor(node))</code></li></ul></li></ul></li></ul></li></ul><hr><ul><li>实现<code>Sequence</code><ul><li>只需树的<code>traversal order</code>等于sequence内部item的顺序即可</li></ul></li><li>实现<code>Set</code> =&gt; BST 二叉搜索树/Set二叉树<ul><li>只需树的<code>traversal order</code>等价于item.key的增长的顺序即可</li><li>特性：左节点的子树中的所有节点都小于该节点，右节点的则反之</li><li>find(k): <strong>二分搜索</strong></li><li>find_next / find_prev 就分别对应找到那个节点的<code>successor</code>和<code>predecessor</code></li></ul></li></ul><p>Lec7</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hashing&quot;&gt;&lt;a href=&quot;#Hashing&quot; class=&quot;headerlink&quot; title=&quot;Hashing&quot;&gt;&lt;/a&gt;Hashing&lt;/h1&gt;&lt;p&gt;在现有的模型(有诸多限制)下执行find的时间不会低于 &lt;code&gt;logN&lt;/code&gt;。&lt;br&gt;</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://example.com/2024/02/28/test/"/>
    <id>http://example.com/2024/02/28/test/</id>
    <published>2024-02-28T09:29:04.000Z</published>
    <updated>2024-02-28T09:29:13.384Z</updated>
    
    <content type="html"><![CDATA[<p>八年级上册知识点<br>第一章从世界看中国<br>第一节疆域<br>【基本知识点】<br>一、优越的地理位置：<br>1.半球位置： 半球、 半球<br>2.纬度位置及优越性：<br>（1）纬度位置：大部分位于 带，南部部分地区位于 带，没有 带<br>（2）优越性：俄罗斯和加拿大大部分位于 带和 带地区；巴西大部分位于 带地区，与其相比，我国南北 较广，气候类型多样，有利于 的多种经营<br>3.海陆位置及优越性：（1）海陆位置： 东部，东临 <br>（2）优越性：蒙古是一个 国，日本是一个 国，与其相比，我国 ，优越性表现为：①有利于发展 事业，②<br>    交通便利，便于对外交往，③ 丰沛，利于农业发展。<br>二、辽阔的疆域：<br>1.领土四至： 最北端—                                               最南端—                                              最东端—                                              最西端— <br>2.我国南北最大距离约为 千米，东西最大距离约为 千米。<br>3.我国南北气候差异显著是因为 ；东西时间差异大是因为 。<br>4.陆地领土： 平方千米，仅次于 和 ，居世界第 位。<br>5.疆界：（1）陆上疆界： 多千米<br>（2）大陆海岸线： 多千米<br>6.邻国：（1）陆上邻国：        个，东邻 _____，北邻          ，东北和西北邻___________，                    西面有 、 、 、 、 <br>西南有 、 、 ，南面有 、 、 。<br>（2）隔海相望的国家： 个，从北向南依次是 、 、 、<br>    、 、 。</p><p>（3）与我国既陆地相邻，又隔海相望的国家： 、 。<br>7.海域：（1）濒临的海洋：<br>①临海：从北向南依次是 海、 海、 海、 海。<br>②大洋：东临 洋。<br>③台湾海峡属于 海，台湾岛东岸直接濒临 洋<br>（2）海峡： 海峡、 海峡。<br>（3）领海范围：从海岸基线向海上延伸 海里。<br>（4）内海： 、 。<br>8.主要岛屿： （我国最大的岛屿）、 （我国第二大岛）<br>三、行政区划<br>1.三级行政区划： 、 、 <br>2.省级行政区域：<br>（1）数量： 个，其中 个省， 个自治区， 个直辖市， 个特别行政区。<br>（2）省级行政区中：<br>面积最大                         面积最小                         最北  <br>最南  <br>最东  <br>最西                             跨经度最多                       跨纬度最多                       邻国最多  <br>相邻省区最多 、<br>既临渤海又临黄海 、<br>黄河 、长江干流都流经 、 <br>北回归线自东向西穿过 、 、 、 <br>既有陆上国界线，又有大陆海岸线 、 </p><p>【读图练习】<br>1.读中国疆域图，写地理事物名称。<br>（1）国家：1________2________<br>3________4________<br>5_________6________<br>7________8________<br>9________10________<br>11________12________<br>13________14________<br>①________②________<br>③________④________<br>⑤________⑥________<br>（2）海域：A <strong><strong><strong><strong>海B________海<br>C________海 D________海<br>E________海<br>（3）海峡：F</strong></strong></strong></strong>G________<br>（4）岛屿：a________b________</p><ol start="3"><li>   读“中国行政区划”图，填表。</li></ol><p>代号12345678910<br>全称<br>简称<br>行政<br>中心</p><p>第二节人口<br>一、世界上人口最多的国家<br>1.人口数量：<br>（1）人口总数： <br>（2）占世界人口总数的       2.我国人口政策：<br>（1）基本国策：实行 政策<br>（2）实施一对夫妻可生育两个孩子的计划生育政策是为了促进人口 。<br>二、人口东多西少<br>1.我国平均人口密度： 人/平方千米<br>2.人口分布：<br>分布情况： 地区人口密度大， 地区人口密度小（ 多 少）。<br>人口地理分界线： —— 一线。<br>第三节民族<br>一、56 个民族<br>1.民族构成：<br>（1） 个民族。<br>（2）人口最多的民族是 <br>（3）人口最多的少数民族是 <br>（4）人口在 500 万以上的少数民族： 族、 族、 族、 族、 族、<br>___<em><strong>族、 族、</strong></em> <em>族、 族<br>2.民族文化：<br>（1）主要民族节日： 傣族的 节；蒙古族的 节；苗族的 ；<br>藏族的 节； 族的丰收节； 族的元宵节。<br>（2）列入“世界非物质文化遗产”的民族文化：新疆维吾尔 、侗族 、藏族的 、蒙古族 <br>二、民族分布特点<br>1.民族分布：<br>（1）分布情况：①汉族：遍布全国，以 部和 部最为集中②少数民族： 、 、 <br>（2）分布特点： 、 、</em><br>（3）下列少数民族主要分布地区：<br>维吾尔族： 自治区，蒙古族： 自治区，藏族： 自治区， 回族： 自治区，壮族： 自治区<br>（4）少数民族最多的省是 省。<br>2.民族政策：在少数民族聚居地区实行民族区域自治制度。</p><p>第二章中国的自然环境第一节地形和地势<br>【基本知识点】 一、我国地形特点<br>1.我国地形特点： 、 。<br>2.地形的分布：西部以 、 、 为主，东部地形以 、 为主。<br>3.构成我国地形“骨架”的是 。<br>4.山区：（1）包括 、 和比较崎岖的 <br>（2）面积：占我国陆地面积的 <br>（3）发展的条件：①不利条件—— 不便，不利于发展 <br>②优势—— 业、 业、 业、 业<br>5.主要地形区：<br>（1）四大高原： （冰川广布） （地面平坦）<br>_____（沟壑纵横）（崎岖不平）</p><p>（2）四大盆地：__（海拔最高）____（纬度最高）<br>_____（面积最大）_______<br>（3）三大平原：__<em>（面积最大） _______<br>（4）主要丘陵：</em>____</p><p>③巫山的东侧是 ，西侧是 <br>④横断山脉的东侧是 、 ，西侧是 <br>⑤天山的北侧是 ，南侧是 <br>⑥昆仑山脉的北侧是 ，南侧是 <br>（3）山脉两侧的省级行政区<br>①太行山脉的东侧是 ，西侧是 ②巫山的东侧是 ，西侧是 ；<br>③武夷山脉的东侧是 ，西侧是 ④祁连山脉的北侧是 ，南侧是 <br>⑤昆仑山脉的北侧是 ，南侧是        二、我国地势特征<br>1.我国地势特征： 、 <br>2.三级阶梯：</p><ol start="5"><li>   主要地形区：<br>（1）四大高原： （冰川广布） （地面平坦）<br>_____（沟壑纵横）（崎岖不平）</li></ol><p>（2）四大盆地：__（海拔最高）____（纬度最高）</p><p>___（面积最大）</p><hr><p>（3）三大平原：__<em>（面积最大） _______<br>（4）主要丘陵：</em>____<br>6.主要山脉：<br>（1）山脉走向：</p><hr><ol start="3"><li>   我国地势的影响：</li></ol><p>①天山是 走向，和它走向相同的山脉还有： 、 、 、 <br>②大兴安岭是 走向，和它走向相同的山脉还有： 、 、 、<br>    、 、 <br>③阿尔泰山是 走向，和它走向相同的山脉还有： 、 <br>④贺兰山、横断山脉是 走向；<br>⑤喜马拉雅山脉是 山脉。<br>（2）山脉两侧的地形区：<br>①大兴安岭的东侧是 ，西侧是 <br>②太行山脉的东侧是 ，西侧是 </p><p>（1）对气候的影响： <br>（2）对河流的影响： </p><p>（3）我国大型水电站的分布特点：分布在 <br>4.我国陆地海拔最高点是 ，它位于我国和 的交界处，是<br>_____ 山脉的主峰，海拔 米 。 5.我国陆地最低点在吐鲁番盆地中的 洼地。</p><p>【读图练习】<br>1.读“我国主要山脉分布”图， 写出数字代表的山脉名称。</p><ol start="2"><li>   读“我国主要地形分布”图，写出字母代表的地形区名称。</li></ol><p>第二节气候<br>【基本知识点】 一、气温分布特点<br>1.我国气温分布特点：<br>（1）冬季：①特点：冬季 <br>②影响因素： <br>③ 我国 1 月 0℃等温线大致沿 — 一线分布。<br>（2）夏季：①特点： <br>②我国夏季气温最低的地方是 ，影响因素是 <br>2.我国冬季最冷的地方是 ；夏季最热的地方是 ， 人称“”。<br>3.我国的温度带：<br>（1）划分依据：根据 的南北差异，并结合 的实际<br>（2）名称： 带、 带、 带、 带、 带<br>（3）亚热带和暖温带的分界线： <br>（4）主要水果：苹果、梨 带，柑橘 带，椰子、香蕉 带<br>（5）按温度带划分，有热带的省级行政区是 、 、 、 、 （简称） 二、我国干湿地区分布<br>1.我国年降水量的分布趋势： </p><p>A___<br>C___    G___    F___    I___        </p><p>B____<br>D____<br>E____<br>H____<br>J____</p><ol start="2"><li>   干湿地区：<br>（1）反映一个地方气候干湿程度的是 和 的对比关系<br>（2）干湿地区的划分依据：气候的 状况<br>（3）名称： 、 、 、 。<br>（4）降水量：湿润区在 毫米以上，半湿润区为 — 毫米半干旱区为 — 毫米，干旱区在 毫米以下</li></ol><p>K___</p><p>（5）植被：湿润区以 为主，半湿润区属 和 的过渡地带， 半干旱区以 为主，干旱区植被稀疏， 和 广布</p><p>（6）农业生产：<br>①湿润、半湿润区以 业为主，湿润区耕地以 为主，粮食作物是 <br>半湿润区耕地以 为主，粮食作物是 <br>②干旱、半干旱区以 业为主。<br>（7）湿润区和半湿润区大体以 一线为界。<br>3.我国大多数地区的降水集中在 — 月。 方雨季长， 方雨季短（填“南/北”）。<br>4.我国降水最多的地方是台湾岛东北部的 ，降水最少的地方是 <br>    。三、我国的气候特征<br>1.我国气候的主要特征： 和 <br>2.我国的农作物及各种动植物资源极其丰富是因为 <br>3.我国主要的气候类型：<br>东部地区—— 、 、 西北内陆地区—— <br>青藏高原——                 四、影响我国气候的主要因素： 1.影响我国气候的主要因素：<br>（1）自南向北气温越来越低。 <br>（2）自东南向西北降水量越来越少。 <br>（3）山脉两侧气候差异大；一些高大的山地，气候呈明显的垂直变化。           2.受季风影响，我国比世界其他纬度相近地区，冬季气温更    ，夏季气温更     ， 气温年较差更 。</p><ol start="3"><li>   比较冬季风和夏季风：<br>（1）冬季风：<br>发源地：           风向： <br>性质： <br>影响：加剧了 的寒冷，使南北 <br>（2）夏季风<br>发源地： 、 <br>风向：① ② 性质： <br>影响： ，有利于农业生产。<br>【读图练习】</li><li>   读“我国温度带划分图”，写温度带名称。</li></ol><p>A B C <br>D E F </p><ol start="2"><li>   读“我国干湿地区”图，写出干湿地区名称。A <br>B C D </li><li>   读“我国主要的气候类型”图，写出字母代表的气候类型名称。<br>A B C D <br>E</li></ol><p> </p><p>第三节河流<br>【基本知识点】一、河流概况<br>1.主要河流及流向：大多自 向 流，最后注入 洋（受 地势影响） 怒江、雅鲁藏布江向南流入 洋；额尔齐斯河向北注入 洋<br>2.水文特征：<br>（1）汛期最长的大河是 ；结冰期最长的河流是 ；含沙量最多的河流是 ； 水量最大、年内流量变化最大的河流是 <br>（2）汛期： ① 季<br>②秦岭—淮河以北的河流在 季有短暂的汛期<br>（3）枯水期： 季<br>3.我国最大的内流河是 。<br>4.外流河的补给形式是 ；内流河的补给形式是 <br>5.京杭运河（1）地位：是世界上最长、开凿最早的人工河<br>（2）长度： 千米<br>（3）经过的省级行政区（简称）： 、 、 、 、 、 <br>（4）贯通的水系： 、 、 、 、 <br>（5）作用：在 工程中，京杭运河是长江水北调的重要输水通道。二、长江的开发与利用<br>1.长江的概况<br>（1）第一大河： 最长、 最广、 最大<br>（2）发源：青藏高原上的 山； 省<br>（3）注入： 海<br>（4）上、中游分界是 省的 ，中、下游分界是 省的 <br>（5）主要支流（自西向东）： 、 、 、 、 、 、</p><p>（6）主要湖泊：湖南省的 、江西省的 （我国最大的淡水湖）。<br>（7）干流流经的地形区： 高原、 高原、 盆地、 平原。</p><p>（8）干流流经的的省级行政区（简称）：_ _、 、 、 、 、 、<br>    、 、 、 、 <br>（9）主要的城市： 、 、 、 2.长江的开发与利用<br>（1）水能资源丰富：①集中分布在 河段<br>②主要水利枢纽： 、 <br>③美称：“ ”<br>（2）航运价值高：① 以下四季通航<br>②通航里程占全国内河航道总里程的 <br>③美称：“ ”。<br>3.长江的治理<br>（1）重点治理的河段：滩多流急的 ，“九曲回肠”的 <br>（2）主要生态问题及治理措施：<br>①上游——问题： 严重，措施： <br>②中下游地区——问题： 灾害频繁，措施： <br>③入海口及沿海——问题： 高风险区，措施：                  三、黄河的治理<br>1.概况<br>（1）发源：黄河发源于青藏高原上的 山； 省<br>（2）注入： 海<br>（3）上、中游分界是 自治区的 ，中、下游分界是 省的 <br>（4）主要支流： 、 <br>（5）干流流经的主要地形区： 高原、 高原、 高原、 平原。<br>（6）干流流经的省级行政区： 、 、 、 、 、 、 、<br>    、 ____ 2.黄河的奉献：<br>（1）塑造了平原： 上游—— 平原、 平原<br>下游—— 平原<br>（2）水能资源丰富：集中在 游，实行 开发</p><p>3.黄河的忧患与治理：<br>（1）上游——① 严重。原因是气候趋于 ，草地 ，解决的措施是 </p><p>② 。在 、 境内； （季节）；影响因素是 <br>（2）中游—— 严重。原因是流经 高原，这里土层 ， 破坏严重，7、8 月份多 ；解决的措施是 <br>（3）下游——①“ ”。原因是流经平原地区，河道变 ，河床坡度变 ， 水流速度 ，泥沙沉积下来，使河床逐渐 ；解决措施是 <br>② 。在 省境内。4.治黄的关键： <br>【读图练习】</p><p>2.读“长江水系图”，回答问题。</p><p>（1）支流: ① ② ③ ④ ⑤ ⑥ ⑦ <br>（2）湖泊: a b </p><p>1.读“我国主要河流分布”图，写出数字代表的河流名称。</p><p>（3）水利枢纽:c d  </p><p>e_ </p><p>（4）城市: A___ </p><p>B  </p><p>C  </p><p>D___ _</p><p>（5）上、中游分界E <em>，中、下游分界F</em> 3.读“黄河水系图”，回答问题。</p><p>1 2 3 <br>4 5 6 （1）海域：A _</p><p>7 8 9 </p><p>水利枢纽：B_ </p><p>C  </p><p>D_ </p><p>支流： E____ F  <br>(2)上、中游分界是①_<em>，中、下游分界是②</em>_<br>（3）平原：a b  </p><p>第四节自然灾害<br>一、我国常见的自然灾害<br>1.我国常见的自然灾害有 、 等。<br>2.气象灾害主要有 、 、 、 ；地质灾害主要有 、 、 等。<br>3.山区发生 灾害的频率较高。二、我国自然灾害发生频繁<br>1.我国自然灾害的特点： 多、 广、发生 、危害 <br>2.灾害的分布：台风— ；干旱— ；洪涝— ； 滑坡和泥石流— ，以 最为集中<br>三、防灾减灾<br>1.我国能够比较精确预报的灾害是 、 。<br>2.北方地区营造防护林是为防御 灾害。<br>3.避灾方法<br>（1）地震发生时， </p><p>（2）泥石流发生时，                              第三章中国的自然资源<br>第一节自然资源的基本特征<br>1.自然资源分为 资源和 资源。土地、阳光、森林、水能等属于<br>    资源；矿产资源属于 资源。<br>2.自然资源的合理利用：可再生资源—— <br>非可再生资源——             3.我国自然资源的基本特征： <br>4.被称为“黑色的金子”、“工业的血液”的是 。<br>5.我国是世界上第二大石油进口国。<br>6.4 月 22 日是“”。</p><p>第二节土地资源<br>【基本知识点】<br>一、土地资源的划分：<br>1.依据： 和 的差异，<br>2.分类： 用地、 用地和通常情况下难以利用的土地。<br>3.农业用地包括： 、 、 _。其中比例最大的是 ，比例最小的是 <br>二、优势和不足：<br>1.优势： 丰富， 齐全。<br>2.不足:（1）人均占有 <br>（2）比例不合理： 少、而 较多， 不足三、分布<br>1.耕地和林地：主要分布在东部 、 区（干湿地区）<br>（1）南方耕地以 为主，北方耕地以 为主<br>（2）林地则主要分布在 <br>2.草地：主要分布在西部 、 区（干湿地区），主要用于 业。四、我国的基本国策是“ ”。<br>【读图练习】写出漫画反映的土地利用中的问题：</p><p>① “飞来的山峰”： <br>② “小草的哀求”： <br>③ “水土的怒吼”： <br>④ “土地的辛酸”： </p><p>第三节水资源一、时空分布不均<br>1.我国主要的淡水资源： 和 <br>2.时空分布不均<br>（1）空间分布：以 为界， 丰 缺，缺水最严重的是 和<br>    地区<br>（2）时间分配： 多， 少；年际变化也 。<br>（3）时空分布不均对社会经济发展的影响：<br>①南方耕地以 为主，北方耕地以 为主。<br>② 我国降水和径流的季节、年际变化大容易造成 灾害频繁；<br>③ 在西北地区，制约社会经济发展的瓶颈是 不足。二、合理利用与保护水资源<br>1.解决水资源时空分布不均的措施<br>（1）解决水资源季节变化大的措施： <br>（2）解决水资源地区分布不均的有效办法： <br>①缓解天津市严重缺水的是 工程；<br>②缓解山西省供水紧张状况的是 工程；<br>③解我国北方地区严重缺水的是 引水工程。2.关于南水北调工程：<br>（1）把长江流域丰富的水资源，调到缺水严重的 和 地区。<br>（2）调水线路：<br>①东线工程:从长江下游抽引长江水，主要利用 输送，北达 与</p><p>4.节约用水，保护水资源<br>（1）农业：① <br>② <br>③ <br>（2）工业：① <br>② <br>③ <br>（3）生活：① <br>② <br>③ </p><p>②中线工程：目前从 水库引水，北达 。<br>③东线和中线工程可以解决 地区的缺水问题<br>④西线方案:把长江上游的水引入 ，补充 地区的水资源。3.目前我国的水资源状况：供应 ；利用率 ， 惊人；<br>    严重，解决途径： </p><p>第四章中国的经济发展第一节交通运输<br>【基本知识点】<br>一、交通运输的作用<br>1.地位：人们把交通运输形象地比喻为“ ”。<br>2.各种现代交通运输方式特点：（1）速度最快、价格最高： 运输；<br>（2）价格最低、运量最大： 运输；<br>（3）机动灵活： 运输；<br>（4）运量较大，价格较低： 运输。</p><p>【读图练习】读“我国主要铁路干线分布”图，回答问题。</p><ol start="3"><li>   运输方式的选择：<br>（1）乌鲁木齐某学校的校长接到去北京开会的通知，要求第二天必须赶到。 运输<br>（2）从石家庄到香港旅游，比较经济的旅行方案。 运输<br>（3）从重庆到武汉，沿途欣赏三峡风光。 运输<br>（4）1 吨活鱼从北京郊区的水库运往城区。 运输<br>（5）1 吨葡萄从山东运到上海销售。 运输<br>（6）5000 吨钢材从上海运往济南。 运输<br>（7）1 万吨大米从大连运往广州。 运输<br>归纳：运距远，贵重、急需、量小的货物适宜选择 ； 鲜活的或易变质的货物，运距较近，多采用 ；<br>大宗笨重货物，远距离运输，一般选择 。二、主要的铁路干线</li><li>   我国铁路网的分布情况： 部密集， 部稀疏。</li><li>   在建设资源节约型，环境友好型社会方面意义重大的运输方式是 。</li><li>   我国民航运输总量已经跃居世界第 位。</li><li>   陇海线与京广线交会于 ，与京沪线交会于 。</li><li>   经过省级行政区最多的铁路线是 。</li></ol><p>1.起讫点:<br>1 2 3 4 5 <br>6 7 8 9 10 <br>11 12 13 14 15 <br>16 17 18 19 20 <br>21 22 23 24 <br>2.铁路线：<br>1-2 1-3 1-4 1-5 <br>6-7 7-8 8-9 10-11 <br>11-12 2-13 2-14 1-15 <br>17-16 16-18 4-19 19-20 <br>20-21 21-12 22-23 2-24 <br>3.主要铁路枢纽：A B </p><p>第二节农业<br>【基本知识点】一、农业的作用<br>1.主要农业部门： 业、 业、 业、 业等。<br>2.地位：农业是支撑国民经济的 产业。二、我国农业的地区分布：<br>1.东、西部的差异：东、西部的分界线： 等降水量线<br>（1）西部地区：以 业为主；牧区： 、 、 、 <br>（2）东部地区： 业、 业和 业<br>种植业：主要分布在 、 （干湿地区）的 （地形）地区林业：天然林区分布在 和 ，人工林区分布在 <br>渔业：海洋渔业基地是 地区，淡水渔业发达的是 地区2.南、北方的差异：南、北方的分界线： <br>（1）北方地区：耕地多为 ，粮食作物主要是 、 。</p><p>四、走科技强农之路<br>1.我国依靠科学技术，使农业增长方式正从广种薄收转向优质高产，优良品种不断出现； 机械化和专业化水平、生产效率不断提高；农田水利建设取得长足进步，抗灾能力明显 增强。<br>2.我国科技进步对农业生产的贡献已经超过 50%，还必须依靠科技的优势，大力发展高产、优质、高效、生态、安全农业。<br>第三节工业<br>【基本知识点】<br>1.工业国情：我国是世界 大国，是世界最大的货物 国。<br>2.我国产量居世界首位的工业产品是 、 、 、 、 。<br>3.工业分布的基本格局： 地区工业中心密集， 地区工业中心较多，<br>______ 地区工业中心较少、分布稀疏。<br>4.我国四大工业基地： 、 、 、 <br>5.带动我国工业实现科学发展的高新技术产业有： 、 、</p><p>（2）南方地区：耕地以 为主，粮食作物主要是 。 和 。我国是世界最大的 设备制造国。</p><p>（3）我国主要平原的农业生产：①东北平原：全国有名的 （糖料作物）基地，这<br>里种植的油料作物是 ，作物熟制是 <br>②华北平原：全国三大 区之一，是全国重要的<br>    （油料作物）产地，作物熟制大多 <br>③长江中下游平原：种植水稻，也种植 （油料作物）、 ，作物熟制是 。<br>（4）海南岛的作物熟制是 。<br>（5）我国粮食作物的分布格局是“ ”。三、因地制宜发展农业：<br>1.地形陡峭，水土容易流失的山区适宜发展 业，这叫“ ”<br>2.降水稀少，牧草生长良好的地区适宜发展 业，这叫“ ”<br>3.地形平坦，土壤肥沃，水源丰富的地区适宜发展_ _业，这叫“ ”<br>4.河湖较多的地区适宜发展 业，这叫“ ”<br>5.城市近郊地区以种植蔬菜、花卉，发展 生产为主。</p><ol start="6"><li>   我国的国家级高新技术产业开发区的分布：<br>（1）多依附于 城市。<br>（2）聚集的地区： 、 、 <br>（3）我国首个国家级高新技术产业开发区是北京 ；我国第一家国家级的光电产业基地是湖北 新技术开发区，被称为“ ”。<br>【读图练习】<br>读“我国工业分布”图，回答问题。<br>（1）工业基地：A B <br>C D <br>（2）沿海工业中心：① ② ③ <br>④ ⑤ ⑥ ⑦ <br>（3）沿长江工业中心；<br>a b c</li></ol><p> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;八年级上册知识点&lt;br&gt;第一章	从世界看中国&lt;br&gt;第一节	疆域&lt;br&gt;【基本知识点】&lt;br&gt;一、优越的地理位置：&lt;br&gt;1.	半球位置： 	半球、 	半球&lt;br&gt;2.	纬度位置及优越性：&lt;br&gt;（1）	纬度位置：大部分位于 	带，南部部分地区位于 	带，没有 	带&lt;br&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>递归打印_P1928</title>
    <link href="http://example.com/2024/02/17/%E9%80%92%E5%BD%92%E6%89%93%E5%8D%B0-P1928/"/>
    <id>http://example.com/2024/02/17/%E9%80%92%E5%BD%92%E6%89%93%E5%8D%B0-P1928/</id>
    <published>2024-02-17T00:18:37.000Z</published>
    <updated>2024-02-17T12:49:38.433Z</updated>
    
    <content type="html"><![CDATA[<p>多层嵌套出了问题</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;多层嵌套出了问题&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CS106X_Note1</title>
    <link href="http://example.com/2024/01/16/CS106X-Note1/"/>
    <id>http://example.com/2024/01/16/CS106X-Note1/</id>
    <published>2024-01-16T02:16:21.000Z</published>
    <updated>2024-03-05T03:32:50.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h1><p>C++ 的语法和 Java 是大体相似的<br>（岂不是我学完C++可以速通Java了</p><pre><code class="cpp">using namespace name;</code></pre><p>其中 <code>namespace</code>就是变量的作用域(scope)</p><p>这种写法的好处就是我们可以让各个文件中相同名字的函数名、变量名、类名 <strong>各自独立</strong>。<br>例如我们有很多类似于 <code>cout</code>的标识符，如果你需要用 <code>cout</code>来打印你的内容，那就代表着你不能将一个变量命名为cout(这样会导致冲突)</p><p>如果你在两个不同的 <code>namespace</code>中使用了相同名称的变量、方法或者类的时候，这都是OK的。</p><p>你在代码开头打上 <code>using namespace xxx;</code>，这代表你希望获得 <code>xxx</code>中所有东西的命名，以及你希望在程序中可以访问其所有内容。</p><p>例如：<code>cout</code>的全称是 <code>std::cout</code>，这代表它是一个位于 <code>std namespace</code>的变量。<br>但是我们一遍遍打 <strong>std::</strong> 有些痛苦，加上 <code>using namespace std;</code>，就可以不用在 <code>cout</code>的前面加上 <code>std::</code>了。</p><hr><p><code>cin</code>是一个糟糕的用法</p><p><code>cin&gt;&gt;(int age)</code>是语法错误，无法编译。</p><p>FUCK，Vscode 无法使用StanfordLib，你妈的。</p><p>cin无法判断用户输入的内容是否匹配对应的类型，所以我们不用。</p><p>我们用 <code>simpio.h</code>中的 <code>getInteger("prompt")</code>,<code>getReal("prompt")</code>,<code>getLine("prompt")</code>,<code>getYesOrNo("prompt")</code>.</p><hr><h1 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h1><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><pre><code class="cpp">double circleArea(double r) {    return 3.14159265359 * r * r;}</code></pre><ol><li>可以利用函数指针来将一个函数作为参数传入另一个函数，也就是回调(call back)</li><li>C++对类型转换较为宽容，类似于 <code>Java</code>和 <code>Python</code>。例如你传入 <code>1</code>到 <code>circleArea</code>中，会自动转换为 <code>1.0</code></li><li>C++允许默认参数 <code>default parameters</code>，这是C++的一个特性，C不具备。它允许你在函数中声明一个具有默认值的参数。如果在调用函数的时候没有为这个参数提供值，它将会自动使用默认值。</li></ol><pre><code class="cpp">void printLine(int width = 10, char letter = '*') {    for (int i = 0; i &lt; width; i++) {        cout &lt;&lt; letter;    }}···printLine(7, '?'); // ???????printLine(5);      // *****printLine();       // **********</code></pre><p>需要注意的一点是：<strong>有默认值的参数必须在参数列表的末尾</strong>，否则函数无法判断你的参数是传递给谁的。我们也不能跳过第一个默认值，去直接给第二个默认值参数传值。默认参数只能<strong>从右至左连续地省略</strong>。</p><ol start="4"><li>一切的函数必须在使用之前就被声明或定义。这一点和C是一致的。如果有大量的函数需要被声明的话，那就可以单独建立一个头文件，然后在main函数的文件头include一下”.h”。<br>所有的默认参数值在开头的声明处写明就好，如果在函数定义处重申一遍默认值，编译器会报错。例如下面：</li></ol><pre><code class="cpp">void song(int times = 5);····void song(int times) {    ·····}</code></pre><ol start="5"><li>数学函数<br><code>#include &lt;cmath&gt;</code><br>以下来自ChatGPT:</li></ol><p><strong>三角函数</strong>:</p><ul><li><code>sin(double x)</code>: 计算角 x（以弧度为单位）的正弦。</li><li><code>cos(double x)</code>: 计算角 x（以弧度为单位）的余弦。</li><li><code>tan(double x)</code>: 计算角 x（以弧度为单位）的正切。</li><li><code>asin(double x)</code>: 计算 x 的反正弦值，结果以弧度为单位。</li><li><code>acos(double x)</code>: 计算 x 的反余弦值，结果以弧度为单位。</li><li><code>atan(double x)</code>: 计算 x 的反正切值，结果以弧度为单位。</li><li><code>atan2(double y, double x)</code>: 计算以点 (x, y) 为坐标的角度，结果以弧度为单位。</li></ul><p><strong>指数和对数函数</strong>:</p><ul><li><code>exp(double x)</code>: 计算 e 的 x 次幂。</li><li><code>log(double x)</code>: 计算 x 的自然对数（基数是 e）。</li><li><code>log10(double x)</code>: 计算 x 的常用对数（基数是 10）。</li><li><code>pow(double base, double exp)</code>: 计算 base 的 exp 次幂。</li></ul><p><strong>平方根和绝对值函数</strong>:</p><ul><li><code>sqrt(double x)</code>: 计算 x 的平方根。</li><li><code>cbrt(double x)</code>: 计算 x 的立方根。</li><li><code>abs(int n)</code> / <code>fabs(double x)</code>: 计算整数或浮点数 x 的绝对值。</li></ul><p><strong>取整函数</strong>:</p><ul><li><code>ceil(double x)</code>: 计算大于或等于 x 的最小整数。</li><li><code>floor(double x)</code>: 计算小于或等于 x 的最大整数。</li><li><code>round(double x)</code>: 返回 x 四舍五入到最接近的整数。</li></ul><p><strong>其他函数</strong>:</p><ul><li><code>fmod(double x, double y)</code>: 返回 x 除以 y 的余数。</li><li><code>hypot(double x, double y)</code>: 计算直角三角形的斜边长度，给定两个边长 x 和 y。</li></ul><ol start="6"><li>值语意(value semantics) / 引用语意(reference semantics)</li></ol><ul><li>值语意：当变量(int, double, char)作为参数传入函数时，只会<strong>复制它们的值</strong>，两者是完全独立的</li><li>引用语意：当较为复杂的对象或者数组作为参数传入函数时，会使用引用语意。两者是关联在一起的</li><li>当然，你可以自己选择语意的类型，例如你写一个 <code>swap</code>函数。需要注意的是，这里的 <code>int&amp; a, int&amp; b</code>的写法和<strong>指针</strong>是不同的：引用更像给<strong>变量起一个别名</strong>，你使用a, b就和使用x, y是一样的，而不是像是指针一样去访问地址。你也不需要用什么*a, *b之类的去<strong>解引用</strong>。你也就不可以将字面值作为一个引用参数传入函数中去</li></ul><pre><code class="cpp">void swap(int&amp; a, int&amp; b) {   int temp = a;   a = b;   b = temp;}····swap(x, y);</code></pre><ul><li>我们也可以通过引用参数来实现<strong>一次返回多个值</strong>的操作，例如下面：我在 <code>datingRange</code>中对min, max做的任何操作，其实都是直接作用在 <code>main</code>中的young, old上的。</li></ul><pre><code class="cpp">void datingRange(int age, int&amp; min, int&amp; max) {   min = age / 2 + 7;   max = (age - 7) * 2;}int main() {   int young;   int old;   datingRange(48, young, old);   ·····}</code></pre><h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p><code>#include &lt;string&gt;</code> &amp; <code>string s = "hello";</code></p><p>C++中的字符串支持运算符 <code>Operators</code>，例如：</p><ul><li>Concatenation串联 +/+=</li></ul><pre><code class="cpp">string s1 = "Mar";s1 += "ty"; // "Marty"</code></pre><ul><li>Q1:为什么有了 <code>+</code>这种操作，在 <code>cout</code>中还要用 <code>&lt;&lt;</code>呢？</li><li>A1:因为串联操作<strong>仅支持string+string/char</strong>，对于int、double等类型无效</li><li>Compare比较 利用 == != &lt; &lt;= &gt; &gt;= 根据ASCII码大小，注意<strong>大写字母的ASCII码小</strong></li></ul><pre><code class="cpp">string s2 = "Cynthia";if (s1 &gt; s2 &amp;&amp; s2 != "Joe") { // true   ···}</code></pre><ul><li>operator overloading操作符重载<br>这是一种C++特有的语言特性，你可以<strong>重新定义操作符，让它们能处理不同的数据类型</strong>。Compare这里就用到了这一特性</li><li>Mutable可变性</li></ul><pre><code class="cpp">s1.append(" Stepp");       //"Marty Stepp"s1.erase(3, 2);            //"Mar  Stepp"s1[6] = 'o';               //"Mar  Stopp"</code></pre><ul><li>Q2:<code>append</code>和 <code>+=</code>的区别是?</li><li>A2:前者是<strong>直接修改原有的string</strong>，后者是<strong>创建了一个新的string</strong>，相比之下，内存方面会有一些差异。</li></ul><hr><p>下面是一些string内部定义的一些函数：</p><table><thead><tr><th>函数调用</th><th>解释和用法</th></tr></thead><tbody><tr><td><code>s.append(str)</code></td><td>向字符串 <code>s</code> 的末尾追加另一个字符串 <code>str</code>。</td></tr><tr><td><code>s.assign(str)</code></td><td>将字符串 <code>s</code> 的内容替换为字符串 <code>str</code> 的副本。</td></tr><tr><td><code>s.clear()</code></td><td>清除字符串 <code>s</code> 中的所有内容，使其变为空字符串。</td></tr><tr><td><code>s.compare(str)</code></td><td>比较字符串 <code>s</code> 和 <code>str</code>。返回值 &lt; 0 表示 <code>s</code> 小于 <code>str</code>，0 表示两者相等，&gt; 0 表示 <code>s</code> 大于 <code>str</code>。</td></tr><tr><td><code>s.empty()</code></td><td>如果字符串 <code>s</code> 为空返回 <code>true</code>，否则返回 <code>false</code>。</td></tr><tr><td><code>s.erase(pos, len)</code></td><td>从字符串 <code>s</code> 中移除从 <code>pos</code> 位置开始的 <code>len</code> 个字符。</td></tr><tr><td><code>s.find(str, pos)</code></td><td>从字符串 <code>s</code> 中的 <code>pos</code> 位置开始查找子字符串 <code>str</code>。如果找到，返回子字符串的起始位置；否则返回 <code>std::string::npos</code>。</td></tr><tr><td><code>s.rfind(str, pos)</code></td><td>从字符串 <code>s</code> 中的 <code>pos</code> 位置开始回头查找子字符串 <code>str</code>。如果找到，返回子字符串的起始位置；否则返回 <code>std::string::npos</code>。 (pos为空，则默认从末尾开始)</td></tr><tr><td><code>s.length()</code></td><td>返回字符串 <code>s</code> 中的字符数。</td></tr><tr><td><code>s.replace(pos, len, str)</code></td><td>将字符串 <code>s</code> 中从 <code>pos</code> 开始的 <code>len</code> 个字符替换为字符串 <code>str</code>。</td></tr><tr><td><code>s.substr(pos, len)</code></td><td>返回一个新字符串，包含从字符串 <code>s</code> 的 <code>pos</code> 位置开始的 <code>len</code> 个字符。</td></tr><tr><td><code>s.insert(pos, str)</code></td><td>在字符串 <code>s</code> 的 <code>pos</code> 位置插入字符串 <code>str</code>。</td></tr></tbody></table><p>下面是 <code>StanfordLib</code>中 <code>strlib.h</code>的函数</p><table><thead><tr><th>Function name</th><th>Description</th></tr></thead><tbody><tr><td><code>endswith(str, suffix)</code></td><td>如果字符串以给定的文本结束，则为真</td></tr><tr><td><code>startswith(str, prefix)</code></td><td>如果字符串以给定的文本开始，则为真</td></tr><tr><td><code>integerToString(int)</code></td><td>将整数转换成字符串</td></tr><tr><td><code>realToString(double)</code></td><td>将实数转换成字符串</td></tr><tr><td><code>stringToInteger(str)</code></td><td>将字符串转换成整数</td></tr><tr><td><code>stringToReal(str)</code></td><td>将字符串转换成实数</td></tr><tr><td><code>equalsIgnoreCase(s1, s2)</code></td><td>如果s1和s2有相同的字符，忽略大小写，则为真</td></tr><tr><td><code>toLowerCase(str)</code></td><td>返回字符串的小写版本</td></tr><tr><td><code>toUpperCase(str)</code></td><td>返回字符串的大写版本</td></tr><tr><td><code>trim(str)</code></td><td>返回去除周围空白的字符串</td></tr></tbody></table><hr><p>C++中有两种并行的字符串存储处理方式-C(char arrays)/C++(string objects)</p><p>类似于 <code>"Hi there"</code>就是 <code>C string</code>，当你打出 <code>s1 = "xxx"</code>,其实后台默认做了个转换，将 <code>C string</code>转换为了 <code>C++ string</code>并存储在 <code>s1</code>中。</p><p>一切适用于C++ string的特性都不适用于C string。</p><ul><li>Q3:什么时候会出现Bug呢？</li><li>A3:例如 <code>string s2 = "Hi" + "there";</code> 这是一个 <code>C-string</code> + <code>C-string</code>,这个bug甚至不会导致编译错误，只是会使你的程序崩溃。因为这里只是在<strong>将地址相加</strong>，并返回一个<strong>不知道在什么地方的地址</strong>。正确的写法应该是**<code>string s2 = string("Hi") + "there";</code>,先将 <code>Hi</code>转换为 <code>C++-string</code>,再进行处理，就OK了。</li><li>同理，<code>C-string</code> + <code>char/int.....</code>都是不行的</li></ul><h2 id="I-O-Stream"><a href="#I-O-Stream" class="headerlink" title="I/O Stream"></a>I/O Stream</h2><p><code>#include &lt;fstream&gt;</code><br>由于 <code>继承</code>的机制，例如：<code>cin</code>-&gt;<code>ifstream</code>,<code>cout</code>-&gt;<code>ofstream</code></p><p>⬇️<code>ifstream</code></p><table><thead><tr><th>成员函数</th><th>描述</th></tr></thead><tbody><tr><td><code>f.clear();</code></td><td>重置流的错误状态（如果有的话）</td></tr><tr><td><code>f.close();</code></td><td>停止读取文件</td></tr><tr><td><code>f.eof();</code></td><td>如果流已经过了文件末尾（EOF），则返回真</td></tr><tr><td><code>f.fail();</code></td><td>如果最后一次读取调用失败（例如 EOF），则返回真</td></tr><tr><td><code>f.get();</code></td><td>读取并返回一个字符</td></tr><tr><td><code>f.open("filename");</code></td><td>用给定的C字符串打开文件（如果传递了C++字符串，可能需要写 <code>.c_str()</code>）</td></tr><tr><td><code>f.open(s.c_str());</code></td><td>同上</td></tr><tr><td><code>f.unget(ch);</code></td><td>取消读取一个字符</td></tr><tr><td><code>f &gt;&gt; var;</code></td><td>从输入文件读取数据到变量（类似 cin）；一次读取一个由空白分隔的标记</td></tr><tr><td><code>getline(f&amp;, s&amp;);</code></td><td>将输入行读取到字符串，通过引用；返回成功/失败的真/假指示器</td></tr></tbody></table><p><strong>open</strong> a file,<strong>read</strong> each line,<strong>close</strong> it.</p><pre><code class="cpp">// read and print every line of a file#include &lt;fstream&gt;...ifstream input;input.open("poem.txt"); string line;while (getline(intput, line)) {   cout &lt;&lt; line &lt;&lt; endl;}input.close();</code></pre><p>一个常见的错误⬇️</p><pre><code class="cpp">// incorrect (why?)while (!input.fail()) {   string line;   getline(input, line);   cout &lt;&lt; line &lt;&lt; endl;}</code></pre><p>问题点在于：<code>getline</code>读取到文件的末尾时，并不会立刻将 <code>input</code>的 <code>fail</code>状态设置成 <code>true</code>，而是先设置 <code>eof</code>，当下一次尝试读取时(即读取一个 <code>eof</code>状态的文件，才会将他的 <code>fail</code>状态更为 <code>true</code>)。这就会产生一个问题：最后一次读取 <code>input</code>的时候失败了，没有对 <code>line</code>进行任何更改，也就导致<em>最后一行输出了两次</em>，随后才会终止while循环</p><hr><p><code>#include &lt;sstream&gt;</code></p><p><code>istringstream</code>可以将一整个 <code>string</code>读取进来，然后逐个 <code>word</code>进行处理</p><pre><code class="cpp">// read specific word tokends from a stringistringstream input("Jenny Smith 8675309");string first, last;int phone;input &gt;&gt; first &gt;&gt; last;input &gt;&gt; phone;cout &lt;&lt; first &lt;&lt; " " &lt;&lt; last &lt;&lt; " " &lt;&lt; phone &lt;&lt; endl;// Jenny Smith 8675309</code></pre><pre><code class="cpp">istringstream input2("To be or not to be");string word; while (input2 &gt;&gt; word) {    cout &lt;&lt; word &lt;&lt; endl;}</code></pre><p><code>ostringstream</code>可以创建一个 <code>string</code>的 <code>buffer</code>缓冲区，将你的输出存储起来。最后使用 <code>str</code>来读取其内容。</p><pre><code class="cpp">ostringstream output;int age = 42, iq = 79;output &lt;&lt; "My age is " &lt;&lt; age &lt;&lt; endl;output &lt;&lt; "and my IQ is " &lt;&lt; iq &lt;&lt; endl;string result = output.str();cout &lt;&lt; result &lt;&lt; endl;// My age is 42\nand my IQ is 79\n</code></pre><p><code>StanfordLib</code>-<code>filelib.h</code></p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>createDirectory(name);</code></td><td>用给定的名称创建一个新目录</td></tr><tr><td><code>deleteFile(name);</code></td><td>从磁盘中删除一个文件</td></tr><tr><td><code>fileExists(name)</code></td><td>如果给定的文件在磁盘上存在，则返回真</td></tr><tr><td><code>getCurrentDirectory()</code></td><td>返回C++程序目录的字符串形式</td></tr><tr><td><code>isDirectory(name), isFile(name)</code></td><td>基于文件路径的类型返回真</td></tr><tr><td><code>openFile(ifstream&amp;, name);</code></td><td>方便地使用C++字符串打开文件</td></tr><tr><td><code>promptUserForFile(ifstream&amp;, prompt)</code></td><td>重复提示用户输入现有文件的名称</td></tr><tr><td><code>readEntireFile(ifstream&amp;, Lines&amp;);</code></td><td>将文件数据读入到行的集合中</td></tr><tr><td><code>renameFile(oldname, newname);</code></td><td>更改文件的名称</td></tr></tbody></table><hr><h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><p><code>#include "grid.h"</code><br>一种 <code>collection</code>容器-&gt;<strong>存储数据的数据结构</strong>，数据的独立片段则被称为<strong>elements</strong>元素。</p><p><code>Grid</code>是二维数组,**一定要标明元素的数据类型。默认值是0/false(bool)</p><p>需要强调的一点是：<strong>当你想把一个 <code>Grid</code>作为参数传入到函数当中去的时候，<code>Copying</code>是很慢的，严重拖慢效率，直接reference(&amp;)引用传递就好</strong></p><p>还需要强调的一点是：<strong>当你不希望你传入的 <code>Grid</code>被修改时，请善用 <code>const</code></strong></p><pre><code class="cpp">// constructing a GridGrid&lt;int&gt; matrix(3, 4);martix[0][0] = 75;...// or specify elements in {}Grid&lt;int&gt; matrix = {   {75,24,3,3},   {23,4,5,4},   {1,2,1,1}};</code></pre><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>Grid&lt;type&gt; name(r, c);</code></td><td>创建一个给定行数/列数的网格；如果省略，则创建一个空的0x0网格</td></tr><tr><td><code>g[r][c];</code></td><td>返回给定行/列的值</td></tr><tr><td><code>g.fill(value);</code></td><td>设置每个格子为给定的值</td></tr><tr><td><code>g.inBounds(r, c)</code></td><td>如果给定位置在网格内，则返回真</td></tr><tr><td><code>g.numCols()</code> 或 <code>g.width()</code></td><td>返回列数</td></tr><tr><td><code>g.numRows()</code> 或 <code>g.height()</code></td><td>返回行数</td></tr><tr><td><code>g.resize(nRows, nCols);</code></td><td>将网格调整为新的大小，并丢弃旧内容</td></tr><tr><td><code>g[r][c] = value;</code> 或 <code>g.set(r, c, value);</code></td><td>在给定行/列存储值</td></tr><tr><td><code>g.toString()</code></td><td>返回网格的字符串表示形式，例如 <code>"{{3, 42}, {-7, 1}, {5, 19}}"</code></td></tr><tr><td><code>ostr &lt;&lt; g</code></td><td>打印网格，例如 <code>{{3, 42}, {-7, 1}, {5, 19}}</code></td></tr></tbody></table><hr><h1 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h1><h2 id="Vector-aka-list"><a href="#Vector-aka-list" class="headerlink" title="Vector(aka list)"></a>Vector(aka list)</h2><p><code>#include "vector.h"</code></p><p>依旧是一个 <code>collection</code> 容器，负责<strong>从0开始索引存储内容</strong>，一个可以<strong>动态调整大小</strong>的数组。</p><pre><code class="cpp">// initialize a vector containing 5 integers//          index 0  1  2  3  4Vector&lt;int&gt; nums {1, 2, 3, 4, 5} //不需要加"="Vector&lt;string&gt; names;names.add("Tom");       //{"Tom"}names.add("Jay");       //{"Tom", "Jay"}names.insert(0, "Liu")  //{"Liu", "Tom", "Jay"}</code></pre><ul><li>Q4: 为什么不用 <code>Arrays</code>?</li><li>A4: 1. Arrays有着固定的大小，且很难更改其大小。  2. 无法判断访问是否越界，是否会访问到垃圾内存上。  3.没有那些实用的函数</li></ul><p>一些常用的函数如下⬇️</p><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td><code>v.add(value);</code> 或 <code>v += value;</code> 或 <code>v += v1, v2, ..., vN;</code></td><td>在向量末尾添加一个或多个值</td></tr><tr><td><code>v.clear();</code></td><td>移除所有元素</td></tr><tr><td><code>v[i]</code> 或 <code>v.get(i);</code></td><td>返回给定索引处的值</td></tr><tr><td><code>v.insert(i, value);</code></td><td>在给定索引之前插入值，并将后续的值向右移动</td></tr><tr><td><code>v.isEmpty();</code></td><td>如果向量不包含任何元素，则返回真</td></tr><tr><td><code>v.remove(i);</code></td><td>移除/返回给定索引处的值，并将后续的值向左移动</td></tr><tr><td><code>v[i] = value;</code> 或 <code>v.set(i, value);</code></td><td>在给定索引处替换值</td></tr><tr><td><code>v.subList(start, length);</code></td><td>返回索引子范围的新向量</td></tr><tr><td><code>v.size();</code></td><td>返回向量中元素的数量</td></tr><tr><td><code>v.toString();</code></td><td>返回向量的字符串表示形式，例 如 <code>"{{3, 42, -7, 15}}"</code></td></tr><tr><td><code>ostr &lt;&lt; v;</code></td><td>打印向量中的元素</td></tr></tbody></table><p>C++在 <code>c++17</code>后开始有了<strong>模板推断</strong>的特性，也就是你在 <code>&lt;&gt;</code>输入为空的话，编译器会<strong>自行判断数据类型</strong></p><p>下面是一个小练习，写一个函数，目的是删除整个 <code>vector</code>里所有的 <code>string s</code></p><pre><code class="cpp">void removeAll(Vector&lt;string&gt;&amp; v, string s) {   for (int i = v.size() - 1; i &gt;= 0; i--) {      if (v[i] == s) {         v.remove(i);      }   }}</code></pre><ul><li><strong>注意⚠️！！</strong> <strong>是 <code>Vector</code>,V要大写</strong></li><li>为什么从后往前查找呢？</li></ul><h3 id="Vector-insert"><a href="#Vector-insert" class="headerlink" title="Vector insert"></a>Vector insert</h3><p><code>Vector</code>内部是用 <code>Arrays</code>来实现的，那么是如何实现动态容量的呢？</p><p>由于 <code>Arrays</code>本身并没有调整大小的功能，所以size总会比我们实际所需的大一些。例如我们创建了一个包含 <code>6个int的Vector</code>，那么他的实际大小可能是10/20/30… 但是<strong>这个实际大小确实是固定的</strong>，当我们所需的大小超过了目前的实际大小，那么就会<strong>重新创建</strong>一个实际大小更大的 <code>Arrays</code>，<strong>并把原来的数据Copy过去</strong></p><hr><h2 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h2><p>一种通过代码来判断计算机资源使用情况的方法：通常与<strong>速度(运行时间)/内存(占用空间)<strong>有关，大多数都是</strong>参考运行时间</strong></p><p>为了方便评估，我们有如下假设：</p><ul><li>A single statement’s runtime = 1</li><li>A function call’s runtime = (sum of runtime of statements in function’s body)</li><li>A loop of N iterations   ‘ runtime = (N * (loop body’s runtime))</li></ul><p>下面是一个例子：⬇️</p><pre><code class="cpp">statement1;                // runtime = 1for (int i = 1; i &lt;= N; i++) {      // runtime = N^2    for (int j = 1; j &lt;= N; j++) {  // runtime = N        statement2;    }}for (int i = 1; i &lt;= N; i++) {      // runtime = 3N    statement3;    statement4;    statement5;}// total = N^2 + 3N + 1</code></pre><p>通常来说我们只关心<strong>影响运行时间的最大因素</strong>，并将<strong>表达式中的参数都忽略掉</strong>。例如上面👆这个例子我们就可以用O(N^2)来概括</p><hr><h1 id="Part4"><a href="#Part4" class="headerlink" title="Part4"></a>Part4</h1><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><code>#include "list.h"</code><br><code>LinkedList</code>提供了和 <code>Vector</code>几乎一样的函数。</p><pre><code class="cpp">LinkedList&lt;int&gt; list; // 要声明元素存储类型for (int i = 1; i &lt;= 8; i++) {   list.add(10 * i); // {10, 20, 30, 40, 50, 60, 70, 80}}</code></pre><p>一个笑话：计算机科学家讨厌三件东西,redundancy(冗余),inefficiency(低效)和redundancy(冗余)</p><ul><li>Q5:为什么要在已经有 <code>Vector</code>的情况下，还要在设计一个几乎相同的collection <code>LinkedList</code>呢？</li><li>A5:因为两者内部是不同的实现方式，前者是 <code>Arrays</code>，后者是 <code>Nodes</code></li></ul><hr><h2 id="Abstract-data-types-ADTs"><a href="#Abstract-data-types-ADTs" class="headerlink" title="Abstract data types (ADTs)"></a>Abstract data types (ADTs)</h2><p>一类<strong>数据类型和操作方法</strong>的集合，主要关注<strong>这个集合能做什么</strong>，而不是<strong>它如何做什么</strong></p><p>我们可以将 <code>Vector</code>和 <code>LinkedList</code>都归类为 <code>list</code>.其他的一些ADTs还有：<code>stack, queue, set, map, graph</code></p><h2 id="Stacks-and-queues"><a href="#Stacks-and-queues" class="headerlink" title="Stacks and queues"></a>Stacks and queues</h2><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240116/1705372931222.webp" alt="1705372931222"></p><h3 id="Stacks"><a href="#Stacks" class="headerlink" title="Stacks"></a>Stacks</h3><p><code>#include "stack.h"</code></p><ul><li>Add/remove from “top” only. Last-In, First-Out (LIFO)</li><li>元素按照插入的顺序进行存储。我们认为他们没有序号(index)</li><li>只能对最上面的(最后一个插入的)元素进行操作(add/remove/examine)</li><li>基础的一些操作⬇️</li><li><strong>push</strong>: Add an element to the top.</li><li><strong>pop</strong>:  Remove the top element.</li><li><strong>peek</strong>: Examine the top element.</li></ul><table><thead><tr><th>方法</th><th>时间复杂度</th><th>描述</th></tr></thead><tbody><tr><td><code>s.isEmpty()</code></td><td>O(1)</td><td>如果栈没有元素则返回真</td></tr><tr><td><code>s.peek()</code></td><td>O(1)</td><td>返回栈顶元素但不移除它；如果栈为空则抛出错误</td></tr><tr><td><code>s.pop()</code></td><td>O(1)</td><td>移除并返回栈顶元素；如果栈为空则抛出错误</td></tr><tr><td><code>s.push(value);</code></td><td>O(1)</td><td>将给定值放到栈顶</td></tr><tr><td><code>s.size()</code></td><td>O(1)</td><td>返回栈中元素的数量</td></tr></tbody></table><pre><code class="cpp">Stack&lt;int&gt; s;              // {}s.push(42);                // {42}s.push(-3);                // {42, -3}s.push(17);                // {42, -3, 17}cout &lt;&lt; s.pop() &lt;&lt; endl;   // 17  (s is {42, -3})cout &lt;&lt; s.peek() &lt;&lt; endl;  // -3  (s is {42, -3})cout &lt;&lt; s.pop() &lt;&lt; endl;   // -3  (s is {42})</code></pre><p><code>Stack</code>内部是通过 <code>Arrays</code>或者 <code>Vector</code>实现的</p><ul><li>“bottom” = index 0</li><li>“top”    = index (size - 1)   (便于进行操作)</li></ul><p>当然，你也可以用 <code>LinkedList</code>来实现</p><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><code>#include "queue.h"</code></p><ul><li>Add to “back” only; remove from “front” only. First-In, First-Out(FIFO)</li><li>元素按照按照插入顺序进行存储，没有index</li><li>只能在队尾 <code>add</code>，在前面 <code>examine/remove</code></li><li>基础的一些操作⬇️</li><li><strong>enqueue</strong>: Add an element to the back.</li><li><strong>dequeue</strong>: Remove the front element.</li><li><strong>peek</strong>:    Examine the front element.</li></ul><table><thead><tr><th>方法</th><th>时间复杂度</th><th>描述</th></tr></thead><tbody><tr><td><code>q.dequeue()</code></td><td>O(1)</td><td>移除并返回队列前端的值；如果队列为空则抛出错误</td></tr><tr><td><code>q.enqueue(value);</code></td><td>O(1)</td><td>在队列后端放置给定的值</td></tr><tr><td><code>q.isEmpty()</code></td><td>O(1)</td><td>如果队列没有元素则返回真</td></tr><tr><td><code>q.peek()</code></td><td>O(1)</td><td>返回队列前端的值但不移除；如果队列为空则抛出错误</td></tr><tr><td><code>q.size()</code></td><td>O(1)</td><td>返回队列中元素的数量</td></tr></tbody></table><p>和 <code>Stacks</code>一样，必须将<strong>所有的元素出列</strong>才可以遍历它们。</p><pre><code class="cpp">// process (and destory) an entire queuewhile (!q.isEmpty()) {   do something with q.dequeue();}</code></pre><p>Another version:</p><pre><code class="cpp">int size = q.size(); // 要注意，queue是FIFO，这一套操作下来，其实整体是没有改变的，先出来，再塞到末尾。这种方式不会丢失内容for (int i = 0; i &lt; size; i++) {   do something with q.dequeue();   (including possibly re-adding it to the queue)}</code></pre><pre><code class="cpp">void mirror (Queue&lt;string&gt;&amp; p) {    Stack&lt;string&gt; s;    int size = p.size();    string tmp;    for (int i = 0; i &lt; size; i++) {        tmp = p.dequeue();        s.push(tmp);        p.enqueue(tmp);    }    for (int i = 0; i &lt; size; i++) {        p.enqueue(s.pop());    }}</code></pre><h2 id="Sets-and-Maps"><a href="#Sets-and-Maps" class="headerlink" title="Sets and Maps"></a>Sets and Maps</h2><h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h3><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240116/1705410426723.jpg" alt="Sets"><br><code>#include "set.h"</code> &amp; <code>#include "hashset.h"</code></p><ul><li>包含若干<strong>不重复的</strong>元素。</li><li>没有index，没有顺序，我们也不关系它们的顺序</li><li>有两种实现方式：<code>Set</code> / <code>HashSet</code></li><li><code>Set</code>会将数据存储在一个<strong>二叉树</strong>中。而 <code>HashSet</code>则是将数据H<strong>ash化并用Array存储</strong></li><li>同时，<code>Sets</code>也支持<strong>操作符的使用</strong></li></ul><table><thead><tr><th>成员</th><th>Set</th><th>HashSet</th><th>描述</th></tr></thead><tbody><tr><td><code>s.add(value);</code></td><td>O(log N)</td><td>O(1)</td><td>向集合中添加给定值</td></tr><tr><td><code>s.clear();</code></td><td>O(N)</td><td>O(N)</td><td>移除集合中的所有元素</td></tr><tr><td><code>s.contains(value)</code></td><td>O(log N)</td><td>O(1)</td><td>如果找到给定值则返回真</td></tr><tr><td><code>s.isEmpty()</code></td><td>O(1)</td><td>O(1)</td><td>如果集合中没有元素则返回真</td></tr><tr><td><code>s.isSubsetOf(set)</code></td><td>O(N log N)</td><td>O(N)</td><td>如果这个集合是另一个集合的子集则返回真</td></tr><tr><td><code>s.remove(value);</code></td><td>O(log N)</td><td>O(1)</td><td>从集合中移除给定值</td></tr><tr><td><code>s.size()</code></td><td>O(1)</td><td>O(1)</td><td>返回集合中的元素数量</td></tr><tr><td><code>s.toString()</code></td><td>O(N)</td><td>O(N)</td><td>返回集合的字符串表示，例如 “{3, 42, -7, 15}”</td></tr><tr><td><code>ostr &lt;&lt; s</code></td><td>O(N)</td><td>O(N)</td><td>将集合打印到流中</td></tr></tbody></table><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td><code>s1 == s2</code></td><td>如果集合包含完全相同的元素则返回真</td></tr><tr><td><code>s1 != s2</code></td><td>如果集合不包含相同的元素则返回真</td></tr><tr><td><code>s1 + s2</code></td><td>返回集合 s1 和 s2 的并集（来自任一集合的元素）</td></tr><tr><td><code>s1 += s2;</code></td><td>将集合 s1 设置为 s1 和 s2 的并集（或向 s1 添加一个值）</td></tr><tr><td><code>s1 * s2</code></td><td>返回集合 s1 和 s2 的交集（在两个集合中都存在的元素）</td></tr><tr><td><code>s1 *= s2;</code></td><td>将集合 s1 设置为 s1 和 s2 的交集</td></tr><tr><td><code>s1 - s2</code></td><td>返回集合 s1 和 s2 的差集（在 s1 中但不在 s2 中的元素）</td></tr><tr><td><code>s1 -= s2;</code></td><td>将集合 s1 设置为s1 和 s2 的差集（或从 s1 中移除一个值）</td></tr></tbody></table><ul><li>Q6: 那我们什么时候需要用 <code>Sets</code>来解决问题呢？</li><li>A6: 例如：计算一些文本中<strong>有多少种单词</strong>(比如”to”出现了55次，也只算1种)</li><li>Q7: 什么时候用 <code>Set</code>，什么时候用 <code>HashSet</code>呢？</li><li>A7: 需要<strong>有序</strong>时，用前者；否则用后者以获得更快性能。</li></ul><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240116/1705415408686.jpg" alt="1705415408686"><br><code>#include "map.h"</code>; <code>#include "hashmap.h"</code>;</p><pre><code class="cpp">Map&lt;string, int&gt; votes // maps from string keys to integer values</code></pre><ul><li>一种用来存储<strong>一对数据</strong>的collection, (key, value)。<code>key</code>相当于是<strong>索引</strong>，<code>value</code>是<strong>具体的值</strong></li><li>同样的，我们也有两种的 <code>Maps</code>类型：<code>Map</code> / <code>HashMap</code></li><li>其内部原理和 <code>Sets</code>几乎相同，<code>Map</code>用<strong>二叉树存储</strong>，而 <code>HashMap</code>存储<strong>Hash化后的数据</strong>，利弊也是类似的</li><li>基础的一些操作⬇️</li><li><strong>m.put(key, value)</strong>: Add a key/value pair to the map.</li><li><strong>m.get(key)</strong>:        Returns the value paired with the given key.(return a default value if the key is not found)</li><li><strong>m.remove(key)</strong>:     Remove the given key and its paired value.</li></ul><table><thead><tr><th>成员</th><th>Map</th><th>HashMap</th><th>描述</th></tr></thead><tbody><tr><td><code>m.clear();</code></td><td>O(N)</td><td>O(N)</td><td>移除所有键/值对</td></tr><tr><td><code>m.containsKey(key)</code></td><td>O(log N)</td><td>O(1)</td><td>如果映射中有给定键的对应项则返回真</td></tr><tr><td><code>m[key]</code> 或 <code>m.get(key)</code></td><td>O(log N)</td><td>O(1)</td><td>返回给定键映射的值；如果未找到，则添加具有默认值的项</td></tr><tr><td><code>m.isEmpty()</code></td><td>O(1)</td><td>O(1)</td><td>如果映射不包含任何对则返回真</td></tr><tr><td><code>m.keys()</code></td><td>O(N)</td><td>O(N)</td><td>返回映射中所有键的向量副本</td></tr><tr><td><code>m[key] = value;</code> 或 <code>m.put(key, value);</code></td><td>O(log N)</td><td>O(1)</td><td>添加一个键/值对；如果键已存在，替换其值</td></tr><tr><td><code>m.remove(key);</code></td><td>O(log N)</td><td>O(1)</td><td>移除给定键的任何对</td></tr><tr><td><code>m.size()</code></td><td>O(1)</td><td>O(1)</td><td>返回映射中对的数量</td></tr><tr><td><code>m.toString()</code></td><td>O(N)</td><td>O(N)</td><td>返回映射的字符串表示，例如 “{a: 90, d: 60, c: 70}”</td></tr><tr><td><code>m.values()</code></td><td>O(N)</td><td>O(N)</td><td>返回映射中所有值的向量副本</td></tr><tr><td><code>ostr &lt;&lt; m</code></td><td>O(N)</td><td>O(N)</td><td>将映射打印到流中</td></tr></tbody></table><h3 id="Lexicon"><a href="#Lexicon" class="headerlink" title="Lexicon"></a>Lexicon</h3><p><code>#include "lexicon.h"</code></p><ul><li>有和 <code>Sets</code>一样的方法和接口，就是一个<strong>大字典</strong></li><li>默认就是存储 <code>String</code>, 按 <code>字典序</code>排列</li></ul><table><thead><tr><th>成员方法</th><th>Big-Oh</th><th>描述</th></tr></thead><tbody><tr><td><code>Lexicon name;</code></td><td>O(N*len)</td><td>创建空词典或从文件读取</td></tr><tr><td><code>Lexicon name("file");</code></td><td>O(N*len)</td><td>从文件创建词典</td></tr><tr><td><code>L.add(word);</code></td><td>O(len)</td><td>向词典中添加给定单词</td></tr><tr><td><code>L.addWordsFromFile("f");</code></td><td>O(N*len)</td><td>从输入文件添加所有单词（每行一个）</td></tr><tr><td><code>L.clear();</code></td><td>O(N*len)</td><td>移除词典中的所有元素</td></tr><tr><td><code>L.contains("word")</code></td><td>O(len)</td><td>如果在词典中找到单词则返回真</td></tr><tr><td><code>L.containsPrefix("str")</code></td><td>O(len)</td><td>如果 s 是词典中任意单词的开始则返回真</td></tr><tr><td><code>L.isEmpty()</code></td><td>O(1)</td><td>如果词典中没有单词则返回真</td></tr><tr><td><code>L.remove("word");</code></td><td>O(len)</td><td>如果存在，则从词典中移除单词</td></tr><tr><td><code>L.removePrefix("str");</code></td><td>O(len)</td><td>移除所有以特定前缀开始的单词</td></tr><tr><td><code>L.size()</code></td><td>O(1)</td><td>返回词典中的单词数量</td></tr><tr><td><code>L.toString()</code></td><td>O(M)</td><td>返回词典的字符串表示，例如 “{ ‘arm’, ‘cot’, ‘zebra’ }”</td></tr></tbody></table><h1 id="Part-5"><a href="#Part-5" class="headerlink" title="Part 5"></a>Part 5</h1><h2 id="Recursion"><a href="#Recursion" class="headerlink" title="Recursion"></a>Recursion</h2><p><strong>self—similar</strong></p><ul><li>这描述了一种<strong>自己运行时调用自己</strong>的算法或处理方式</li><li>What is recursive programming?</li><li>Writting a function that calls itself.</li></ul><p>eg: Factorial(N)</p><pre><code class="cpp">int fact(int n){   if (n &lt;= 1){       return 1;      // Base case   }else{      int result = n * fact(n - 1); // Recursive case      return result;   }   }</code></pre><ul><li>recursion &amp; iteration</li><li>其实recursion在效率上是<strong>远远不如iteration</strong>的，尤其当其调用过多后，很有可能会造成<strong>stack overflow</strong>。很多问题也不适合利用recursion来解决。</li><li>Q8: 什么类型的问题或者算法适合用recursion来解决呢？</li><li>A8: 有 <code>self-similar</code>(自相似)特性的算法。=&gt; 我怎么描述这个算法使得其能<strong>被一个更小更相似的版本</strong>来刻画</li><li><strong>base case</strong> : 最简单的情况，直接给出答案</li><li><strong>recursive case</strong> : 一些无法被直接回答的情况。但是你可以通过其他<strong>更小的更简单的</strong>情况来刻画它</li></ul><h2 id="backtracking"><a href="#backtracking" class="headerlink" title="backtracking"></a>backtracking</h2><p>回溯</p><p>这是一种采取recursion来解决 <strong>涉及对(true)错(false)</strong> 的问题的特定方法。<br>如果你遇到了false，那就通过backtracking来寻找争取的路。<br>我们先从 <code>exhaustive search</code>(穷举搜索)开始。backtracking作为其一种形式</p><h3 id="exhaustive-search"><a href="#exhaustive-search" class="headerlink" title="exhaustive search"></a>exhaustive search</h3><ul><li>尝试每一种可能的组合</li><li>搜索空间经常包含许多 <code>选择</code>，每一种选择都有很多的 <code>可选项</code>。</li><li>什么时候我们可能会用到穷举搜索呢？ 例如：<strong>搜索目录树结构</strong>、<strong>对一组数值进行排列或搜索的情况</strong>(-&gt;逻辑组合、组合数学、名称、密码……)</li></ul><hr><ul><li>一个通用的穷举搜索的伪代码：</li></ul><pre><code class="cpp">function Search(decisions): - If there are decisions left to make:   // Let's handle one decision ourselves, and the rest by recursion.   For each available choice C for this decision:      - Choose C.      - Search the remaining decisions that could follow C. - Otherwise, if there are no more decisions to make: Stop.</code></pre><p>这里的 <code>base case</code>不再代表<strong>一种简单普通的情况</strong>，而是代表<strong>走到头了</strong>，<strong>我这个stack已经堆到要求的高度了</strong>，没什么可以接着选了。</p><hr><p>例子：printBinary 打印指定位数的所有二进制数.</p><pre><code class="cpp">void printBinary (int digits, string prefix = "") {   if (digits == 0) {      cout &lt;&lt; prefix &lt;&lt; endl; // 这个base case并不是什么都不做，而是将我们之前的成功(完整的prefix)打印出来   }else {      printBinary(digits - 1, prefix + "0");      printBinary(digits - 1, prefix + "1");   }}</code></pre><p>printDecimal 打印所有的十进制数</p><pre><code class="cpp">void printDecimal (int digits, string prefix = "") {   if (digits == 0) {      cout &lt;&lt; prefix &lt;&lt; endl; // 这个base case并不是什么都不做，而是将我们之前的成功(完整的prefix)打印出来   }else {      printDecimal(digits - 1, prefix + "0");      printDecimal(digits - 1, prefix + "1");      printDecimal(digits - 1, prefix + "2");      printDecimal(digits - 1, prefix + "3");      printDecimal(digits - 1, prefix + "4");      printDecimal(digits - 1, prefix + "5");      printDecimal(digits - 1, prefix + "6");      printDecimal(digits - 1, prefix + "7");      printDecimal(digits - 1, prefix + "8");      printDecimal(digits - 1, prefix + "9");   }}</code></pre><p>permute 打印所有字母的排列组合</p><pre><code class="cpp">void permute (string s, string perfix = "") {    int length = s.length();    if (length &lt; 1) {        cout &lt;&lt; perfix &lt;&lt; endl;    }else {        for (int i = 0; i &lt; length; i++) {            char x = s[i];            string y = s;            y.erase(i,1);            permute(y, perfix + x);        }    }}</code></pre><h3 id="backtracking-1"><a href="#backtracking-1" class="headerlink" title="backtracking"></a>backtracking</h3><p>回溯法是<strong>穷尽搜索</strong>和<strong>筛选</strong>相结合的一种方法，它在探索解空间的时候，加入了<em>过滤</em>的思想。这样我们就可以<strong>找到问题的最优解或者满足特定条件的解决方案</strong></p><ul><li>这是一种暴力技巧，它会检查所有的可能性(至少确保考虑了所有情况)</li><li>同时，由于这类算法和策略通常具有<strong>自相似性</strong>，通过递归来实现解决方案通常会<strong>更加直观和易于理解</strong></li><li>-&gt; 递归能够更自然的表达问题与解决方案之间的关系，使代码更易读以及可维护</li><li>backtracking的伪代码：</li></ul><pre><code class="cpp">function Search(decisions): - If there are decisions left to make:   // Let's handle one decision ourselves, and the rest by recursion.   For each available choice C for this decision:      - Choose C.      - Search the remaining decisions that could follow C.      - **Un-choose C** -&gt;(Backtrack!) - Otherwise, if there are no more decisions to make: Stop.</code></pre><p>在进行选择时，你会修改目前的状态，而在后续的搜索过程中，你会发现这种修改<strong>并不符合你的要求或者期望</strong>。因此，你需要<strong>撤销之前的选择</strong>，回到之前的状态，以便重新尝试其他的选择。-&gt; 确保你可以找到满足条件的解决方案</p><ul><li><strong>8皇后问题</strong></li><li>在8×8格的国际象棋上摆放8个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法</li><li>很明显的解决思路是： 我们应在放置一个皇后时，通过其被摆放的位置，来限制接下来皇后可能存在的位置，来减少查找空间的大小。这样可以逐步缩小解的范围，使我们更快的找到有效的解决方案</li></ul><h1 id="Part-6"><a href="#Part-6" class="headerlink" title="Part 6"></a>Part 6</h1><h2 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h2><p>一种*<strong>轻量化的</strong>类，相当于给各类数据打了个包。</p><pre><code class="cpp">struct Date {     // 声明一个structure的名称   int month;   int day;       // 各类成员的名称与类型}···Date today;       //初始化today.month = 10;today.day = 23;Date xmas = {12, 25}; // 按顺序来实现初始化+赋值</code></pre><p>当然，你也可以在里面写一些<strong>你定义的函数</strong>，在这些函数里，你可以<strong>直接 使用结构体里的变量</strong></p><pre><code class="cpp">struct Date {      int month;   int day;        int daysInMonth() {       if (month == 9 || month == 4      ||  month == 6 || month == 11) {         return 30;      }else if (month == 2) {         return 28; // 这里就不考虑闰年的情况了      }else { return 31; }   }   string toString() {      return integerToString(month) + "/" + integerToString(day);   }}</code></pre><p>结构体里的东西默认是公开的(public)，意味着你可以直接访问它并查看其变量的值。<br>而对于类来说，里面的东西默认是私有的(private)，意味着当你想直接访问/修改里面的变量，编译器会报错：你没有这个权限</p><ul><li>空指针：本身的所处内存并不是NULL，而是其指向的是NULL。nullptr就像宇宙中的无边黑暗</li><li>垃圾指针：没有进行初始化，故其指向某个随机地方的指针。也就是随机<strong>生成</strong>一个地址数字存储起来，这个内存中可能存储着<strong>你绝不可以碰触的数字</strong></li><li>-&gt; 所以我们<strong>声明一个新指针时</strong>，务必要<strong>为其赋予初值</strong></li></ul><pre><code class="cpp">int* p = nullptr;if(p)....         // false p是否不为nullptrif(!p)...         // true p是否为nullptr </code></pre><p><code>type* name = new type(parameters);</code></p><p><strong>运行中的程序</strong>是将所有的变量存储在一个 <strong>栈(stack)</strong> 中</p><p>当一个函数完成其任务，所有的局部变量的使命也就完成了。我们就会将这些变量占用的内存空间回收，用于存放新的数据。从技术来讲，当这些变量消失的时候，实际上就是<strong>栈被压缩了</strong></p><p>还有另外一块存储空间 - <strong>堆(heap)<strong>。<br>当你使用 <code>new</code>语句来申请空间时，就会在heap里申请一块空间，并返回一个指针。<br>并且这块内存并不会随着某个函数的运行结束而被</strong>自动释放</strong>，只会被手动<strong>free up</strong></p><p>从整体来看，内存中存储变量是连续的，但两者在<strong>生命周期上是完全无关的</strong>。故我们将这两块区域视为<strong>相对独立</strong>的。<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240129/image.6361ak1emao0.webp" alt="image"></p><pre><code class="cpp">struct ListNode {   int data;   ListNode* next;}</code></pre><p>在C++中，你<strong>不能定义一个指向引用的指针</strong>，这是不被允许的。故你可以传递<em><em>指针的引用（</em>&amp;）</em><em>，但是不能传递**指向引用的指针(&amp;</em>)**</p><p>双重指针(**)会使代码显得极为臃肿，故不推荐使用</p><pre><code class="cpp">int size(ListNode* front) {   int cnt = 0;   ListNode* tmp = front;   while (tmp != nullptr){      tmp = tmp-&gt;next;      cnt++;   }   return cnt;}int get(ListNode* front, int index) {   ListNode* tmp = front;   for (int i = 0; i &lt; index; i++) {      tmp = tmp-&gt;next;   }   return tmp-&gt;data;}void add(ListNode*&amp; front, int value) {    // ⬆️⬆️必须是引用&amp;，否则就不会影响头节点   // create a new node   ListNode* newNode = new ListNode(value);   if (front == nullptr) {      front = newNode;   } else {      ListNode* tmp = front;      while (tmp-&gt;next != nullptr) {         tmp = tmp-&gt;next;      }      tmp -&gt; next = newNode;   }}void addFirst(ListNode*&amp; front, int value) {   front = new ListNode(value, front);}void removeFirst(ListNode*&amp; front) {   if (front != nullptr) {      ListNode* tmp = front;      front = front-&gt;next;      delete tmp;   }}void remove(ListNode*&amp; front, int index) {   if (front != nullptr) {      ListNode* tmp_1 = front;      for (int i = 0; i &lt; index - 1; i++) {         tmp_1 = tmp_1-&gt;next;      }      ListNode* trash = tmp_1-&gt;next;      tmp_1-&gt;next = trash-&gt;next;      delete trash;   }}</code></pre><h2 id="Classes-and-Objects"><a href="#Classes-and-Objects" class="headerlink" title="Classes and Objects"></a>Classes and Objects</h2><ul><li>Class: 一种数据对象的模板，定义了属于这种类型的内容，包括其存储的数据和行为</li><li>数据 -&gt; <strong>成员变量</strong>(存储在对象内部的变量)</li><li>对象内部的函数和行为 -&gt; <strong>成员函数/方法</strong></li><li><strong>构造函数</strong> 可以在对象被创建、被初始化时设置对象的状态</li></ul><p>面向对象编程(OOP)的思想：你的<strong>大部分代码都与对象有关</strong>，这些对象执行任务，并与其他对象相互协作。</p><p>提供了抽象(abstraction)的概念: 我并不需要知道其内部的运行原理，我只需要知道<strong>如何去使用它</strong></p><ul><li>C++中的类被分成了两种代码文件:</li><li>.h: 头文件，负责<strong>声明</strong>(declarations)</li><li>.cpp: 源文件，负责<strong>定义</strong>(method bodies)写清楚具体的实现方式</li><li>例如你想写一个名为 <code>Foo</code>的class，就要有 <code>Foo.h &amp; Foo.cpp</code></li><li>好处在于：别人只需要看你的头文件即可知道你所定义的方法和参数，而不需要关心位于源文件的具体实现方式。</li></ul><hr><p>那么如何编写一个头文件呢？<br>⬇️这是一个基本的结构<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240130/image.6t4y9bwtydxc.webp" alt="image"></p><pre><code class="cpp">#ifndef _classname_h#define _classname_h// 预处理，防止重复声明定义class ClassName {public:                                   // in ClassName.h   ClassName(parameters);                 // constructor   returnType name(parameters);           // member functions   returnType name(parameters);           // (behavior inside   returnType name(parameters);           // each object)private:   type name;     // member variables   type name;     // (data inside each object)}; // IMPORTANT: must put a semicolon at end of class declaration(argh)#endif</code></pre><p>通过 <code>const</code>用法，你可以使得一些东西不会被改变</p><pre><code class="cpp">const int x = 4;void foo(const BankAccount&amp; ba){   ···}class BankAccount {   ····   double getBalance() const;    // 意味着getBalance将不会改变BankAccount }</code></pre><hr><p>操作符重载(Operator overloading)</p><p>unary(一元) + - ++ – * &amp; ! ~ new delete<br>binary(二元) + - * / % += -= *= /= %= &amp; | &amp;&amp; || ^ == != &lt; &gt; &lt;= &gt;= = [ ] -&gt; ( )</p><pre><code class="cpp">returnType operator op(parameters);    //.hreturnType operator op(parameters) {   //.cpp   statements;}</code></pre><p>在C++中有一个比较有趣的玩法，可以<strong>让某些函数/方法访问到private内的数据</strong>，就是在前面加上 <code>friend</code>关键字</p><hr><p><strong>Destructor 析构函数</strong></p><p>如果你的对象中涉及到了指针或者在堆中创建的新对象，那在析构函数中释放他们就很有必要了-&gt;避免内存泄漏。</p><pre><code class="cpp">~ClassName();                    // ClassName.hClassName::~ClassName() {···}   // ClassName.cpp</code></pre><h2 id="Doubly-Linked-List-Skip-Lists"><a href="#Doubly-Linked-List-Skip-Lists" class="headerlink" title="Doubly Linked List &amp; Skip Lists"></a>Doubly Linked List &amp; Skip Lists</h2><ul><li>Doubly Linked List: 每个节点都有 <code>prev</code>和 <code>next</code>两个指针。同时我们要维护两个指针 <code>front</code>和 <code>back</code>，一头一尾，这样我们就可以双向遍历Lists。缺点就是会占用更多的内存，以及维护和修改起来更为困难</li><li>Skip List: 有序的List。每个节点包含存储 <code>next</code>指针的 <code>vector</code>/<code>array</code>。使得查找、增加或者删除元素的时间复杂度都可以达到O(logN)<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240130/image.457bredn5h34.webp" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240130/image.4esn1dyqplz4.webp" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240130/image.4rsxngc83ekg.webp" alt="image"></li></ul><hr><h1 id="Part-7"><a href="#Part-7" class="headerlink" title="Part 7"></a>Part 7</h1><h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><h3 id="两种声明方式"><a href="#两种声明方式" class="headerlink" title="两种声明方式"></a>两种声明方式</h3><ol><li><strong>type name[length]</strong>;</li></ol><ul><li>位于栈上，有固定大小，内存自动释放</li></ul><ol start="2"><li><strong>type* name</strong> = new <strong>type[length]</strong>;</li></ol><ul><li>位于堆上，指针(意味着你可以<strong>创造一个更大的数组</strong>然后让指针指向<strong>新的数组</strong>)，内存不会自动释放</li></ul><p>你可以根据你所需的<strong>生命周期</strong>来<strong>选择不同的声明方式</strong>。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>由于C++是一个<strong>追求效率</strong>的语言，故在没有特殊要求的时候，它是不会遍历整个数组并设置成0的。</p><p>如果你想初始化，可以想下面这么写⬇️</p><pre><code class="cpp">type* name = new type[length](); // initialize to 0</code></pre><p>或者你也可以这么写⬇️</p><pre><code class="cpp">type name[length] {};            // initialize to 0</code></pre><p>第二种写法更类似于一种trick</p><h3 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h3><p>数组本身也是支持 <code>for-each</code>循环的。</p><pre><code class="cpp">int a[4] {1, 2, 3, 4};for(int n: a) {   cout &lt;&lt; n &lt;&lt; endl;}/* output:   1   2   3   4*/</code></pre><h3 id="一点关于栈的题外话"><a href="#一点关于栈的题外话" class="headerlink" title="一点关于栈的题外话"></a>一点关于栈的题外话</h3><pre><code class="cpp">int x = 555;int y = 777;int a[3] {1, 2, 3};cout &lt;&lt; a[-1] &lt;&lt; endl;cout &lt;&lt; a[-2] &lt;&lt; endl;/* output:   777   555*/</code></pre><p>这是为什么呢？<br>因为在栈上x, y, a是连续的，<code>a[-1]/a[-2]</code>本身的意思就是 <strong>从a的起始位置向前移1/2个int的大小</strong></p><pre><code class="cpp">void foo() {   int x = 5;   int y = 7;}void goo() {   int a;   int b;   cout &lt;&lt; a &lt;&lt; endl;   cout &lt;&lt; b &lt;&lt; endl;}int main() {   foo();   goo();   return 0;}/* output:   5   7*/</code></pre><p>这是怎么一回事呢？ 调用完 <code>foo()</code>后，<code>x&amp;y</code>就从栈上被<em>擦除</em>掉了，但是<strong>其存储的bits并没有改变</strong>，只是系统将那块内存区域标记为<strong>不再使用</strong>。随后的 <code>goo()</code>中的 <code>a&amp;b</code>就被放到了先前的这块内存上。由于两者未进行初始化，故<strong>继承</strong>了先前 <code>x&amp;y</code>的值。</p><h3 id="Vector-Stack-是如何依赖-Arrays来工作的"><a href="#Vector-Stack-是如何依赖-Arrays来工作的" class="headerlink" title="Vector/Stack 是如何依赖 Arrays来工作的"></a>Vector/Stack 是如何依赖 Arrays来工作的</h3><p>你不能通过类似于 <code>.size()</code>or <code>.length()</code>等方法来获取数组的大小。数组本身<strong>只是一块内存，其没有任何功能</strong></p><p>两者都是基于一种被我们称为 <code>unfilled array</code>来实现的。也就是其<strong>实际大小</strong>比我们<strong>已经添加</strong>的大一些。</p><p>让我们用 <code>Array</code>来实现一下 <code>Stack</code></p><pre><code class="cpp">// ArrayStack.hclass ArrayStack {   public:      ArrayStack();     // constrution      ~ArrayStack();    // destrution      // member functions(method)      // TODO: push, pop(peek), isEmpty, operator &lt;&lt;      void push(int n);      int pop();      int peek() const;      bool isEmpty() const;      friend ostream&amp;  operator &lt;&lt;(ostream&amp; out, const ArrayStack&amp; stack);   private:      //member variables      int size;      // 用于记录已添加元素数量      int capacity;  // 用于记录总容量      int* elements; // 可变性，易于维护};ostream&amp;  operator &lt;&lt;(ostream&amp; out, const ArrayStack&amp; stack);</code></pre><pre><code class="cpp">// ArrayStack.cpp#include "ArrayStack.h"ArrayStack::ArrayStack(){   size = 0;   capacity = 10;   elements = new int[capacity]();}   ArrayStack::~ArrayStack(){   delete[] elements;   // 为了区分数组与单个值，需要在delete后面加上[]                        // 因为其本质是指针，后台清理指针时，指向一个元素和指向一系列元素的处理方式不同}// member functions(method) // TODO: push, pop(peek), isEmpty, operator &lt;&lt;void ArrayStack::push(int n){      if (size &lt; capacity) {         elements[size] = n;         size++;      }else {         capacity *= 2;         int* newelements = new int[capacity];         for (int i = 0; i &lt; size; i++) {            newelements[i] = elements[i];         }         newelements[size] = n;         size++;         delete[] elements;         elements = newelements;      }}int ArrayStack::pop(){      if(!isEmpty()) {      int a = elements[size - 1];      element[size - 1] = 0;     // optional      size--;      return a;   }else {      throw "oh sh*t";   }}int ArrayStack::peek() const{   if(!isEmpty()) {      return elements[size - 1];   }else {      throw "oh sh*t";   }}bool ArrayStack::isEmpty() const{   return size == 0;    // 若为真，返回true}friend ostream&amp;  operator &lt;&lt;(ostream&amp; out, const ArrayStack&amp; stack){   out &lt;&lt; "{";   if(!stack.isEmpty()) {      out &lt;&lt; stack.elements[0];      for (int i = 1; i &lt; stack.size; i++) {         out &lt;&lt; "," &lt;&lt; stack.elements[i];      }   }   out &lt;&lt; "}";   return out;}</code></pre><p>在第一次运行时出了问题，问题在于 <code>const ArrayStack&amp; stack</code>这种调用方式，默认只能使用 <code>ArrayStack</code>中的 <code>const</code>函数。于是进行了一些修改。<strong>注意！在.cpp与.h文件中要进行同步的修改</strong></p><p>Q9: 我们对于 <code>capacity</code>的大小修改应该遵循怎样的规则呢？<br>A9: 倍数增长(*2常用)。可以确保你越来越不受<strong>扩容</strong>的困扰。</p><h3 id="shallow-copy-bug-浅拷贝错误"><a href="#shallow-copy-bug-浅拷贝错误" class="headerlink" title="shallow copy bug(浅拷贝错误)"></a>shallow copy bug(浅拷贝错误)</h3><pre><code class="cpp">ArrayStack s1;s1.push(1);s1.push(2);s1.push(3);ArrayStack s2 = s1;</code></pre><p>这会造成什么问题呢？一般来说，我们使用 <code>=</code>就是将后者的<strong>内存内容</strong>复制到前者去。这里 <code>ArrayStack</code>中s <code>ize/capacity</code>都好说，但是 <code>elements</code>是 <code>int*</code>的形式(复制也只会复制<strong>一个地址</strong>而已)，<strong>两者会共享一个数组</strong>。最后会造成下图的后果⬇️</p><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240203/image.1k3exxguyw68.webp" alt="image"></p><p>如何解决这个问题呢-&gt;Deep Copy(深拷贝)</p><ol><li>可以写一个复制构造函数 <code>ArrayStack(const ArrayStack&amp; stack)</code></li><li>可以写一个等号运算符 <code>ArrayStack&amp; operator =(const ArrayStack&amp; stack);</code></li></ol><p><strong>Rule of Three</strong>:当你在C++的class中写如下三个的任意一个的时候，你最好把三个都写上</p><ol><li>copy constructor</li><li>assignment operator</li><li>destructor</li></ol><p>或者你也可以直接从源头上断绝这种问题-&gt;<strong>禁止拷贝</strong></p><pre><code class="cpp">// ArrayStack.hprivate:   ArrayStack(const ArrayStack&amp; stack);   ArrayStack&amp; operator =(const ArrayStack&amp; stack);// In ArrayStack.cpp, don't give them any actual definition/body.</code></pre><h2 id="Graphs-图"><a href="#Graphs-图" class="headerlink" title="Graphs(图)"></a>Graphs(图)</h2><ul><li>一种数据结构，包含如下内容：</li></ul><ol><li>一组顶点(vertexes)，有时也被称为节点(nodes)</li><li>一组边(edges)，顶点之间的连接</li></ol><h3 id="一些关于图的术语"><a href="#一些关于图的术语" class="headerlink" title="一些关于图的术语"></a>一些关于图的术语</h3><ol><li>reachable: Vertex a is <em>reachable</em> from b if a path exists from a to b.</li><li>complete: If every vertex has a direct edge from every other.</li><li>connected: If every vertex can be reachable from every other.</li><li>cycle: A path which starts and ends at the same node.(一般而言，每个edge在一个path中只允许被使用一次)</li><li>loop: A edge directly from a node to itself.(许多图不允许)</li></ol><h3 id="Weighted-Graph-加权图"><a href="#Weighted-Graph-加权图" class="headerlink" title="Weighted Graph(加权图)"></a>Weighted Graph(加权图)</h3><ul><li>给每个边赋予一定的值(权重)</li><li>一般我们认为<strong>权重是非负的</strong></li><li>非加权图可视为：每个边都有相同的权重(0/1/…..)<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240203/image.15aj04p76uyo.webp" alt="image"></li></ul><h3 id="Directed-Graph-digraph-单向图"><a href="#Directed-Graph-digraph-单向图" class="headerlink" title="Directed Graph/digraph(单向图)"></a>Directed Graph/digraph(单向图)</h3><ul><li>每个edge是有方向的(带箭头)</li><li>你也可以混合加权/非加权</li></ul><h3 id="binary-tree-二叉树-Linked-List-链表"><a href="#binary-tree-二叉树-Linked-List-链表" class="headerlink" title="binary tree(二叉树)/Linked List(链表)"></a>binary tree(二叉树)/Linked List(链表)</h3><ul><li>二叉树是一个<strong>有向且无环</strong>的图</li><li>每个节点的最大入度(in-degree, 多少条边指向该节点)为1，最大出度(out-degree, 该节点指向多少个节点)为2。</li><li>链表也是类似的，入度和出度均为1</li></ul><h3 id="Stanford-BasicGraph"><a href="#Stanford-BasicGraph" class="headerlink" title="Stanford BasicGraph"></a>Stanford BasicGraph</h3><p><code>#include "basicgraph.h"</code></p><ul><li>通过这个库构建的图，是<strong>有向加权</strong>的</li><li>nodes默认是strings<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240203/image.72t0sdwwcwhs.webp" alt="image"></li></ul><table><thead><tr><th>包含的函数</th><th>描述</th></tr></thead><tbody><tr><td><code>g.addEdge(v1, v2);</code></td><td>在两个顶点之间添加一条边</td></tr><tr><td><code>g.addVertex(name);</code></td><td>向图中添加一个顶点</td></tr><tr><td><code>g.clear();</code></td><td>清除图中的所有顶点/边</td></tr><tr><td><code>g.getEdgeSet();</code></td><td>返回所有边的集合</td></tr><tr><td><code>g.getEdgeSet(v);</code></td><td>返回从顶点v出发的所有边的集合</td></tr><tr><td><code>g.getNeighbors(v);</code></td><td>返回顶点v的所有邻居顶点的集合</td></tr><tr><td><code>g.getVertex(name);</code></td><td>返回具有给定名称的顶点</td></tr><tr><td><code>g.getVertexSet();</code></td><td>返回图中所有顶点的集合</td></tr><tr><td><code>g.isNeighbor(v1, v2);</code></td><td>如果顶点v1和v2相邻则返回真（即v1到v2有一条边）</td></tr><tr><td><code>g.isEmpty();</code></td><td>如果图为空（没有顶点或边）则返回真</td></tr><tr><td><code>g.removeEdge(v1, v2);</code></td><td>删除顶点v1和v2之间的边</td></tr><tr><td><code>g.removeVertex(name);</code></td><td>删除具有给定名称的顶点</td></tr><tr><td><code>g.size();</code></td><td>返回图中顶点的数量</td></tr><tr><td><code>g.toString();</code></td><td>返回图的字符串表示，例如 “{a, b, c, a -&gt; b}”</td></tr></tbody></table><h3 id="Topological-Sort-拓扑排序"><a href="#Topological-Sort-拓扑排序" class="headerlink" title="Topological Sort(拓扑排序)"></a>Topological Sort(拓扑排序)</h3><ul><li>用于处理<strong>依赖</strong>关系</li><li>假设有一个DAG(有向无环图)</li><li>为各顶点排序，确保：<strong>如果存在A到B的边，那么A就应该在B之前</strong>。</li><li>排序的结果可能<strong>不唯一</strong></li></ul><h4 id="Kahn’s-algorithm"><a href="#Kahn’s-algorithm" class="headerlink" title="Kahn’s algorithm"></a>Kahn’s algorithm</h4><ul><li>ordering uses a list or vector</li><li>ordering:= {}</li><li>Repeat until graph is empty:<ul><li>Find a vertex v with in-degree of 0 (no incoming edges)<ul><li>if ther is no such vertex, the graph cannot be sorted; stop.</li></ul></li><li>Delete v and all of its outgoing edges from the graph.</li><li>ordering += v.</li></ul></li></ul><h4 id="Revised-algorithm"><a href="#Revised-algorithm" class="headerlink" title="Revised algorithm"></a>Revised algorithm</h4><ul><li>我们不希望破坏整个图来实现排序</li><li>map := {each vertex -&gt; its in-degree}</li><li>queue := {all vertices with in-degree  = 0}.</li><li>ordering := {}</li><li>Repeat until queue is empty:<ul><li>Dequeue the first vertex v from the queue</li><li>ordering += v.</li><li>Decrease the in-degree of all v’s neighbors by 1 in the map.</li><li>queue += {any neighbors whose in-degree is now 0}</li></ul></li><li>If all vertices are processed, success.Otherwise, there is a cycle.</li></ul><h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><p>O(V + E)<br>基本与 顶点数和边数成 线性相关</p><h3 id="三种图的表示方式"><a href="#三种图的表示方式" class="headerlink" title="三种图的表示方式"></a>三种图的表示方式</h3><h4 id="Edge-list"><a href="#Edge-list" class="headerlink" title="Edge list"></a>Edge list</h4><ul><li>利用 list、vector或数组来存储所有的edges(unordered)</li><li>每个edge存储起始&amp;终止的vertex</li><li>vertex本身并不直接进行存储，只存在于edge的数据中</li><li>优势<ul><li>找到<strong>每个vertex的in-degree</strong> O(E)</li><li>可遍历所有边</li><li>添加边很方便</li></ul></li></ul><h4 id="Adjacency-list"><a href="#Adjacency-list" class="headerlink" title="Adjacency list"></a>Adjacency list</h4><ul><li>利用linked list,Vector,Set…..存储每个vertex的neighbors</li><li>非常适合<strong>获得每个vertex的度</strong></li><li><strong>增删vertex极其麻烦</strong></li><li><strong>无法方便的获取每个vertex的入边</strong></li></ul><h4 id="Adjacency-matrix"><a href="#Adjacency-matrix" class="headerlink" title="Adjacency matrix"></a>Adjacency matrix</h4><ul><li>一个N*N的矩阵，类似于<a href="#grid">Grid</a></li><li>a[i, j] -&gt; i与j之间是否有一条edge</li><li>有向图：i-&gt;start; j-&gt;end</li><li>无向图：a[i, j] = a[j, i]</li><li>几乎没什么缺点，全是优点<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240205/image.639a9o85mrgg.png" alt="image"></li></ul><h2 id="DFS-BFS"><a href="#DFS-BFS" class="headerlink" title="DFS/BFS"></a>DFS/BFS</h2><h3 id="Depth-first-search-DFS深度优先搜索"><a href="#Depth-first-search-DFS深度优先搜索" class="headerlink" title="Depth-first search(DFS深度优先搜索)"></a>Depth-first search(DFS深度优先搜索)</h3><ul><li>搜索一点到另一点的路径</li><li>尽可能的探索<strong>每一条可能的路径</strong></li><li>没有<strong>选择性</strong>，只是找到，并非最佳/最优路径</li><li>基于<a href="#backtracking">backtracking</a></li></ul><h4 id="DFS伪代码"><a href="#DFS伪代码" class="headerlink" title="DFS伪代码"></a>DFS伪代码</h4><pre><code class="cpp">dfs from v1 to v2:   mark v1 as visited, and add it to the path;   perform dfs from each of v1's unvisited neighbors n to v2:      if dfs(n,v2) succeeds: a path is found!   if all neighbors fail: remove v1 from the path;</code></pre><h3 id="Breadth-first-search-BFS广度优先搜索"><a href="#Breadth-first-search-BFS广度优先搜索" class="headerlink" title="Breadth-first search(BFS广度优先搜索)"></a>Breadth-first search(BFS广度优先搜索)</h3><ul><li>先直接探索<strong>所有你可以直接到达的临近点</strong></li><li>如果没有到达目的地，那就重复上面的步骤，循环往复，直到到达目的地。</li><li><strong>永远返回最短/最优的路径</strong></li><li>会<strong>消耗更多的时间与空间</strong></li></ul><h4 id="BFS伪代码"><a href="#BFS伪代码" class="headerlink" title="BFS伪代码"></a>BFS伪代码</h4><pre><code class="cpp">bfs from v1 to v2:   create a queue of vertexes to visit, initially storing just v1.    mark v1 as visited.   while queue is not empty and v2 is not seen:       dequeue a vertex v from it,      mark that vertex v as visited,      and add each unvisited neighbor n of v to the queue.</code></pre><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>基本上与**顶点数(V)和边数(E)**呈线性相关</li><li><strong>O(V + E)</strong></li></ul><h3 id="Dijkstra’s-Algorithm"><a href="#Dijkstra’s-Algorithm" class="headerlink" title="Dijkstra’s Algorithm"></a>Dijkstra’s Algorithm</h3><ul><li>找到<strong>总权重最小(成本最低)的路径</strong></li><li>与<a href="#breadth-first-searchbfs%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS</a>类似，但是其采用了 <code>优先级队列(priority queue)</code></li><li>无法处理<strong>负权重</strong>，会打破算法的正常运行。但是权重为0不会有影响。</li><li>在更新 <code>pqueue</code>时，只有新cost<strong>低于</strong>当前cost时，才会更新。若相等，则不会更新。</li></ul><h3 id="A-Algorithm"><a href="#A-Algorithm" class="headerlink" title="A* Algorithm"></a>A* Algorithm</h3><ul><li>Dijkstra算法的改进版，基于<a href="#heuristic%E5%90%AF%E5%8F%91%E5%BC%8F">启发式</a>函数</li><li>所需做的改动就是<strong>加入一个启发式估计信息</strong>-&gt;该节点的成本+我估计该节点好坏程度的总和</li><li>从a到c，途径节点b -&gt; priority(b) = cost(a, b) + <strong>Heuristic(b, c)</strong></li><li>我们按照处理后的优先程度，进行探索</li><li>如果A*算法的效率差，那只有一个原因，你的启发式函数写的烂</li><li>四个大字：<strong>趋利避害</strong></li></ul><h4 id="Heuristic-启发式"><a href="#Heuristic-启发式" class="headerlink" title="Heuristic(启发式)"></a>Heuristic(启发式)</h4><ul><li>一种<strong>有预测的，基于目前已有信息的猜测</strong></li><li>指导解决<strong>接下来的问题</strong></li><li>在图的问题中，如果我们能<strong>预估中间点到达目的地时的好坏程度</strong>-&gt;启发式方法</li><li>制定一个<strong>可接受的</strong>启发是非常重要的：因为有时候这个预测可能<strong>过于乐观</strong>，导致实际结果与预测偏差过大</li><li>如果你的估计小于或等于你的正确答案，那就意味着他不会破坏你的优先队列，这也就是我们想要的。如果你的估计比正确答案差，那么就会导致较好的路径被排在后面，你无法探寻到最优的路径，从而毁掉整个算法</li></ul><h3 id="Spanning-tree-生成树🌲"><a href="#Spanning-tree-生成树🌲" class="headerlink" title="Spanning tree(生成树🌲)"></a>Spanning tree(生成树🌲)</h3><ul><li>从原图中提取出部分边，确保图中的每一个节点都相互连接，但是没有任何的回环存在。</li><li>迷宫可视为二维图的生成树</li></ul><h4 id="Minimum-spanning-tree-MST最小生成树"><a href="#Minimum-spanning-tree-MST最小生成树" class="headerlink" title="Minimum spanning tree(MST最小生成树)"></a>Minimum spanning tree(MST最小生成树)</h4><ul><li>总权重最小的生成树</li><li>利用 Kruskal’s algorithm来寻找MST<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240204/image.3hp849jz46tc.png" alt="image"></li></ul><h4 id="Kruskal’s-algorithm"><a href="#Kruskal’s-algorithm" class="headerlink" title="Kruskal’s algorithm"></a>Kruskal’s algorithm</h4><p>按照我自己的理解说一下吧：</p><ol><li>把<strong>所有的edge</strong>按<strong>权重</strong>翻到一个 <code>pqueue</code>里</li><li>pop()，然后判断<strong>这条edge是否回生成loop</strong></li><li>若不生成，就连上。生成就跳过</li><li>最后当pqueue为空时，即生成了最小生成树</li></ol><h1 id="Part-8"><a href="#Part-8" class="headerlink" title="Part 8"></a>Part 8</h1><h2 id="Inheritance-继承"><a href="#Inheritance-继承" class="headerlink" title="Inheritance(继承)"></a>Inheritance(继承)</h2><ul><li>基于原有的class生成新的class，并继承原有class的特性<ul><li>base class: Parent class that is being extended.</li><li>derived class: Child class that inherits from the base class.</li></ul></li><li>共享了很多<strong>公共的代码</strong>，降低了重复性</li></ul><pre><code class="cpp">class Name :public base class{</code></pre><ul><li><strong>overriding</strong>: 在derived class重写base class中的一个函数/方法</li><li><strong>virtual function</strong>: 只有在base class的.h文件中各函数前面声明 <code>virtual</code>的函数/方法才可以重写<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240205/image.50w15pvtrc74.webp" alt="image"></li><li><strong>Pure virtual functions</strong>: 如果你想定义一个virtual函数，这个函数的内部定义必须由每个derived class自行决定，那该如何在base class内定义呢？这么写⬇️</li></ul><pre><code class="cpp">virtual void function() = 0;// 是的。没有错，就是加一个 = 0 就可以了 </code></pre><p><em>注意：纯虚化的class是不被允许的，因为在编译器看来，这个类是一个不完整的实体(entity)</em></p><ul><li>Private inheritance(私有继承)<ul><li>和 <code>class</code>定义的 <code>private</code>和 <code>public</code>很像。就是外部代码不知道你继承了这个类</li><li>这是一个不太好的特性，如果你需要使用私有继承，那么可能<strong>意味着你的设计存在问题</strong></li></ul></li><li>Multiple inheritance(多重继承)<ul><li>有时候还不错。但是有时会大幅的增加代码的复杂性，以及导致混淆和不明确。</li><li>比如你继承的两个class中都有同一种方法，那么当你调用的时候，你用的是哪个？</li><li>类似Java等大部分语言都不支持这一特性</li></ul></li></ul><pre><code class="cpp">class Name : public Superclass1, public Superclass2, ......</code></pre><ul><li><strong>Favor composition over inheritance</strong><ul><li>先想组合，再寻思继承</li><li>如果你需要在一个类中用到 <code>Vector</code>，那就在private里直接定义一个 <code>Vector</code>来用就好了</li></ul></li></ul><h3 id="一些不应滥用inheritance的情况"><a href="#一些不应滥用inheritance的情况" class="headerlink" title="一些不应滥用inheritance的情况"></a>一些不应滥用inheritance的情况</h3><ul><li>例如：<ul><li>当你需要一个<strong>三维坐标</strong>，然后你将你的 <code>Point2D</code>加入了一个z轴坐标，拓展成 <code>Point3D</code><ul><li><code>distance()</code>会出错</li></ul></li><li>当你需要一个<strong>正方形</strong>，然后你将你的 <code>Rectangle(矩形)</code>内部修改成长和宽相同，得到 <code>Square</code><ul><li><code>Rectangle</code>支持 <code>Square</code>不支持的操作(例如 <code>setWidth()</code>)</li></ul></li><li>当你需要一个<strong>排好序的Vector</strong>，然后你将你的 <code>Vector</code>内部的 <code>add()</code>修改为每次添加后排序/插入到对应的位置，得到 <code>SortedVector</code><ul><li><code>SortedVector</code>可能会使用户懵了：刚把一个元素插入到一个 <code>index</code>里，立即check那个 <code>index</code>的元素，结果发现不是刚才放进去的元素.</li></ul></li></ul></li><li>这些inheritance都可能会导致<strong>你不得不对代码和结构进行大量修改，以避免可能出现的各类错误</strong></li><li>如果你不能<strong>毫不惊讶地用一个类替代另一个</strong>，那就是inheritance的不当使用.</li></ul><h2 id="Hashing-哈希"><a href="#Hashing-哈希" class="headerlink" title="Hashing(哈希)"></a>Hashing(哈希)</h2><ul><li><p>将<strong>较大范围的值</strong>映射到<strong>较小范围内的索引</strong>的过程</p></li><li><p>Hash Table(哈希表): An array that stores elements via hashing.</p></li><li><p>Hash function(哈希函数): An algorithm that maps values to indexes.</p></li><li><p>Hash code(哈希值): The output of a hash function for a given value.</p></li><li><p>Hash化后，所有的时间复杂度都会变成<strong>O(1)</strong></p></li><li><p>还有一个十分重要的问题：<strong>对于其他类型(除了int）的数据</strong>，我们能否<strong>获得对象的状态并将其转化成一个可重现的整数</strong></p><ul><li>例如对于字符串，可以将其所有字符转换成对应的ASCII码，并相加-&gt;该字符串的hashcode.<strong>但是这个会导致大量的碰撞</strong>，于是有人研究出来了下面的算法⬇️(也是Java在hash化string时的算法)<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240205/image.6d7at9nh3mv4.png" alt="image"></li><li>对于其他的一些数据类型，可以通过<strong>与一些奇怪的常数进行组合拼凑</strong>来使之分散化<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240205/image.3hny1cf0oy9s.webp" alt="image"></li></ul></li><li><p>若出现了<strong>冲突怎么办？</strong></p></li><li><p>—&gt; 一个合格的Hash算法需要有解决冲突的机制</p></li></ul><h3 id="Separating-chaining"><a href="#Separating-chaining" class="headerlink" title="Separating chaining"></a>Separating chaining</h3><ul><li>通过在每个index处构建一个vector/linked list来解决冲突的问题</li><li>这是大部分hash数据结构通用的解决方法，STL/Java/SPL……</li><li>add(): 放到链表表头处，很熟悉的操作了，降低时间复杂度。唯一麻烦的是<strong>你需要遍历整个链表来检查是否重复</strong>。但是，就算我们<strong>允许重复项</strong>也可以实现Set的结构(因为我们从外部看只会判断<strong>有没有</strong>  )</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240205/image.6mr1di8w6igw.png" alt="image"></p><h3 id="Rehashing"><a href="#Rehashing" class="headerlink" title="Rehashing"></a>Rehashing</h3><ul><li>当hashTable将要被填满时，重新调整其大小的过程。</li><li>一种算法是 如果链表的长度超过某个特定值，那么就可以进行重新哈希</li><li>故HashSet可以维护一个有关自身的量 -&gt; <code>load factor 负载因子</code><ul><li>(元素数量) / (HashTable长度/容量)</li><li>你可以在HashSet中设定一个双精度的常数，作为<strong>何时进行rehash的标准</strong></li><li>一般是0.75/0.66</li></ul></li><li>大小的修改<strong>要做乘法</strong>，这样才会有显著的性能改变</li></ul><h3 id="Good-hashCode-behavior"><a href="#Good-hashCode-behavior" class="headerlink" title="Good hashCode behavior"></a>Good hashCode behavior</h3><ul><li>一个合格的哈希算法要求<ul><li>(MUST)<strong>hashCode(x) == hashCode(x)</strong>,if x’s state doesn’t change</li><li>(MUST)<strong>a == b</strong> &lt;=&gt; <strong>hashCode(a) == hashCode(b)</strong>. And <strong>hashCode(a) != hashCode(b)</strong> -&gt; <strong>a != b</strong><br>-(DESIRED) Good distribution of hash codes<ul><li>For a large set of distinct values, they should generally return unique hash codes rather than often colliding into the same hash bucket.</li></ul></li></ul></li></ul><h2 id="Sorting"><a href="#Sorting" class="headerlink" title="Sorting"></a>Sorting</h2><ul><li>将一些位于数组的元素按照某些特定的要求进行排序</li><li>类似 <code>number</code>/<code>string</code>等元 素有一套<strong>自然的排序方式</strong></li></ul><h3 id="Selection-sort"><a href="#Selection-sort" class="headerlink" title="Selection sort"></a>Selection sort</h3><ul><li>遍历数组，找到最大/最小的值，放到最前面(swap)</li><li>重复遍历未排序的数组，重复上述动作，直至数组有序</li><li>O(n^2)</li></ul><pre><code class="cpp">// Rearranges elements of v into sorted order.void selectionSort(Vector&lt;int&gt;&amp; v) {    for (int i = 0; i &lt; v.size() - 1; i++) {        // find index of smallest remaining value        int min = i;        for (int j = i + 1; j &lt; v.size(); j++) {            if (v[j] &lt; v[min]) {                min = j;            }        }        // swap smallest value to proper place, v[i]        if (i != min) {            int temp = v[i];            v[i] = v[min];            v[min] = temp;        }    }}</code></pre><h3 id="Insertion-sort"><a href="#Insertion-sort" class="headerlink" title="Insertion sort"></a>Insertion sort</h3><ul><li>把每个元素插入到一个已经有序的数组中(要先遍历那个有序的数组来找位置)</li><li>原理上和<a href="#selection-sort">Selection sort</a>很像</li><li>O(n^2) -&gt; 比<a href="#selection-sort">Selection sort</a>略快一点</li></ul><pre><code class="cpp">// Function to perform insertion sort on the vectorvoid insertionSort(Vector&lt;int&gt;&amp; v) {    int i, key, j;    for (i = 1; i &lt; v.size(); i++) {        key = v[i]; // Take the current element        j = i - 1;        // Move elements of v[0..i-1], that are greater than key,        // to one position ahead of their current position        while (j &gt;= 0 &amp;&amp; v[j] &gt; key) {            v[j + 1] = v[j];            j = j - 1;        }        v[j + 1] = key; // Place the current element at its correct position    }}</code></pre><h3 id="Merge-sort"><a href="#Merge-sort" class="headerlink" title="Merge sort"></a>Merge sort</h3><ul><li>将<strong>未排序的数组分成两半</strong>，将这两部分进行<strong>排序</strong>，然后<strong>合并成一个有序的整体</strong></li><li>再结合<strong>递归</strong></li><li>O(N logN) // 合并是N，拆分是logN<br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240206/image.6fkkiyr21gn4.png" alt="image"></li></ul><pre><code class="cpp">void mergeSort(Vector&lt;int&gt;&amp; v) {   if(v.size() &gt;= 2) {      // split array in half      Vector&lt;int&gt; left = v.subList(0, v.size() / 2);      Vector&lt;int&gt; right = v.subList(v.size() / 2, v.size() - left.size());      // sort halves      mergeSort(left);      mergeSort(right);      // merge halves      int i1 = 0;      int i2 = 0;      for(int i = 0;i &lt; v.size(); i++) {         if((i2 &gt;= right.size())||(i1 &lt; left.size() &amp;&amp; left[i1] &lt;= right[i2])) {            v[i] = left[i1];            i1++;         }else {            v[i] = right[i2];            i2++;         }      }   }else {      // do nothing.   }</code></pre><h3 id="Quick-sort"><a href="#Quick-sort" class="headerlink" title="Quick sort"></a>Quick sort</h3><ul><li>某种程度上与<a href="#merge-sort">MergeSort</a>很类似，也采用了<strong>分治</strong>的思想。但快排不是<strong>稳定排序</strong>，而归并是<strong>稳定排序</strong> -&gt; <strong>这也就是为什么快排没有被稳定使用的原因</strong><ul><li>一个算法是<strong>稳定</strong>的 &lt;=&gt; 在排序前后，<strong>相等元素</strong>的相对位置<strong>不变</strong></li></ul></li><li>快排效率的核心是<strong>选择一个合适的枢轴(pivot)<strong>，你希望枢轴大概是</strong>数组的中位数</strong></li><li>详见<a href="https://lzh-xyz.github.io/2023/11/19/20231119-Sort/">Sort_Note</a></li></ul><hr><h2 id="Templates-模板"><a href="#Templates-模板" class="headerlink" title="Templates(模板)"></a>Templates(模板)</h2><ul><li>可以传递各种类型的“自己”</li></ul><pre><code class="cpp">template&lt;typename T&gt;T max(T a, T b) {   if (a &lt; b) {      return a;   }else{      return b;   }}int i = max(17, 4);string s = max(string("HI"), string("My Darling"));double d = max(3.3, 4.2);</code></pre><h3 id="Template-Class"><a href="#Template-Class" class="headerlink" title="Template Class"></a>Template Class</h3><pre><code class="cpp">// ClassName.htemplate&lt;typename T&gt;class ClassName {   ......};// ClassName.cpptype ClassName::name(parameters) {   ......}</code></pre><p>例子⬇️</p><pre><code class="cpp">template &lt;typename T&gt; class ArrayList {public:    ArrayList();    ~ArrayList();    void add(T value);    void clear();    T get(int index) const;    void insert(int index, T value);    bool isEmpty() const;    void remove(int index);    void set(int index, T value) const;    int size() const;    string toString() const;private:    T* elements;    int m_size;    int capacity;    void checkIndex(int index, int min, int max) const;    void checkResize();};</code></pre><h2 id="Standard-Template-Library-STL"><a href="#Standard-Template-Library-STL" class="headerlink" title="Standard Template Library(STL)"></a>Standard Template Library(STL)</h2><ul><li>一些C++内置的类和方法<ul><li>container(collection) 容器</li><li>algorithm             算法</li><li>functional programming</li><li>iterator              迭代器</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240207/image.66s0awp4a29s.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240207/image.2fwcrg6xty9s.webp" alt="image"></p><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240207/image.38w631jgna2.webp" alt="image"></p><h2 id="Smart-Pointer"><a href="#Smart-Pointer" class="headerlink" title="Smart Pointer"></a>Smart Pointer</h2><p>A stack-allocated container that can store a pointer to data on the heap and free it automatically later.</p><ul><li>Added to C++ in the C++11 version of the language</li><li>Prior to this, many coders used Boost library or others</li><li>C++ Smart Pointer Types</li></ul><pre><code class="cpp">#include &lt;memory&gt;</code></pre><ul><li><code>unique_ptr</code> // exactly 1 “owner”; best one</li><li><code>shared_ptr</code> // multiple “owners”; use sparingly</li><li><code>weak_ptr</code>   // use sparingly</li><li><code>auto_ptr</code>   // deprecated; do not use!</li></ul><p>Common concept: notion of “ownership” of a heap-allocated pointer; who is responsible for deleting/freeing it later?</p><pre><code class="cpp">unique_ptr&lt;T&gt; name(heapObject);void foo(){   unique_ptr&lt;ListNode&gt; p(new ListNode());   p-&gt;data = 42;   p-&gt;next = nullptr;   ...   p.reset(new ListNode());   // frees prior node   p-&gt;data = 19;   p-&gt;next = nullptr;   ...   if(p){...}                 // non-null   // node will be freed here!}</code></pre><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240207/image.1huh71rudl40.webp" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Part1&quot;&gt;&lt;a href=&quot;#Part1&quot; class=&quot;headerlink&quot; title=&quot;Part1&quot;&gt;&lt;/a&gt;Part1&lt;/h1&gt;&lt;p&gt;C++ 的语法和 Java 是大体相似的&lt;br&gt;（岂不是我学完C++可以速通Java了&lt;/p&gt;
&lt;pre&gt;&lt;code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>20231231_信</title>
    <link href="http://example.com/2023/12/31/20231231-%E4%BF%A1/"/>
    <id>http://example.com/2023/12/31/20231231-%E4%BF%A1/</id>
    <published>2023-12-31T14:18:58.000Z</published>
    <updated>2023-12-31T15:36:42.046Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7eb7b5782f85d600b5cc129e0b73046edfa0f06f9d5abde0e6f6d64714073fc7">98c6ec152bf6953f1fca972fa992a23e63d9c9469c76045fa7081e36a3d877c5e86782397c141d0cf180fb9c84b5b09176ea0085f23cda2a9f8545c17ed8ff0d31a19cdd561f61554de358feb09f62532dd0ea3658d3eddf60e9b9bf381d7d8f79114e733b956bf0055707a37542a4122738ee76b3985c49f5dafb9cb3b9072a454d2905cfca2923e3ad3eba1fc80b5d516e0c39e69a970c9a9e437ae7f24899e2857be53fd9fab8cdd303d7f4d0a1e4eebb195d9f3f80a514cbfb34a766618377fe18a568406d55fb83b4f784245b82180dfda4db25f6f8ba2ae3cb0030a4c2896b873e5d0e95adb2dfad42e4b83f41694ad8e9d418531b3c15e0d2db3b61df1369ffe22ac1fe336bfb318ccad2a63fc0bbebe3b7c458d18743fa8fad1fc61e2b2f46c4d1069ce16d8554b2742011b7d7bb4ad98634f725415bd48e80e54ca63201a1576d8d72da487b2d394aeeb909ad6528a14418dd9f91899e7082d1ab1a33a16fb1991876eb1ecffbcb6450543910a3d8b2b867b463712ebba1325cbe1c9db1c123c8d617ae5fa363617c2b7acdc1a336267d6518d9c0a0a0a0ddfee7dd2090c2e9145a22da71cbfb739624f8add814a2f77e5c7a14ecbe79c30a73e89983fc1cf2890de5be0f0680502dcdc9660b4c0828668b87bfbac9c52c61ebb460f0c0e48a97a86283f7cdb9baa2aa127643e66cfd06accf82ebeeb30c9045626e7cb91279fedf9fe5e38330d5ee55e0e3fce8916beaa8ff15cbe94e1deedd6af2ecefa1d31f5a5fedd70dc8048f0749a0d7789fbada6936925cfdb3612aa2691f2b267445b0797f5aede5156e78c3496533bf65377dd790b7cab244bab0987c2ae52ccd8a9d1769a665edfc62600b364504807e1cda5095c0c7063805f38c534f3af3cd4e2f5b7f026afce04cc03c3cbac9b7d355194e95228a79f2a2023ca7dc43f787a7d5d065f941d1be719a78af7ca9e8e2292f25b7983ccdafae30f4d257cc93bcb3a4bb8483c099d8f4aa38e97c5b0240d23a6314a271a4331392add2d12c8373574c560847c835d8c7a85e1c53ee76673dfde6c95063490a08a248e4d779fa99f300490fab9267aff818a1d161e910408e0f373118f1ef60c602b762ef9eb227f18e04d595bbd674a05530ffd76996e850e7d6c8f3461c4371fbda2a2cac0537c92690cb4f25bee65ca71314b777816063c79ddf79858ace5c72e2702389fa2af97c4341cca7f7278b96f3f9cf1db0f9e11b30d9f20c4c2c7face0cf571a2f9b27d38a513a4ae94978b371d9a2b4cd59643ba7b969657a69f053bd9d54960a9e792f668f89fde33ca66334570c0c9c4c0c0e8610a80072c2df761f76f339851d7b66737531063bdb6f62c608b44311fa119356d27226be3f2c536832fb1ac57205e008380dff56f7e88e5d9321ca6e6c31df14bdd6b3ebfa05732293a77a61b21268dc4650780af415b1641c3961c6c9c0c4acfb61c30410732f88a4481dd70d2594c329d723066cf38c215511f25dec19a317708b4ab6698a370b857096fd7b3367cd49026c43b13b464524a825a840cf17911e39a5bea7246bb7559b01fc92f53cbe8c9990dea76b85b6f47077eaffa5e9708e3be4a9f78101a3b055e46012c525b7bdef02a0bc442dcbb752080df98db2ad1bd88745594ffb125b4d19ee0c8de928f77eb05f48e7064194857e44eac0c9ef1cf5eb3b0254bc7f42f857921d6ad3497be3c5b57f08565e40b023720cd1886898669f43caf1233e39eb673290ab6943ef27d593be6f49d8e5d19f83044970f68bfa736574f4dd99e136da0a61f841760fa2b324cb699a7b023f0d360d70222896451585565a4747557495af44c4e822a035b8090a0c4236054c3131e33ad009fc50743c0e3f0d5082c063d604d5949716434e975ded50f9cf3486920320cae2c0dcab35ff38bb9d1d0febe18fd998efc8ed76d9825aefa17552aec45b1868d7180400ea2e89e5c4965426b55a172d21423567cdbe29a0b4cb0b800a9b41bc8cb5757a7793d4002fac7b916a5e43b14a1644ae866efe7bd9c414175da6c5ce7dcc9042c2161f0decdc77d103a56df139c21cb2b17fdc783dd8cd0a55eac80cecc9f7898ec6e30ed0ddae2a2dc6478f5f2e8ca6d816fa7c9f2484bec6befb6f337149f54c5442f49c2f57ce8c804f401af9431fa6e65d6e53aeade068cd4e86d5308de791a488398411db502fb96a7ca26bef8cc3c6af82d54cc69143e3f7d244e1d85d51b877fae681f3f436a3532a03f5e01274fbd58a4467ed805af75cf8c9bcce40093029d5673ff1e3649a7681196c259bf2d50aab10a75731fea9d0c99814d3b854f60bd2ccb558ff76ad87ec1b1e0ce4d85663d1c1377cc5e4730d4910f6351700e988ec9ae6634664b56ef42df4432da8f9727eed34af12b365c7319406ce51cba9b92d01775e859bc58674b3451190dff1fca32a0acb053d58e6403fdf78126802d20c04242b75f3e5288dec352d67dd647b9267cc94b3058fc06530b88d57d19a4b8e89c516d0ea7b2f0cfea5fa02bd8ef784dfbdee4f2faed9370746258cae7adbacefe4b9d499500259f352b2081995c7bcc51680ff94a21e02c238102d7f1b016d4a60ef927bdf89557cbadbecb881c283792d48bfd4edad4eeacb9aecbb45ef92442d114e4646f51c89303812cea17ad8a1085f26e5124008e5bec2de003c5079e24eefdc4f36d8212ad955e10bcfc811a68dc26e81e0ce9b01880d5ad028a3d4d5f5cacfb86721b189126d3dfe70a1d47d144694492826e75d337746a4b73c3a3ac24189ed10b05db63920c60e29aba72be332330940b29d3f2f0873a232266df6e0185968afe59f4b8989ef34b17c434890931fe58ca87e564c7b97f3ae5565cbbbdc57d2a614cd3b5ce288127ac99890f48a5394e3eaa84caff010f268e179811e2e325503aac610f55a0ab83fd809d6bc51d7ad9b7d2506dd2f27ea918945ceff5188935e1bc88db9162b00af2f95f23dd757a6f0381efe63007962943a4f44b31a876d0c2d33a318286049b40db8e1ffcbe7cfb1fcca1e57d7dbdb3f61c79f29be8529f1437a0bd5bedfa2b2a964eb603f92753b48c075116c78d7e35fefc8941424173ecbff19d1e17727bd87f25be332ee15867431cac25566f58855f2d41b3184b8a712572c7de8bc4339eabc7f6daea5561b7a95debb7e8e3629755ad689d48a6489b278ccf31eec59051473e15026b2698cd78cf0042e50f119c512d427ad69c5ddf38631ce917fb9196cc1e6592bae2229f8bae95930cb292ebbb7743b03b5fd065296a14eb7bc948f3f7acb6bc3947c3797320a079d75c0447f9fdf04a962b7ddef14bb68b93ee146b01b85c88a1b4354600fc5ed62d7ef8480ba8acb37138392f838907b8fa0e4b42a1093be8ad967db77a7824ce0b80b6ed49dafc943089c1bf79add6080f2842b0d204ec48da97aed85406b1b052f270f2be843eb84cfb01e13c6c77c63e36b93d433da6f9647748cc5c480cbc7aced67939630d3d3310e8f5e4772449e09af3a9cf90abfa183807268d6a90eb282d8ab8385b7b8c0bdf7db636531f2682a1d338d6790c2a80fa8b222fa961eecf2cf17bb013ff23d32a4caa2fbf436d5d209f114770f7ab06db078e81a2caf52619b0eda2168f882b58e88c919b2f452c482f2e9646b28356166e08c33693a226b3ded48e9124fc0bb7072cac1d21e9c2e6d054c8f8306ef7a4b2881a0b2b38b9aa485ebc5569a84cf1806019c3663ee7eeae45f7392e41e42b616995fb499ba399f6fcda2f2da929c8f377d96f3215377cd7eb889b1e508c79188e2d1e249e7dba10b2b46116a1a6f771bb30fda8afc6e21faa982bec6a63ace23440c2320faa5bbb7c04b3fcea7d6d7e118d547e49830e3bfcce4e622f96fd8ec291e61547cb0637f6b98481a12d8574f70129e4c9e8a6fe74a203fdba6811ca675737066d4a4d8a973ad4b93117b9d503df0a356345ea59fa1ad145018ac52f838a0e40667fd0421a3227270b82edba67507decf3905fc7608b5d3d276f7fe3d823c0c317d90a1ea0999d0b9e794e6bcefbe62508ffee289abb5e6066e996eb8ea46d523fd0e51d09c666ddaa9f49a07adb0dbff8a93f520a692b2b083ee1b1bd7229908a6b1fc4bd6590cde45aa72b1cc30cb24f0f44306a4f8ef63f9b45775ac14394165df0805fb209b66a960df38ca5905e89e188e0615c21c38d2e4fc6fa3ee69ea240a0d2c8a4665bbe1c4f15b7278ea7020775f05a8b9a8b22697a325a92634d85bb34671179ff54875c8d7859d56389ea5bfd80fc0dbe5269347a96b94eb9c9c4eb4225944accb36c834931ef5309fc0ef6862d96fb1d92d5e954a95d4b3f273b067b233f04e940409209fc7b402f721af9caa4b672d428745970b34692c288e7f077f28e75659b54e47cbc8f92e49949276313533676c46f36e6a1f6136a234c798d09674c3790d2880070fdf3063e1e659770840990ec4359d34f7af8ce3190d97c85b2b9278e42ec2f52a66879a588282f4c2458e290c84b60df7ba8ff7acd6902ebdea8c11ee5567bfbfb1cfdc4c0f20f36e42e7f6d86ac3c2aca02ff94221b617ce439af5dd13a54e846257e5d045306ee9dc287eb885209511d3562e45569deeed718f7da44a2da7e826c412c38951af98510213985be0a553f4be8d55b9b704d6aaddd5fa74378d9cba11138f3fd4939ca1c727d01c591a6d7f62e6b97be59ad8357a5568662ae1e638af6c56e3569acbafe8b7f7fdb2250ef442e7d54a63f2740086d74cec826dbb0703244fbda67125511311c1eb07ba89dac303f4d891f6400fefe79b505cc439b1a80a047d74ac110caa18f549314c165217806cf18274e6e49fa2117f67f5ec90d40bf31ed12c89fdef1fa7486f5a2e414d3f42072cdbf7cf358b96810bb6c73bb17e362921a72ae0f819142e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输个密码吧</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="信" scheme="http://example.com/tags/%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>20231229_期末，寒假，以及下学期</title>
    <link href="http://example.com/2023/12/29/20231229-%E6%9C%9F%E6%9C%AB%EF%BC%8C%E5%AF%92%E5%81%87%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8B%E5%AD%A6%E6%9C%9F/"/>
    <id>http://example.com/2023/12/29/20231229-%E6%9C%9F%E6%9C%AB%EF%BC%8C%E5%AF%92%E5%81%87%EF%BC%8C%E4%BB%A5%E5%8F%8A%E4%B8%8B%E5%AD%A6%E6%9C%9F/</id>
    <published>2023-12-29T15:10:23.000Z</published>
    <updated>2023-12-29T16:19:36.962Z</updated>
    
    <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=394648&amp;auto=0&amp;height=66"></iframe><p>上次写这种类型的博客还是10月24日，那是期中考试之后，成绩刚出来。当时看到成绩单，下定决心，痛定思痛，捋顺了一下思路，把各科的问题以及对应的解决思路记录了下来，并列了下TO-DO List。</p><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/Blog_Pic@master/20231229/%E6%88%AA%E5%B1%8F2023-12-29-23.29.26.4by500q3g5z4.webp" alt="TODOLIST"></p><p>目前看来，完成率还可以。下半学期基本可以说是拉足马力了，呆在正心的时间已经比呆在宿舍的时间要长了。期末的四门考试课：淑芬、近代史、程序设计、线代。只剩下<code>线代(1月4日)</code>一科了，应该问题不大，该练习的都练习到了，最近几天再把一些基本的知识点和方法看一看，把往年题的错题和一百题看一看。</p><p>这学期的学分绩还没有完全出来，只出来了<code>淑芬</code>一科——89(194/624)。其实是很不尽如人意的，但是没办法，期中扣分太多，期末无力回天😂感觉最后的学分绩排名能在150+就很不错了，等到最终的绩点出来再来Update一下吧。</p><hr><p>其实这篇文章的主要内容是即将到来的寒假的计划。目前我想了这么几件事，也算是接下来的TO-DO List吧</p><ul><li><input disabled="" type="checkbox"> 淑芬下先修</li><li><input disabled="" type="checkbox"> 大雾自学(由于大雾只有大二上，后半Part才有先修)</li><li><input disabled="" type="checkbox"> CS106X(计算机冲冲冲！)</li><li><input disabled="" type="checkbox"> 概率论与数理统计</li></ul><p>怎么说呢，感觉回到了中学那会儿的<strong>抢先抓早</strong>的打法。这四个TO-DO的Deadline还未定，不想齐头并进，还是突击来的比较爽快和高效一些。但是像<code>CS106X</code>这种课又没办法突击，让我再想想吧。</p><p>寒假还需要把体重和身体调理一下，这12月的后20天真的有些难顶，无奈了。</p><p>先写到这里吧，未完待续。</p><p>Mostly_Harmless</p><p>写于2023.12.30 凌晨0时20分 A02.2108的一张床上</p>]]></content>
    
    
      
      
    <summary type="html">&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;amp</summary>
      
    
    
    
    
    <category term="计划, 总结" scheme="http://example.com/tags/%E8%AE%A1%E5%88%92-%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>20231128_CS50_Data Stucture</title>
    <link href="http://example.com/2023/11/28/20231128-CS50_Data%20Stucture/"/>
    <id>http://example.com/2023/11/28/20231128-CS50_Data%20Stucture/</id>
    <published>2023-11-28T06:20:58.000Z</published>
    <updated>2023-11-28T08:21:52.756Z</updated>
    
    <content type="html"><![CDATA[<p>这应该是<code>CS50</code>笔记的最后一弹了，其C语言部分的最后一个lecture也是有关于<code>Data structure</code>的，今天写这些就当作复习了。</p><hr><h2 id="链表-LIST"><a href="#链表-LIST" class="headerlink" title="链表 LIST"></a>链表 LIST</h2><pre><code class="c">typedef struct node{    int number;    struct node *next;} node;</code></pre><p>This is the basic stucture of LIST. Every node has a part which contains data, and a pointer which stores the address of the next node. So that these node can be linked together one by one, forming a chain.</p><p>Let’s discuss  th below code from Malan.</p><pre><code class="c">int main(int argc, char *argv[]) // 加入命令行参数{    node *list = NULL; // 定义了一个空链表，即元素数量为0的链表    for (int i = 1; i &lt; argc; i++) // argv的第一个值是 程序的名称    {        int number = atoi(argv[i]); // atoi 将ASCII码转换为整数，只要你输入的是数字        node *n = malloc(sizeof(node));        if (n == NULL)        {            return 1;        }        n-&gt;number = number;        n-&gt;next = NULL;        n-&gt;next = list;        list = n;    }    // node *ptr = list;    // while (ptr != NULL)    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next) // 和上面的两行是等价的    {        printf("%i\n", ptr-&gt;number);    }    // 开始释放    node *ptr = list; // 回到开头    while (ptr != NULL)    {        node *next = ptr-&gt;next;        free(ptr);        ptr = next;    }    return 0;}</code></pre><p>This small program can create a LIST with numbers based on the input of the commandline arguments, and print them from front to back. After performing these operations, the memory can be freed all.</p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/WechatIMG406.5xrdesyyi2gw.webp" alt="WechatIMG406"></p><p>This photo shows that <code>HOW TO INSERT A NODE INTO A LIST</code>.</p><hr><p>Generally, if we want to read a LIST, we need a temporary pointer(like <code>ptr</code>)to traverse the entire chain, until it reaches the node we need.</p><pre><code class="c">// node *ptr = list;// while (ptr != NULL)    for (node *ptr = list; ptr != NULL; ptr = ptr-&gt;next) // 和上面的两行是等价的    {        printf("%i\n", ptr-&gt;number);    }</code></pre><p><code>node *ptr = list</code> is to create a temporary pointer<code>ptr</code>.<br><code>ptr != NULL</code> serves as a limitation, preventing access to prohibited memory or handling cases where the memory allocated for ptr was not available during its creation.<br><code>ptr = ptr-&gt;next</code> enables us to obtain the next node in the sequence after the current one.</p><hr><p>A very important thing is the freeing of the linked list. This process relies on the temp pointer, but it also involves another pointer, <code>next</code>. Nodes are deleted from the front to the back one by one.</p><pre><code class="c">    node *ptr = list; // 回到开头    while (ptr != NULL)    {        node *next = ptr-&gt;next; // 先get下一个node        free(ptr);        ptr = next;    }</code></pre><hr><p><strong>Pros:</strong></p><ol><li>Dynamic Memory Allocation: We don’t need a complete memory space; instead, the structure allows us to adjust the amount of data by creating or deleting nodes. Knowing the total number of data elements in advance is unnecessary, and there is no pre-allocation of space.</li><li>Efficient Insertion and Deletion: Due to the pointer relationships between nodes, inserting and deleting nodes in a linked list is more efficient than in arrays. The adjustment mostly relies on changing the pointer.</li><li>Minor Impact: When you change a node, the only nodes on either side of it will be impacted.</li></ol><p><strong>Cons:</strong></p><ol><li>Memory Overhead/Extra Storage for Pointers: Each node in a linked list contains both data and a pointer to the next node. This additional overhead consumes more memory compared to arrays, where only the data needs to be stored.</li><li>Sequential Access: Unlike arrays, linked lists don’t provide constant-time access to individual elements. To access an element, you must start from the head (or another known node) and traverse the whole list sequentially. This makes random access time, especially for a large list.</li></ol><p><code>Doubly-Linked Lists</code> has a more pointer to contain the address of the previous node.</p><h2 id="Trees-🌲"><a href="#Trees-🌲" class="headerlink" title="Trees 🌲"></a>Trees 🌲</h2><p>The stucture of a tree contains many nodes, and every node has three parts<code>*left</code> <code>*right</code> <code>data</code>.</p><p><strong>Similarities:</strong></p><ol><li>Nodes.</li><li>Pointers.</li></ol><p><strong>Differences:</strong></p><ol><li>Hierarchical Structure: A tree is <strong>a hierarchical data structure</strong>, comprising a root node, internal nodes, and leaf nodes. The connections between nodes form a tree-like structure. In contrast, a linked list is <strong>a linear structure</strong>, where nodes have only predecessors and successors, creating a linear sequence.</li><li>Node Relationships: In a linked list, each node usually has <strong>a single successor</strong>. In a tree, nodes can have <strong>multiple child nodes</strong>, establishing parent-child relationships. A node’s parent is the node directly above it, and its children are the nodes directly below.</li><li>Traversal Patterns: Linked lists are typically traversed <strong>linearly</strong>, from the head to the tail or vice versa. Trees can be traversed <strong>in various ways</strong>, such as pre-order, in-order, and post-order traversals.</li></ol><p><strong>Binary search trees are another data structure that can be used to store data more efficiently such that it can be searched and retrieved.</strong></p><p><strong>If the BST has a balance, the time complexity is O(log n) for all cases.</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/trees1.19cxz5qrey1s.webp" alt="trees1"></p><pre><code class="c">bool search(node *tree, int number){    if (tree == NULL)    {        return false;    }    else if (number &lt; tree-&gt;number)    {        return search(tree-&gt;left, number);    }    else if (number &gt; tree-&gt;number)    {        return search(tree-&gt;right, number);    }    else if (number == tree-&gt;number)    {        return true;    }}</code></pre><h2 id="Hashing-and-Hash-Tables-哈希化-和-哈希表"><a href="#Hashing-and-Hash-Tables-哈希化-和-哈希表" class="headerlink" title="Hashing and Hash Tables 哈希化 和 哈希表"></a>Hashing and Hash Tables 哈希化 和 哈希表</h2><p><strong>Hashing</strong> is the idea of taking a value and being able to output a value that becoms a shortcut to it later.<br><strong>A hash table</strong> is a fantastic combination of both arrays and linked lists. When implemented in code, a hash table is an array of pointers to nodes.<br><strong>A hash function</strong> is an algorithm that reduces a larger value to something small and predictable. Generally, this function takes in an item you wish to add to your hash table, and returns an integer representing the array index in which the item should be placed.</p><p>For example, hasing <em>apple</em> may hash as a value of <code>1</code>, and <em>berry</em> may be hashed as <code>2</code>. Therefore, finding <em>apple</em> is as easy as aksing the hashed algorithm where <em>apple</em> is stored.<br>However, if we have a lot of words to store, relying solely on the first character to hash them is inefficient and not ideal. In such cases, it becomes necessary to create a larger hash table.<br><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/hash1.1tgun3ha4d5s.webp" alt="hash1"><br><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/hash2.122mvup0op7k.webp" alt="hash2"></p><p><em>You, as the programmer, have to make a decision about the advantages of <strong>using more memory to have a large hash table and potentially reducing search time</strong> or <strong>using less memory and potentially increasing search time.</strong></em></p><hr><h2 id="Tries-🌲"><a href="#Tries-🌲" class="headerlink" title="Tries 🌲"></a>Tries 🌲</h2><p><strong>Tries are always searchable in constant time.</strong></p><p><strong>One downside to Tries is that they tend to take up a large amount of memory. Notice that we need 26 X 5 = 120 <code>nodes</code> just to store <em>Hagrid!</em></strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/tries1.2ksls3umjg8w.webp" alt="tries1"></p><p><strong>Harry would then be stored as follows:</strong></p><p><img src="https://jsd.cdn.zzko.cn/gh/MostlyHarmlessxyz/Blog_Pic@master/tries2.20f1qgbvjdpc.webp" alt="tries2"></p><hr><p>Goodbye, CS50! Have a nice day!</p><p>Mostly_Harmless</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这应该是&lt;code&gt;CS50&lt;/code&gt;笔记的最后一弹了，其C语言部分的最后一个lecture也是有关于&lt;code&gt;Data structure&lt;/code&gt;的，今天写这些就当作复习了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;链表-LIST&quot;&gt;&lt;a href=&quot;#链表-LIS</summary>
      
    
    
    
    
    <category term="Notes" scheme="http://example.com/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>CARE7_CHATGPT</title>
    <link href="http://example.com/2023/11/20/CARE7-CHATGPT/"/>
    <id>http://example.com/2023/11/20/CARE7-CHATGPT/</id>
    <published>2023-11-20T03:04:41.000Z</published>
    <updated>2023-12-31T14:06:32.541Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4fb1e53c97b21a3e2f7b91548971548c69ba3417cf61325e198b4f05af62f89e">bd25ed9264b080267271e137e33d0ce1c2bbccdc98003fe4014325307c3e2d14e94855f283ecb759d00b11f8989a7a4b460fc15b698abf9ae08d149c5be8e74235a5be3fc0bdd6b56f01e8b84ad1dad525e5e4b90cf30443d32afb22981a492a</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">输个密码吧</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">Here&#39;s something encrypted, password is required to continue reading.</summary>
    
    
    
    
    <category term="CARE" scheme="http://example.com/tags/CARE/"/>
    
  </entry>
  
  <entry>
    <title>20231119_排序算法 Sort</title>
    <link href="http://example.com/2023/11/19/20231119-Sort/"/>
    <id>http://example.com/2023/11/19/20231119-Sort/</id>
    <published>2023-11-19T15:09:59.000Z</published>
    <updated>2023-11-20T02:09:19.943Z</updated>
    
    <content type="html"><![CDATA[<p>写点排序算法的笔记：</p><h2 id="插入排序-InsertionSort-O-n-2"><a href="#插入排序-InsertionSort-O-n-2" class="headerlink" title="插入排序 InsertionSort O(n^2)"></a>插入排序 InsertionSort O(n^2)</h2><pre><code>void insertSort(int arr[], int begin, int end){    // int length = end - begin + 1;    for (int i = begin + 1; i &lt; end + 1; i++)    {        for (int j = i; j &gt; begin; j--)        {            if (arr[j] &lt; arr[j - 1])            {                swap(&amp;arr[j], &amp;arr[j - 1]);            }else            {                break;            }        }    }}</code></pre><p>插入排序的本质就是排个头，先把第一个固定住，然后看第二个，第二个要是比第一个矮，就swap一下。</p><p>然后看第三个，第三个有没有第二个矮，要是矮，swap，此时第三个变成了第二个，再判断一下它和第一个的关系…………</p><p>循环往复，最后就排序完毕了。</p><hr><h2 id="快速排序-QuickSort-O-nlogn"><a href="#快速排序-QuickSort-O-nlogn" class="headerlink" title="快速排序 QuickSort O(nlogn)"></a>快速排序 QuickSort O(nlogn)</h2><pre><code>void QuickSort(int array[], int low , int high){       if(low&lt;high){    int index = array[low];    int i = low;    int j = high;    while (i&lt;j)    {        while (i&lt;j &amp;&amp; array[j] &gt;= index)        {            j--;        }        if (i&lt;j)        {            swap(&amp;array[i], &amp;array[j]);            i++;        }        while (i&lt;j &amp;&amp; array[i]&lt;index)        {            i++;        }        if(i&lt;j)        {            swap(&amp;array[i], &amp;array[j]);            j--;        }     }    array[i] = index;    QuickSort(array,low,i-1);    QuickSort(array,i+1,high);    }}</code></pre><p>快速排序是我接触的第一个排序算法，也是第一个利用到了分治和递归思想的算法。</p><p>说大白话就是<strong>分堆</strong>，我们先选一个“标准/标杆”(index), 这里我直接选的是第一项，然后我们把所有小于index的元素，都swap到index左边，大于index的元素都swap到右边。这样我们就获得了两堆数。之后对着这两堆数进行递归操作，反复的分堆分堆，分到什么时候呢？分到每个堆只有一个数字了，这也就意味着我们分完了。</p><p>在分堆的过程也是有讲究的，我们从数组的两端向中间移动。</p><pre><code>while (i&lt;j &amp;&amp; array[j] &gt;= index){    j--;}if (i&lt;j) // 这个判断就是防止因为i &gt;= j导致while终止，误操作swap，下面的if也是同理{    swap(&amp;array[i], &amp;array[j]);    i++; // 注意这个i++；}</code></pre><p>上面这段就是从最右端往左走，大的我们就留下，一旦发现小的，我们就直接swap到左边，同时从左边swap一个数字过来。可能你想问，如果我们swap过来的那个数字也小于index，应该放在左边怎么办呢？不急，我们接着往下看。</p><pre><code>while (i&lt;j &amp;&amp; array[i]&lt;index){    i++;}if(i&lt;j){    swap(&amp;array[i], &amp;array[j]);    j--;} </code></pre><p>这段开始我们从左端往右走，和上面的同理，小的我们留下，一旦发现大的，我们直接swap到右边，同时从右边swap一个数字过来。这个疑问又出现了，我们如果swap了一个大于index数字过来怎么办？</p><p>还好，循环会解决这些疑问。</p><p>当你进入下一轮最外层的while循环时，我们首先就会判断上一轮swap过来的**array [ j ]**满不满足我们的需求，如果不满足，果断扔回去。第二个也是同理。</p><p>就这样，不断的把数字扔来扔去，我们就得到了一个排好序的数组。</p><hr><h2 id="并归排序-mergeSort-O-nlogn"><a href="#并归排序-mergeSort-O-nlogn" class="headerlink" title="并归排序 mergeSort O(nlogn)"></a>并归排序 mergeSort O(nlogn)</h2><pre><code>void merge(int arr[], int left, int mid, int right){    int i, j, k;    int l = mid - left + 1;    int r = right - mid;    // 创建两个临时数组 L/R    int *L = (int *)malloc(l * sizeof(int));    int *R = (int *)malloc(r * sizeof(int));    // 把数字放进去    for (i = 0; i &lt; l; i++)    {        L[i] = arr[left + i];    }    for (j = 0; j &lt; r; j++)    {        R[j] = arr[mid + 1 + j];    }    // 开始分吧    i = 0;    j = 0;    k = left; // 众神归位    while (i &lt; l &amp;&amp; j &lt; r)    {        if (L[i] &lt;= R[j])        {            arr[k] = L[i];            i++;        }        else        {            arr[k] = R[j];            j++;        }        k++;    }    // 把剩下的元素处理干净    while (i &lt; l)    {        arr[k] = L[i];        i++;        k++;    }    while (j &lt; r)    {        arr[k] = R[j];        j++;        k++;    }    // free一下，养成好习惯    free(L);    free(R);}void mergeSort(int arr[], int left, int right){    if (left &lt; right) // 啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊，不要忘了比较这个啊啊啊啊啊啊啊啊啊啊啊啊啊啊    {        int mid = left + (right - left) / 2;        mergeSort(arr, left, mid);        mergeSort(arr, mid + 1, right);        merge(arr, left, mid, right);    }}</code></pre><p>并归排序的实质，在我理解看来就是局部的有序，然后进行整合。我们通过递归，获得了大量的size为2(或1)的有序的子数组，然后我们选两个，因为在他们内部已经有序了，所以我们比第一个数字的大小，谁大谁放第一个…………就这样，两个有序数组合并成了一个大的有序数组，最终实现了排序。</p><hr><p>先写到这里，未完待续</p><p>Mostly_Harmless</p><p>写于2023.11.20 上午十时</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写点排序算法的笔记：&lt;/p&gt;
&lt;h2 id=&quot;插入排序-InsertionSort-O-n-2&quot;&gt;&lt;a href=&quot;#插入排序-InsertionSort-O-n-2&quot; class=&quot;headerlink&quot; title=&quot;插入排序 InsertionSort O(n^2)&quot;</summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>20231117_指针，地址，字符串</title>
    <link href="http://example.com/2023/11/17/20231117-Notes/"/>
    <id>http://example.com/2023/11/17/20231117-Notes/</id>
    <published>2023-11-17T00:19:16.000Z</published>
    <updated>2023-11-17T06:55:47.797Z</updated>
    
    <content type="html"><![CDATA[<p>写一下CS50学习过程中关于指针和地址部分的笔记和心得，其实就是在下面的注释部分，但是还是整理一下。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;cs50.h&gt;int main(void){    int n = 50;    char *s = "HI!";    int *p = &amp;n; // p 是一个 指向int类型变量 的地址 的 整数 8 bytes    // p 用来存储地址    printf("%i\n", n);    printf("%p\n", p); // %p 获取地址 &amp;n    // p 存储 n的位置 OR p 指向 n的位置    printf("%i\n", *p);    // 打印 p所指向的那个东西，De-reference 解引用=    printf("%p\n", s);    printf("%s\n", s);    // %s (String) 不仅仅是打印了个变量值，更是根据你提供的地址找到了TA！    // 这块一定要理解好，printf不需要找到*s,他只需要找到s，也就是这个字符串的第一位(s[0])开始的地方，然后遍历到\0就可以了，所以    // 我们这里没有写 *s，而是直接s。因为*s对应的就是s[0]这么一个单字母了，我们不需要这个    printf("%s\n", s + 1);    // s + 1 就是将起始位置向后移动了一位，于是只会打印出 “I!”    printf("%c %c\n", s[0], *(s + 0));    // %c 打印 *s 的字符 就是相当于s[0]，因为s指向的就是这个字符串起始位置，也就是H所在的位置    printf("%c %c\n", s[1], *(s + 1));    printf("%c %c\n", s[2], *(s + 2));    // 其实类似于 s[i] 的这种 “语法糖” ，在编译时是这样处理的：    // s[i] --&gt; *(s + i)    // 不用在乎数据类型的问题，编译器会自动为你换算    // 所以让我们做点禁忌的事情    // printf("%c\n", *(s + 20000));    // Segmentation fault (core dumped)    // 访问了不该访问的内存    // strcmp 做了个什么事情呢？    // 比如 s, t 是两个strings    // 我们怎么判断他们是否相等？    // i form 1 to n 判断 *(s + i) ?= *(t + i)    // strcmp(s, t) 就是帮你干了这么件事情    // 若是相同的，return 0;    // 若是字典序 s &gt; t, return 1;    // 若是字典序 s &lt; t, return -1;    string m = get_string("m: ");    string t = get_string("t: ");    printf("%p\n", m);    printf("%p\n", t);}</code></pre><p>其实指针部分的主要问题就是C语言对于 * 这个符号的“滥用”。</p><p>1.int *p = &amp;n;<br>此时*的作用是<strong>定义指针</strong>，p 是一个<strong>指向int类型变量的地址</strong>的<strong>整数</strong>，大小为8 bytes。</p><p>p 可以理解为存储了<strong>n的位置</strong>，你知道p，也就能找到n，并且n在内存中的位置是确定的，尽管n的数值会改变，但是这个变量所在的位置是在其被定义的那个时候就确定了。</p><p>2.printf(“%i\n”, *p);<br>此时*的作用就是<strong>De-reference 解引用指针</strong>，寻找到p对应的那个“东西”。</p><hr><p>剩下的就是一些细枝末节的东西，例如：</p><p>%p就是打印p所指向的<strong>地址</strong><br>e.g:printf(“%p\n”, p); 输出的就是0x16b6c710c，也就是n所在的地址。</p><p>对于字符串 (char数组) 而言，printf中的%s，你只需要提供你想要打印的起始位置，printf函数会自动替你完成“<strong>往下走，直到\0</strong>”的步骤。</p><p>e.g:</p><pre><code>char *s = "HI!";printf("%p\n", s); // out:0x16ae1f108printf("%s\n", s); // out:HI! printf("%s\n", s + 1); // out:I!</code></pre><p>我们这里没有写 *s，而是直接写s。因为*s对应的就是s[0]所对应的这么一个单字母(H)了，我们不需要这个，我们需要的是起始位置，也就是起始的地址。</p><p>类似于 s[i] 的这种 “语法糖” ，在编译时是这样处理的：<strong>s[i] –&gt; *(s + i)</strong><br>不用担心，编译器会为你做好一切，这类语法🍬还是很好用的。</p><hr><p>来点<strong>禁忌</strong>的事情</p><p>比如我们写这么一个东西</p><pre><code>printf("%c\n", *(s + 200000));</code></pre><p>我们想访问一下 s后200000位内存存着些什么，但是运行的时候就是**Segmentation fault (core dumped)**，你访问了（我访问了/计算机访问了）不该访问的内存。</p><hr><p>我们再围绕字符串写一点点东西，比如<strong>strings.h</strong>库中的<strong>strcmp</strong>函数，它的实现原理就是：输入s, t两个strings。然后开始判断 *(s + i) ?= *(t + i)，其中i从0到n遍历。</p><p>若是相同的，return 0;<br>若是字典序 s &gt; t, return 1;<br>若是字典序 s &lt; t, return -1;</p><p>Mostly_Harmless</p><p>写于2023.11.16 下午二时</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;写一下CS50学习过程中关于指针和地址部分的笔记和心得，其实就是在下面的注释部分，但是还是整理一下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;cs50.h&amp;gt;

int main(void)
{
    </summary>
      
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>20231011_新创世纪</title>
    <link href="http://example.com/2023/10/11/20231011-%E6%96%B0%E5%88%9B%E4%B8%96%E7%BA%AA/"/>
    <id>http://example.com/2023/10/11/20231011-%E6%96%B0%E5%88%9B%E4%B8%96%E7%BA%AA/</id>
    <published>2023-10-11T11:31:53.000Z</published>
    <updated>2023-10-11T11:33:04.373Z</updated>
    
    <content type="html"><![CDATA[<p>新创世纪</p><p>Hello，World！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;新创世纪&lt;/p&gt;
&lt;p&gt;Hello，World！&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
