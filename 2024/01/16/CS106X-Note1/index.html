<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>CS106X_Note1</title><meta name="description" content="May the Force be with you"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Part1C++ 的语法和 Java 是大体相似的（岂不是我学完C++可以速通Java了
using namespace name;

其中 namespace就是变量的作用域(scope)
这种写法的好处就是我们可以让各个文件中相同名字的函数名、变量名、类名 各自独立。例如我们有很多类似于cout的标识符，如歌你需要用cout来打印你的内容，那就代表着你不能将一个变量命名为cout(这样会导致冲突)
如果你在两个不同的namespace中使用了相同名称的变量、方法或者类的时候，这都是OK的。
你在代码开头打上using namespace xxx;，这代表你希望获得xxx中所有东西的命名，以及你希望在程序中可以访问其所有内容。
例如：cout的全称是std::cout，这代表它是一个位于std names.."><meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Mostly_Harmless的碎碎念" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Mostly_Hamrless's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">CS106X_Note1</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Part1"><span class="toc-text">Part1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part2"><span class="toc-text">Part2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Function"><span class="toc-text">Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Strings"><span class="toc-text">Strings</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-O-Stream"><span class="toc-text">I&#x2F;O Stream</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Grid"><span class="toc-text">Grid</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part3"><span class="toc-text">Part3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector-aka-list"><span class="toc-text">Vector(aka list)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector-insert"><span class="toc-text">Vector insert</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Efficiency"><span class="toc-text">Efficiency</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Part4"><span class="toc-text">Part4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList"><span class="toc-text">LinkedList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract-data-types-ADTs"><span class="toc-text">Abstract data types (ADTs)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stacks-and-queues"><span class="toc-text">Stacks and queues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stacks"><span class="toc-text">Stacks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue"><span class="toc-text">Queue</span></a></li></ol></li></ol></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">CS106X_Note1</h1><time class="has-text-grey" datetime="2024-01-16T02:16:21.000Z">2024-01-16</time><article class="mt-2 post-content"><h1 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h1><p>C++ 的语法和 Java 是大体相似的<br>（岂不是我学完C++可以速通Java了</p>
<pre><code class="cpp">using namespace name;
</code></pre>
<p>其中 <code>namespace</code>就是变量的作用域(scope)</p>
<p>这种写法的好处就是我们可以让各个文件中相同名字的函数名、变量名、类名 <strong>各自独立</strong>。<br>例如我们有很多类似于<code>cout</code>的标识符，如歌你需要用<code>cout</code>来打印你的内容，那就代表着你不能将一个变量命名为cout(这样会导致冲突)</p>
<p>如果你在两个不同的<code>namespace</code>中使用了相同名称的变量、方法或者类的时候，这都是OK的。</p>
<p>你在代码开头打上<code>using namespace xxx;</code>，这代表你希望获得<code>xxx</code>中所有东西的命名，以及你希望在程序中可以访问其所有内容。</p>
<p>例如：<code>cout</code>的全称是<code>std::cout</code>，这代表它是一个位于<code>std namespace</code>的变量。<br>但是我们一遍遍打 <strong>std::</strong> 有些痛苦，加上<code>using namespace std;</code>，就可以不用在<code>cout</code>的前面加上<code>std::</code>了。</p>
<hr>
<p><code>cin</code>是一个糟糕的用法</p>
<p><code>cin&gt;&gt;(int age)</code>是语法错误，无法编译。</p>
<p>FUCK，Vscode 无法使用StanfordLib，你妈的。</p>
<p>cin无法判断用户输入的内容是否匹配对应的类型，所以我们不用。</p>
<p>我们用<code>simpio.h</code>中的<code>getInteger("prompt")</code>,<code>getReal("prompt")</code>,<code>getLine("prompt")</code>,<code>getYesOrNo("prompt")</code>.</p>
<hr>
<h1 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h1><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><pre><code class="cpp">double circleArea(double r) {
    return 3.14159265359 * r * r;
}
</code></pre>
<ol>
<li><p>可以利用函数指针来将一个函数作为参数传入另一个函数，也就是回调(call back)</p>
</li>
<li><p>C++对类型转换较为宽容，类似于<code>Java</code>和<code>Python</code>。例如你传入<code>1</code>到<code>circleArea</code>中，会自动转换为<code>1.0</code></p>
</li>
<li><p>C++允许默认参数<code>default parameters</code>，这是C++的一个特性，C不具备。它允许你在函数中声明一个具有默认值的参数。如果在调用函数的时候没有为这个参数提供值，它将会自动使用默认值。</p>
</li>
</ol>
<pre><code class="cpp">void printLine(int width = 10, char letter = '*') {
    for (int i = 0; i &lt; width; i++) {
        cout &lt;&lt; letter;
    }
}
···
printLine(7, '?'); // ???????
printLine(5);      // *****
printLine();       // **********
</code></pre>
<p>需要注意的一点是：<strong>有默认值的参数必须在参数列表的末尾</strong>，否则函数无法判断你的参数是传递给谁的。我们也不能跳过第一个默认值，去直接给第二个默认值参数传值。默认参数只能<strong>从右至左连续地省略</strong>。</p>
<ol start="4">
<li>一切的函数必须在使用之前就被声明或定义。这一点和C是一致的。如果有大量的函数需要被声明的话，那就可以单独建立一个头文件，然后在main函数的文件头include一下”.h”。<br>所有的默认参数值在开头的声明处写明就好，如果在函数定义处重申一遍默认值，编译器会报错。例如下面：</li>
</ol>
<pre><code class="cpp">void song(int times = 5);
····
void song(int times) {
    ·····
}
</code></pre>
<ol start="5">
<li>数学函数<br><code>#include &lt;cmath&gt;</code><br>以下来自ChatGPT:</li>
</ol>
<p><strong>三角函数</strong>:</p>
<ul>
<li><code>sin(double x)</code>: 计算角 x（以弧度为单位）的正弦。</li>
<li><code>cos(double x)</code>: 计算角 x（以弧度为单位）的余弦。</li>
<li><code>tan(double x)</code>: 计算角 x（以弧度为单位）的正切。</li>
<li><code>asin(double x)</code>: 计算 x 的反正弦值，结果以弧度为单位。</li>
<li><code>acos(double x)</code>: 计算 x 的反余弦值，结果以弧度为单位。</li>
<li><code>atan(double x)</code>: 计算 x 的反正切值，结果以弧度为单位。</li>
<li><code>atan2(double y, double x)</code>: 计算以点 (x, y) 为坐标的角度，结果以弧度为单位。</li>
</ul>
<p><strong>指数和对数函数</strong>:</p>
<ul>
<li><code>exp(double x)</code>: 计算 e 的 x 次幂。</li>
<li><code>log(double x)</code>: 计算 x 的自然对数（基数是 e）。</li>
<li><code>log10(double x)</code>: 计算 x 的常用对数（基数是 10）。</li>
<li><code>pow(double base, double exp)</code>: 计算 base 的 exp 次幂。</li>
</ul>
<p><strong>平方根和绝对值函数</strong>:</p>
<ul>
<li><code>sqrt(double x)</code>: 计算 x 的平方根。</li>
<li><code>cbrt(double x)</code>: 计算 x 的立方根。</li>
<li><code>abs(int n)</code> / <code>fabs(double x)</code>: 计算整数或浮点数 x 的绝对值。</li>
</ul>
<p><strong>取整函数</strong>:</p>
<ul>
<li><code>ceil(double x)</code>: 计算大于或等于 x 的最小整数。</li>
<li><code>floor(double x)</code>: 计算小于或等于 x 的最大整数。</li>
<li><code>round(double x)</code>: 返回 x 四舍五入到最接近的整数。</li>
</ul>
<p><strong>其他函数</strong>:</p>
<ul>
<li><code>fmod(double x, double y)</code>: 返回 x 除以 y 的余数。</li>
<li><code>hypot(double x, double y)</code>: 计算直角三角形的斜边长度，给定两个边长 x 和 y。</li>
</ul>
<ol start="6">
<li>值语意(value semantics) / 引用语意(reference semantics)</li>
</ol>
<ul>
<li>值语意：当变量(int, double, char)作为参数传入函数时，只会<strong>复制它们的值</strong>，两者是完全独立的</li>
<li>引用语意：当较为复杂的对象或者数组作为参数传入函数时，会使用引用语意。两者是关联在一起的</li>
<li>当然，你可以自己选择语意的类型，例如你写一个<code>swap</code>函数。需要注意的是，这里的<code>int&amp; a, int&amp; b</code>的写法和<strong>指针</strong>是不同的：引用更像给<strong>变量起一个别名</strong>，你使用a, b就和使用x, y是一样的，而不是像是指针一样去访问地址。你也不需要用什么*a, *b之类的去<strong>解引用</strong>。你也就不可以将字面值作为一个引用参数传入函数中去</li>
</ul>
<pre><code class="cpp">void swap(int&amp; a, int&amp; b) {
   int temp = a;
   a = b;
   b = temp;
}
····
swap(x, y);
</code></pre>
<ul>
<li>我们也可以通过引用参数来实现<strong>一次返回多个值</strong>的操作，例如下面：我在<code>datingRange</code>中对min, max做的任何操作，其实都是直接作用在<code>main</code>中的young, old上的。</li>
</ul>
<pre><code class="cpp">void datingRange(int age, int&amp; min, int&amp; max) {
   min = age / 2 + 7;
   max = (age - 7) * 2;
}
int main() {
   int young;
   int old;
   datingRange(48, young, old);
   ·····
}
</code></pre>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p><code>#include &lt;string&gt;</code> &amp; <code>string s = "hello";</code></p>
<p>C++中的字符串支持运算符<code>Operators</code>，例如：</p>
<ul>
<li>Concatenation串联 +/+=</li>
</ul>
<pre><code class="cpp">string s1 = "Mar";
s1 += "ty"; // "Marty"
</code></pre>
<ul>
<li><p>Q1:为什么有了<code>+</code>这种操作，在<code>cout</code>中还要用<code>&lt;&lt;</code>呢？</p>
</li>
<li><p>A1:因为串联操作<strong>仅支持string+string/char</strong>，对于int、double等类型无效</p>
</li>
<li><p>Compare比较 利用 == != &lt; &lt;= &gt; &gt;= 根据ASCII码大小，注意<strong>大写字母的ASCII码小</strong></p>
</li>
</ul>
<pre><code class="cpp">string s2 = "Cynthia";
if (s1 &gt; s2 &amp;&amp; s2 != "Joe") { // true
   ···
}
</code></pre>
<ul>
<li><p>operator overloading操作符重载<br>这是一种C++特有的语言特性，你可以<strong>重新定义操作符，让它们能处理不同的数据类型</strong>。Compare这里就用到了这一特性</p>
</li>
<li><p>Mutable可变性</p>
</li>
</ul>
<pre><code class="cpp">s1.append(" Stepp");       //"Marty Stepp"
s1.erase(3, 2);            //"Mar  Stepp"
s1[6] = 'o';               //"Mar  Stopp"
</code></pre>
<ul>
<li>Q2:<code>append</code>和<code>+=</code>的区别是?</li>
<li>A2:前者是<strong>直接修改原有的string</strong>，后者是<strong>创建了一个新的string</strong>，相比之下，内存方面会有一些差异。</li>
</ul>
<hr>
<p>下面是一些string内部定义的一些函数：</p>
<table>
<thead>
<tr>
<th>函数调用</th>
<th>解释和用法</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.append(str)</code></td>
<td>向字符串 <code>s</code> 的末尾追加另一个字符串 <code>str</code>。</td>
</tr>
<tr>
<td><code>s.assign(str)</code></td>
<td>将字符串 <code>s</code> 的内容替换为字符串 <code>str</code> 的副本。</td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>清除字符串 <code>s</code> 中的所有内容，使其变为空字符串。</td>
</tr>
<tr>
<td><code>s.compare(str)</code></td>
<td>比较字符串 <code>s</code> 和 <code>str</code>。返回值 &lt; 0 表示 <code>s</code> 小于 <code>str</code>，0 表示两者相等，&gt; 0 表示 <code>s</code> 大于 <code>str</code>。</td>
</tr>
<tr>
<td><code>s.empty()</code></td>
<td>如果字符串 <code>s</code> 为空返回 <code>true</code>，否则返回 <code>false</code>。</td>
</tr>
<tr>
<td><code>s.erase(pos, len)</code></td>
<td>从字符串 <code>s</code> 中移除从 <code>pos</code> 位置开始的 <code>len</code> 个字符。</td>
</tr>
<tr>
<td><code>s.find(str, pos)</code></td>
<td>从字符串 <code>s</code> 中的 <code>pos</code> 位置开始查找子字符串 <code>str</code>。如果找到，返回子字符串的起始位置；否则返回 <code>std::string::npos</code>。</td>
</tr>
<tr>
<td><code>s.rfind(str, pos)</code></td>
<td>从字符串 <code>s</code> 中的 <code>pos</code> 位置开始回头查找子字符串 <code>str</code>。如果找到，返回子字符串的起始位置；否则返回 <code>std::string::npos</code>。 (pos为空，则默认从末尾开始)</td>
</tr>
<tr>
<td><code>s.length()</code></td>
<td>返回字符串 <code>s</code> 中的字符数。</td>
</tr>
<tr>
<td><code>s.replace(pos, len, str)</code></td>
<td>将字符串 <code>s</code> 中从 <code>pos</code> 开始的 <code>len</code> 个字符替换为字符串 <code>str</code>。</td>
</tr>
<tr>
<td><code>s.substr(pos, len)</code></td>
<td>返回一个新字符串，包含从字符串 <code>s</code> 的 <code>pos</code> 位置开始的 <code>len</code> 个字符。</td>
</tr>
<tr>
<td><code>s.insert(pos, str)</code></td>
<td>在字符串 <code>s</code> 的 <code>pos</code> 位置插入字符串 <code>str</code>。</td>
</tr>
</tbody></table>
<p>下面是<code>StanfordLib</code>中<code>strlib.h</code>的函数</p>
<table>
<thead>
<tr>
<th>Function name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>endswith(str, suffix)</code></td>
<td>如果字符串以给定的文本结束，则为真</td>
</tr>
<tr>
<td><code>startswith(str, prefix)</code></td>
<td>如果字符串以给定的文本开始，则为真</td>
</tr>
<tr>
<td><code>integerToString(int)</code></td>
<td>将整数转换成字符串</td>
</tr>
<tr>
<td><code>realToString(double)</code></td>
<td>将实数转换成字符串</td>
</tr>
<tr>
<td><code>stringToInteger(str)</code></td>
<td>将字符串转换成整数</td>
</tr>
<tr>
<td><code>stringToReal(str)</code></td>
<td>将字符串转换成实数</td>
</tr>
<tr>
<td><code>equalsIgnoreCase(s1, s2)</code></td>
<td>如果s1和s2有相同的字符，忽略大小写，则为真</td>
</tr>
<tr>
<td><code>toLowerCase(str)</code></td>
<td>返回字符串的小写版本</td>
</tr>
<tr>
<td><code>toUpperCase(str)</code></td>
<td>返回字符串的大写版本</td>
</tr>
<tr>
<td><code>trim(str)</code></td>
<td>返回去除周围空白的字符串</td>
</tr>
</tbody></table>
<hr>
<p>C++中有两种并行的字符串存储处理方式-C(char arrays)/C++(string objects)</p>
<p>类似于<code>"Hi there"</code>就是<code>C string</code>，当你打出<code>s1 = "xxx"</code>,其实后台默认做了个转换，将<code>C string</code>转换为了<code>C++ string</code>并存储在<code>s1</code>中。</p>
<p>一切适用于C++ string的特性都不适用于C string。</p>
<ul>
<li>Q3:什么时候会出现Bug呢？</li>
<li>A3:例如<code>string s2 = "Hi" + "there";</code> 这是一个<code>C-string</code> + <code>C-string</code>,这个bug甚至不会导致编译错误，只是会使你的程序崩溃。因为这里只是在<strong>将地址相加</strong>，并返回一个<strong>不知道在什么地方的地址</strong>。正确的写法应该是**<code>string s2 = string("Hi") + "there";</code>,先将<code>Hi</code>转换为<code>C++-string</code>,再进行处理，就OK了。</li>
<li>同理，<code>C-string</code> + <code>char/int.....</code>都是不行的</li>
</ul>
<h2 id="I-O-Stream"><a href="#I-O-Stream" class="headerlink" title="I/O Stream"></a>I/O Stream</h2><p><code>#include &lt;fstream&gt;</code><br>由于<code>继承</code>的机制，例如：<code>cin</code>-&gt;<code>ifstream</code>,<code>cout</code>-&gt;<code>ofstream</code> </p>
<p>⬇️<code>ifstream</code></p>
<table>
<thead>
<tr>
<th>成员函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>f.clear();</code></td>
<td>重置流的错误状态（如果有的话）</td>
</tr>
<tr>
<td><code>f.close();</code></td>
<td>停止读取文件</td>
</tr>
<tr>
<td><code>f.eof();</code></td>
<td>如果流已经过了文件末尾（EOF），则返回真</td>
</tr>
<tr>
<td><code>f.fail();</code></td>
<td>如果最后一次读取调用失败（例如 EOF），则返回真</td>
</tr>
<tr>
<td><code>f.get();</code></td>
<td>读取并返回一个字符</td>
</tr>
<tr>
<td><code>f.open("filename");</code></td>
<td>用给定的C字符串打开文件（如果传递了C++字符串，可能需要写 <code>.c_str()</code>）</td>
</tr>
<tr>
<td><code>f.open(s.c_str());</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>f.unget(ch);</code></td>
<td>取消读取一个字符</td>
</tr>
<tr>
<td><code>f &gt;&gt; var;</code></td>
<td>从输入文件读取数据到变量（类似 cin）；一次读取一个由空白分隔的标记</td>
</tr>
<tr>
<td><code>getline(f&amp;, s&amp;);</code></td>
<td>将输入行读取到字符串，通过引用；返回成功/失败的真/假指示器</td>
</tr>
</tbody></table>
<p><strong>open</strong> a file,<strong>read</strong> each line,<strong>close</strong> it.</p>
<pre><code class="cpp">// read and print every line of a file
#include &lt;fstream&gt;
...

ifstream input;
input.open("poem.txt"); 
string line;
while (getline(intput, line)) {
   cout &lt;&lt; line &lt;&lt; endl;
}
input.close();
</code></pre>
<p>一个常见的错误⬇️</p>
<pre><code class="cpp">// incorrect (why?)
while (!input.fail()) {
   string line;
   getline(input, line);
   cout &lt;&lt; line &lt;&lt; endl;
}
</code></pre>
<p>问题点在于：<code>getline</code>读取到文件的末尾时，并不会立刻将<code>input</code>的<code>fail</code>状态设置成<code>true</code>，而是先设置<code>eof</code>，当下一次尝试读取时(即读取一个<code>eof</code>状态的文件，才会将他的<code>fail</code>状态更为<code>true</code>)。这就会产生一个问题：最后一次读取<code>input</code>的时候失败了，没有对<code>line</code>进行任何更改，也就导致<em>最后一行输出了两次</em>，随后才会终止while循环 </p>
<hr>
<p><code>#include &lt;sstream&gt;</code></p>
<p><code>istringstream</code>可以将一整个<code>string</code>读取进来，然后逐个<code>word</code>进行处理</p>
<pre><code class="cpp">// read specific word tokends from a string
istringstream input("Jenny Smith 8675309");
string first, last;
int phone;
input &gt;&gt; first &gt;&gt; last;
input &gt;&gt; phone;
cout &lt;&lt; first &lt;&lt; " " &lt;&lt; last &lt;&lt; " " &lt;&lt; phone &lt;&lt; endl;
// Jenny Smith 8675309
</code></pre>
<pre><code class="cpp">istringstream input2("To be or not to be");
string word; 
while (input2 &gt;&gt; word) { 
   cout &lt;&lt; word &lt;&lt; endl;
}
</code></pre>
<p><code>ostringstream</code>可以创建一个<code>string</code>的<code>buffer</code>缓冲区，将你的输出存储起来。最后使用<code>str</code>来读取其内容。</p>
<pre><code class="cpp">ostringstream output;
int age = 42, iq = 79;
output &lt;&lt; "My age is " &lt;&lt; age &lt;&lt; endl;
output &lt;&lt; "and my IQ is " &lt;&lt; iq &lt;&lt; endl;
string result = output.str();
cout &lt;&lt; result &lt;&lt; endl;
// My age is 42\nand my IQ is 79\n
</code></pre>
<p><code>StanfordLib</code>-<code>filelib.h</code></p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>createDirectory(name);</code></td>
<td>用给定的名称创建一个新目录</td>
</tr>
<tr>
<td><code>deleteFile(name);</code></td>
<td>从磁盘中删除一个文件</td>
</tr>
<tr>
<td><code>fileExists(name)</code></td>
<td>如果给定的文件在磁盘上存在，则返回真</td>
</tr>
<tr>
<td><code>getCurrentDirectory()</code></td>
<td>返回C++程序目录的字符串形式</td>
</tr>
<tr>
<td><code>isDirectory(name), isFile(name)</code></td>
<td>基于文件路径的类型返回真</td>
</tr>
<tr>
<td><code>openFile(ifstream&amp;, name);</code></td>
<td>方便地使用C++字符串打开文件</td>
</tr>
<tr>
<td><code>promptUserForFile(ifstream&amp;, prompt)</code></td>
<td>重复提示用户输入现有文件的名称</td>
</tr>
<tr>
<td><code>readEntireFile(ifstream&amp;, Lines&amp;);</code></td>
<td>将文件数据读入到行的集合中</td>
</tr>
<tr>
<td><code>renameFile(oldname, newname);</code></td>
<td>更改文件的名称</td>
</tr>
</tbody></table>
<hr>
<h2 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h2><p><code>#include "grid.h"</code><br>一种<code>collection</code>容器-&gt;<strong>存储数据的数据结构</strong>，数据的独立片段则被称为<strong>elements</strong>元素。</p>
<p><code>Grid</code>是二维数组,**一定要标明元素的数据类型。默认值是0/false(bool)</p>
<p>需要强调的一点是：<strong>当你想把一个<code>Grid</code>作为参数传入到函数当中去的时候，<code>Copying</code>是很慢的，严重拖慢效率，直接reference(&amp;)引用传递就好</strong></p>
<p>还需要强调的一点是：<strong>当你不希望你传入的<code>Grid</code>被修改时，请善用<code>const</code></strong></p>
<pre><code class="cpp">// constructing a Grid
Grid&lt;int&gt; matrix(3, 4);
martix[0][0] = 75;
...
// or specify elements in {}
Grid&lt;int&gt; matrix = {
   {75,24,3,3},
   {23,4,5,4},
   {1,2,1,1}
};
</code></pre>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>Grid&lt;type&gt; name(r, c);</code></td>
<td>创建一个给定行数/列数的网格；如果省略，则创建一个空的0x0网格</td>
</tr>
<tr>
<td><code>g[r][c];</code></td>
<td>返回给定行/列的值</td>
</tr>
<tr>
<td><code>g.fill(value);</code></td>
<td>设置每个格子为给定的值</td>
</tr>
<tr>
<td><code>g.inBounds(r, c)</code></td>
<td>如果给定位置在网格内，则返回真</td>
</tr>
<tr>
<td><code>g.numCols()</code> 或 <code>g.width()</code></td>
<td>返回列数</td>
</tr>
<tr>
<td><code>g.numRows()</code> 或 <code>g.height()</code></td>
<td>返回行数</td>
</tr>
<tr>
<td><code>g.resize(nRows, nCols);</code></td>
<td>将网格调整为新的大小，并丢弃旧内容</td>
</tr>
<tr>
<td><code>g[r][c] = value;</code> 或 <code>g.set(r, c, value);</code></td>
<td>在给定行/列存储值</td>
</tr>
<tr>
<td><code>g.toString()</code></td>
<td>返回网格的字符串表示形式，例如 <code>"{{3, 42}, {-7, 1}, {5, 19}}"</code></td>
</tr>
<tr>
<td><code>ostr &lt;&lt; g</code></td>
<td>打印网格，例如 <code>{{3, 42}, {-7, 1}, {5, 19}}</code></td>
</tr>
</tbody></table>
<hr>
<h1 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h1><h2 id="Vector-aka-list"><a href="#Vector-aka-list" class="headerlink" title="Vector(aka list)"></a>Vector(aka list)</h2><p><code>#include "vector.h"</code></p>
<p>依旧是一个<code>collection</code> 容器，负责<strong>从0开始索引存储内容</strong>，一个可以<strong>动态调整大小</strong>的数组。</p>
<pre><code class="cpp">// initialize a vector containing 5 integers
//          index 0  1  2  3  4
Vector&lt;int&gt; nums {1, 2, 3, 4, 5} //不需要加"="

Vector&lt;string&gt; names;
names.add("Tom");       //{"Tom"}
names.add("Jay");       //{"Tom", "Jay"}
names.insert(0, "Liu")  //{"Liu", "Tom", "Jay"}
</code></pre>
<ul>
<li>Q4: 为什么不用<code>Arrays</code>?</li>
<li>A4: 1. Arrays有着固定的大小，且很难更改其大小。  2. 无法判断访问是否越界，是否会访问到垃圾内存上。  3.没有那些实用的函数</li>
</ul>
<p>一些常用的函数如下⬇️</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>v.add(value);</code> 或 <code>v += value;</code> 或 <code>v += v1, v2, ..., vN;</code></td>
<td>在向量末尾添加一个或多个值</td>
</tr>
<tr>
<td><code>v.clear();</code></td>
<td>移除所有元素</td>
</tr>
<tr>
<td><code>v[i]</code> 或 <code>v.get(i);</code></td>
<td>返回给定索引处的值</td>
</tr>
<tr>
<td><code>v.insert(i, value);</code></td>
<td>在给定索引之前插入值，并将后续的值向右移动</td>
</tr>
<tr>
<td><code>v.isEmpty();</code></td>
<td>如果向量不包含任何元素，则返回真</td>
</tr>
<tr>
<td><code>v.remove(i);</code></td>
<td>移除/返回给定索引处的值，并将后续的值向左移动</td>
</tr>
<tr>
<td><code>v[i] = value;</code> 或 <code>v.set(i, value);</code></td>
<td>在给定索引处替换值</td>
</tr>
<tr>
<td><code>v.subList(start, length);</code></td>
<td>返回索引子范围的新向量</td>
</tr>
<tr>
<td><code>v.size();</code></td>
<td>返回向量中元素的数量</td>
</tr>
<tr>
<td><code>v.toString();</code></td>
<td>返回向量的字符串表示形式，例 如 <code>"{{3, 42, -7, 15}}"</code></td>
</tr>
<tr>
<td><code>ostr &lt;&lt; v;</code></td>
<td>打印向量中的元素</td>
</tr>
</tbody></table>
<p>C++在<code>c++17</code>后开始有了<strong>模板推断</strong>的特性，也就是你在<code>&lt;&gt;</code>输入为空的话，编译器会<strong>自行判断数据类型</strong></p>
<p>下面是一个小练习，写一个函数，目的是删除整个<code>vector</code>里所有的<code>string s</code></p>
<pre><code class="cpp">void removeAll(Vector&lt;string&gt;&amp; v, string s) {
   for (int i = v.size() - 1; i &gt;= 0; i--) {
      if (v[i] == s) {
         v.remove(i);
      }
   }
}
</code></pre>
<ul>
<li><strong>注意⚠️！！</strong> <strong>是<code>Vector</code>,V要大写</strong></li>
</ul>
<h3 id="Vector-insert"><a href="#Vector-insert" class="headerlink" title="Vector insert"></a>Vector insert</h3><p><code>Vector</code>内部是用<code>Arrays</code>来实现的，那么是如何实现动态容量的呢？</p>
<p>由于<code>Arrays</code>本身并没有调整大小的功能，所以size总会比我们实际所需的大一些。例如我们创建了一个包含<code>6个int的Vector</code>，那么他的实际大小可能是10/20/30… 但是<strong>这个实际大小确实是固定的</strong>，当我们所需的大小超过了目前的实际大小，那么就会<strong>重新创建</strong>一个实际大小更大的<code>Arrays</code>，<strong>并把原来的数据Copy过去</strong></p>
<hr>
<h2 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h2><p>一种通过代码来判断计算机资源使用情况的方法：通常与<strong>速度(运行时间)/内存(占用空间)<strong>有关，大多数都是</strong>参考运行时间</strong></p>
<p>为了方便评估，我们有如下假设：</p>
<ul>
<li>A single statement’s runtime = 1</li>
<li>A function call’s runtime = (sum of runtime of statements in function’s body)</li>
<li>A loop of N iterations   ‘ runtime = (N * (loop body’s runtime))</li>
</ul>
<p>下面是一个例子：⬇️</p>
<pre><code class="cpp">statement1;                // runtime = 1

for (int i = 1; i &lt;= N; i++) {      // runtime = N^2
    for (int j = 1; j &lt;= N; j++) {  // runtime = N
        statement2;
    }
}

for (int i = 1; i &lt;= N; i++) {      // runtime = 3N
    statement3;
    statement4;
    statement5;
}
// total = N^2 + 3N + 1
</code></pre>
<p>通常来说我们只关心<strong>影响运行时间的最大因素</strong>，并将<strong>表达式中的参数都忽略掉</strong>。例如上面👆这个例子我们就可以用O(N^2)来概括</p>
<hr>
<h1 id="Part4"><a href="#Part4" class="headerlink" title="Part4"></a>Part4</h1><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><code>#include "list.h"</code><br><code>LinkedList</code>提供了和<code>Vector</code>几乎一样的函数。</p>
<pre><code class="cpp">LinkedList&lt;int&gt; list; // 要声明元素存储类型
for (int i = 1; i &lt;= 8; i++) {
   list.add(10 * i); // {10, 20, 30, 40, 50, 60, 70, 80}
}
</code></pre>
<p>一个笑话：计算机科学家讨厌三件东西,redundancy(冗余),inefficiency(低效)和redundancy(冗余)</p>
<ul>
<li>Q5:为什么要在已经有<code>Vector</code>的情况下，还要在设计一个几乎相同的collection <code>LinkedList</code>呢？</li>
<li>A5:因为两者内部是不同的实现方式，前者是<code>Arrays</code>，后者是<code>Nodes</code></li>
</ul>
<hr>
<h2 id="Abstract-data-types-ADTs"><a href="#Abstract-data-types-ADTs" class="headerlink" title="Abstract data types (ADTs)"></a>Abstract data types (ADTs)</h2><p>一类<strong>数据类型和操作方法</strong>的集合，主要关注<strong>这个集合能做什么</strong>，而不是<strong>它如何做什么</strong></p>
<p>我们可以将<code>Vector</code>和<code>LinkedList</code>都归类为<code>list</code>.其他的一些ADTs还有：<code>stack, queue, set, map, graph</code></p>
<h2 id="Stacks-and-queues"><a href="#Stacks-and-queues" class="headerlink" title="Stacks and queues"></a>Stacks and queues</h2><p><img src="https://cdn.jsdelivr.net/gh/MostlyHarmlessxyz/picx-images-hosting@master/20240116/1705372931222.webp" alt="1705372931222"></p>
<h3 id="Stacks"><a href="#Stacks" class="headerlink" title="Stacks"></a>Stacks</h3><p><code>#include "stack.h"</code></p>
<ul>
<li>Add/remove from “top” only. Last-In, First-Out (LIFO)</li>
<li>元素按照插入的顺序进行存储。我们认为他们没有序号(index)</li>
<li>只能对最上面的(最后一个插入的)元素进行操作(add/remove/examine)</li>
<li>基础的一些操作⬇️</li>
<li><strong>push</strong>: Add an element to the top.</li>
<li><strong>pop</strong>:  Remove the top element.</li>
<li><strong>peek</strong>: Examine the top element.</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>s.isEmpty()</code></td>
<td>O(1)</td>
<td>如果栈没有元素则返回真</td>
</tr>
<tr>
<td><code>s.peek()</code></td>
<td>O(1)</td>
<td>返回栈顶元素但不移除它；如果栈为空则抛出错误</td>
</tr>
<tr>
<td><code>s.pop()</code></td>
<td>O(1)</td>
<td>移除并返回栈顶元素；如果栈为空则抛出错误</td>
</tr>
<tr>
<td><code>s.push(value);</code></td>
<td>O(1)</td>
<td>将给定值放到栈顶</td>
</tr>
<tr>
<td><code>s.size()</code></td>
<td>O(1)</td>
<td>返回栈中元素的数量</td>
</tr>
</tbody></table>
<pre><code class="cpp">Stack&lt;int&gt; s;              // {}

s.push(42);                // {42}
s.push(-3);                // {42, -3}
s.push(17);                // {42, -3, 17}

cout &lt;&lt; s.pop() &lt;&lt; endl;   // 17  (s is {42, -3})
cout &lt;&lt; s.peek() &lt;&lt; endl;  // -3  (s is {42, -3})
cout &lt;&lt; s.pop() &lt;&lt; endl;   // -3  (s is {42})
</code></pre>
<p><code>Stack</code>内部是通过<code>Arrays</code>或者<code>Vector</code>实现的</p>
<ul>
<li>“bottom” = index 0</li>
<li>“top”    = index (size - 1)   (便于进行操作)</li>
</ul>
<p>当然，你也可以用<code>LinkedList</code>来实现</p>
<h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><p><code>#include "queue.h"</code></p>
<ul>
<li>Add to “back” only; remove from “front” only. First-In, First-Out(FIFO)</li>
<li>元素按照按照插入顺序进行存储，没有index</li>
<li>只能在队尾<code>add</code>，在前面<code>examine/remove</code></li>
<li>基础的一些操作⬇️</li>
<li><strong>enqueue</strong>: Add an element to the back.</li>
<li><strong>dequeue</strong>: Remove the front element.</li>
<li><strong>peek</strong>:    Examine the front element.</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>q.dequeue()</code></td>
<td>O(1)</td>
<td>移除并返回队列前端的值；如果队列为空则抛出错误</td>
</tr>
<tr>
<td><code>q.enqueue(value);</code></td>
<td>O(1)</td>
<td>在队列后端放置给定的值</td>
</tr>
<tr>
<td><code>q.isEmpty()</code></td>
<td>O(1)</td>
<td>如果队列没有元素则返回真</td>
</tr>
<tr>
<td><code>q.peek()</code></td>
<td>O(1)</td>
<td>返回队列前端的值但不移除；如果队列为空则抛出错误</td>
</tr>
<tr>
<td><code>q.size()</code></td>
<td>O(1)</td>
<td>返回队列中元素的数量</td>
</tr>
</tbody></table>
<p>和<code>Stacks</code>一样，必须将<strong>所有的元素出列</strong>才可以遍历它们。</p>
<pre><code class="cpp">// process (and destory) an entire queue
while (!q.isEmpty()) {
   do something with q.dequeue();
}
</code></pre>
<p>Another version:</p>
<pre><code class="cpp">int size = q.size(); // 要注意，queue是FIFO，这一套操作下来，其实整体是没有改变的，先出来，再塞到末尾。这种方式不会丢失内容
for (int i = 0; i &lt; size; i++) {
   do something with q.dequeue();
   (including possibly re-adding it to the queue)
}
</code></pre>
<pre><code class="cpp">void mirror (Queue&lt;string&gt;&amp; p) {
    Stack&lt;string&gt; s;
    int size = p.size();
    string tmp;
    for (int i = 0; i &lt; size; i++) {
        tmp = p.dequeue();
        s.push(tmp);
        p.enqueue(tmp);
    }
    for (int i = 0; i &lt; size; i++) {
        p.enqueue(s.pop());
    }
}
</code></pre>
<hr>
<p>P16</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2023/12/31/20231231-%E4%BF%A1/" title="20231231_信"><span class="has-text-weight-semibold">下一页: 20231231_信</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Haojen/Claudia-theme-blog" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Mostlyharmlessxyz"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Mostly_Hamrless 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>